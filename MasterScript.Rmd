---
title: "Tracking Document"
author: "M. Jarvis-Cross"
output: html_document
---

# Required Packages:

```{r, include = FALSE}
library(readr)
library(tidyverse)
library(deSolve)
library(GillespieSSA)
library(rstan)
library(bayesplot)
library(brms)
library(reshape2)
library(MCMCvis)
library(cowplot); library(grid); library(gridExtra)
```

# Models, Forms, and Associated Dynamics

+--------------+---------------------+----------------------------+--------------------------+
|              | Antia et al.        | Fenton and Perkins         | Mod. Fenton and Perkins  |
+==============+=====================+============================+==========================+
| Type I       | NA                  | 1.  Stable limit cycle     | 1.  Damping oscillations |
+--------------+---------------------+----------------------------+--------------------------+
| Type II      | Stable, extirpation | 1.  Stable limit cycle     | 1.  Stable limit cycle   |
|              |                     | 2.  Divergent oscillations | 2.  Damping oscillations |
+--------------+---------------------+----------------------------+--------------------------+
| Type III     | NA                  | 1.  Stable limit cycle     | 1.  Damping oscillations |
|              |                     | 2.  Damping oscillations   |                          |
+--------------+---------------------+----------------------------+--------------------------+

## Antia et al. (1994)

The proposed model (taken from [this paper](https://www.journals.uchicago.edu/doi/pdf/10.1086/285686?casa_token=KoTwpSI4VIgAAAAA:1UwxU-BP01lj_yWWFDzuI3Qq82ltSGIERhcHyMAs0VpHaLtw05LP2W2pEBBv-hMdqcgl5u-fpxWHoQ)):

$\frac{dP}{dt} = rP - kPI$, if $P < D$, where $D = 10^9$. If $P < D$, $P \rightarrow 0$.

$\frac{dI}{dt} = \rho I(\frac{P}{P + \phi})$

+---------+----------------------------------------------------------------------------------------+--------------+
| Symbol  | Parameter                                                                              | Value        |
+=========+========================================================================================+==============+
| $P$     | Parasite abundance                                                                     | $1**$        |
+---------+----------------------------------------------------------------------------------------+--------------+
| $I$     | Host immune cell abundance                                                             | $1**$        |
+---------+----------------------------------------------------------------------------------------+--------------+
| $r$     | Replication rate of parasite                                                           | $0.1 - 10.0$ |
+---------+----------------------------------------------------------------------------------------+--------------+
| $k$     | Rate at which parasites are destroyed by host's immune system                          | $10^{-3}$    |
+---------+----------------------------------------------------------------------------------------+--------------+
| $\rho$  | Maximum replication rate of host's immune system                                       | $1$          |
+---------+----------------------------------------------------------------------------------------+--------------+
| $\phi$  | Parasite density at which replication rate of host's immune system is half its maximum | $10^3$       |
+---------+----------------------------------------------------------------------------------------+--------------+
| $D$     | Lethal within-host parasite abundance                                                  | $10^9$       |
+---------+----------------------------------------------------------------------------------------+--------------+

## Fenton and Perkins (2010)

The proposed model (taken from [this paper](https://www.cambridge.org/core/journals/parasitology/article/abs/applying-predatorprey-theory-to-modelling-immunemediated-withinhost-interspecific-parasite-interactions/7CDBE1EBC4768B76D32B6DC3757DC96F)):

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

With TI functional response, $f(P)=\beta P$

With a TII functional response, $f(P)=\frac{\beta P}{1+h \beta P}$

With a TIII functional response, $f(P)=\frac{\beta P^2}{1+h \beta P^2}$

+----------+------------------------------------------------------------------------+--------------+
| Symbol   | Parameter                                                              | Value        |
+==========+========================================================================+==============+
| $P$      | Parasite abundance                                                     | $1$          |
+----------+------------------------------------------------------------------------+--------------+
| $I$      | Host immune cell abundance                                             | $1$          |
+----------+------------------------------------------------------------------------+--------------+
| $r$      | *Per capita* growth rate of parasite                                   | $0.05 - 0.1$ |
+----------+------------------------------------------------------------------------+--------------+
| $e$      | Immune cell proliferation as stimulated through contact with parasites | $0.1$        |
+----------+------------------------------------------------------------------------+--------------+
| $\delta$ | Decay rate of immune system                                            | $0 - 0.01$   |
+----------+------------------------------------------------------------------------+--------------+
| $\beta$  | Rate at which immune cells consume parasites                           | $0.05$       |
+----------+------------------------------------------------------------------------+--------------+
| $h$      | Handling time of parasite by host immune system                        | $0-10$       |
+----------+------------------------------------------------------------------------+--------------+

## Modified Fenton and Perkins (2010)

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=b + ef(P)I - \delta I$

+----------+------------------------------------------------------------------------+--------------+
| Symbol   | Parameter                                                              | Value        |
+==========+========================================================================+==============+
| $P$      | Parasite abundance                                                     | $1$          |
+----------+------------------------------------------------------------------------+--------------+
| $I$      | Host immune cell abundance                                             | $1$          |
+----------+------------------------------------------------------------------------+--------------+
| $r$      | *Per capita* growth rate of parasite                                   | $0.05 - 0.1$ |
+----------+------------------------------------------------------------------------+--------------+
| $e$      | Immune cell proliferation as stimulated through contact with parasites | $0.1$        |
+----------+------------------------------------------------------------------------+--------------+
| $\delta$ | Decay rate of immune system                                            | $0 - 0.01$   |
+----------+------------------------------------------------------------------------+--------------+
| $\beta$  | Rate at which immune cells consume parasites                           | $0.05$       |
+----------+------------------------------------------------------------------------+--------------+
| $h$      | Handling time of parasite by host immune system                        | $0-10$       |
+----------+------------------------------------------------------------------------+--------------+
| $b$      | Immigration of immune cells in absence of infection                    | $35$         |
+----------+------------------------------------------------------------------------+--------------+

# GLOBAL FRAMEWORK

# Deterministic Simulations

## Antia et al. (1994)

This system is stable, and moves towards extirpation of the parasite.

```{r}
Antia_Model <- function(t, y, p1){
  r <- p1[1]; k <- p1[2]; p <- p1[3]; o <- p1[4] 
  P <- y[1]; I <- y[2]
  dP = r*P - k*P*I
  dI = p*I*(P/(P + o))
  list(c(dP, dI))
}
r <- 0.2; k <- 0.01; p <- 1; o <- 1000 
parms <- c(r, k, p, o)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 50, 0.1)
results <- lsoda(N0, TT, Antia_Model, parms, verbose = FALSE)
Antia_Det <- data.frame(results); colnames(Antia_Det) <- c("Time", "P", "I")
write.csv(Antia_Det, "0_Data/0_Deterministic/Antia_Det.csv")

plot(Antia_Det$Time, Antia_Det$P, type = "l", main = "Deterministic Simulation of Antia et al. (1994) Model", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(Antia_Det$Time, Antia_Det$I, col = "cornflowerblue", lwd = 2)
```

## Fenton and Perkins (2010)

### Hollings Type I Functional Response

This system is neutrally stable, and exhibits stable oscillations.

```{r}
FP_T1 <- function(t, y, p){
  r <- p[1]; B <- p[2]; e <- p[3]; delta <- p[4]
  P <- y[1]; I <- y[2]
  dP = r*P - I*B*P
  dI = e*B*P*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; e <- 0.1; delta <- 0.01
parms <- c(r, B, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 500, 1)
results <- lsoda(N0, TT, FP_T1, parms)
FP_1_Det <- data.frame(results); colnames(FP_1_Det) <- c("Times", "P", "I")
write.csv(FP_1_Det, "0_Data/0_Deterministic/FP_1_Det.csv")

plot(FP_1_Det$Times, FP_1_Det$P, type = "l", ylim = c(0, max(FP_1_Det$P)), main = "Deterministic Simulation of Fenton and Perkins (2010) Model", sub = "Hollings Type I Functional Response", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(FP_1_Det$Times, FP_1_Det$I, col = "cornflowerblue", lwd = 2)
```

### Hollings Type II Functional Response

This system is unstable, and can exhibit:

-   Stable oscillations

-   Divergent oscillations

#### Stable Limit Cycle

```{r}
FP_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; h <- 0; e <- 0.1; delta <- 0.01
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, FP_T2, parms)
FP_2_SLC_Det <- data.frame(results); colnames(FP_2_SLC_Det) <- c("Times", "P", "I")
write.csv(FP_2_SLC_Det, "0_Data/0_Deterministic/FP_2_SLC_Det.csv")

plot(FP_2_SLC_Det$Times, FP_2_SLC_Det$P, type = "l", ylim = c(0, max(FP_2_SLC_Det$P)), main = "Deterministic Simulation of Fenton and Perkins (2010) Model", sub = "Hollings Type II Functional Response, Stable Limit Cycle", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(FP_2_SLC_Det$Times, FP_2_SLC_Det$I, col = "cornflowerblue", lwd = 2)
```

#### Divergent Oscillations

```{r}
FP_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 0.05; B <- 0.05; h <- 0.1; e <- 0.1; delta <- 0.01
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 2000, 0.1)
results <- lsoda(N0, TT, FP_T2, parms)
FP_2_DO_Det <- data.frame(results); colnames(FP_2_DO_Det) <- c("Times", "P", "I")
write.csv(FP_2_DO_Det, "0_Data/0_Deterministic/FP_2_DO_Det.csv")

plot(FP_2_DO_Det$Times, FP_2_DO_Det$P, type = "l", ylim = c(0, max(FP_2_DO_Det$P)), main = "Deterministic Simulation of Fenton and Perkins (2010) Model", sub = "Hollings Type II Functional Response, Divergent Oscillations", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(FP_2_DO_Det$Times, FP_2_DO_Det$I, col = "cornflowerblue", lwd = 2)
```

### Hollings Type III Functional Response

This system can exhibit:

-   Stable oscillations

-   Damping oscillations

Conditions for stability are as follows: $e>2 \delta h$

#### Stable Limit Cycle

```{r}
FP_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 0.04; B <- 0.05; h <- 10; e <- 0.2; delta <- 0.01; print(e > 2*delta*h)
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, FP_T3, parms)
FP_3_SLC_Det <- data.frame(results); colnames(FP_3_SLC_Det) <- c("Times", "P", "I")
write.csv(FP_3_SLC_Det, "0_Data/0_Deterministic/FP_3_SLC_Det.csv")

plot(FP_3_SLC_Det$Times, FP_3_SLC_Det$P, type = "l", ylim = c(0, max(FP_3_SLC_Det$P)), main = "Deterministic Simulation of Fenton and Perkins (2010) Model", sub = "Hollings Type III Functional Response, Stable Limit Cycle", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(FP_3_SLC_Det$Times, FP_3_SLC_Det$I, col = "cornflowerblue", lwd = 2)
```

#### Damping Oscillations

```{r}
FP_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; h <- 2.5; e <- 0.1; delta <- 0.008; print(e > 2*delta*h)
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, FP_T3, parms)
FP_3_DO_Det <- data.frame(results); colnames(FP_3_DO_Det) <- c("Times", "P", "I")
write.csv(FP_3_DO_Det, "0_Data/0_Deterministic/FP_3_DO_Det.csv")

plot(FP_3_DO_Det$Times, FP_3_DO_Det$P, type = "l", ylim = c(0, max(FP_3_DO_Det$P)), main = "Deterministic Simulation of Fenton and Perkins (2010) Model", sub = "Hollings Type III Functional Response, Damping Oscillations", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(FP_3_DO_Det$Times, FP_3_DO_Det$I, col = "cornflowerblue", lwd = 2)
```

## Modified Fenton and Perkins (2010)

### Hollings Type I Functional Response

```{r}
Mod_FP_T1 <- function(t,y,p){
  r <- p[1]; B <- p[2]; e <- p[3]; delta <- p[4]
  P <- y[1]; I <- y[2]
  dP = r*P - I*B*P
  dI = b + e*B*P*I-delta*I
  list(c(dP, dI))
}
r <- 1.5; B <- 0.001; e <- 0.9; delta <- 0.2; b <- 200
parms <- c(r, B, e, delta, b)
P0 <- 10; I0 <- 10
N0 <- c(P0, I0)
TT <- seq(0, 100, 0.1) 
results <- lsoda(N0, TT, Mod_FP_T1, parms)
Mod_FP_1_Det <- data.frame(results); colnames(Mod_FP_1_Det) <- c("Time", "P", "I")
write.csv(Mod_FP_1_Det, "0_Data/0_Deterministic/Mod_FP_1_Det.csv")

plot(Mod_FP_1_Det$Time, Mod_FP_1_Det$P, type = "l", ylim = c(0, max(Mod_FP_1_Det$I)), main = "Deterministic Simulation of Modified Fenton and Perkins (2010) Model", sub = "Hollings Type I Functional Response", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(Mod_FP_1_Det$Time, Mod_FP_1_Det$I, col = "cornflowerblue", lwd = 2)
```

### Hollings Type II Functional Response

#### Divergent Oscillations

```{r}
Mod_FP_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = b + e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 2.5; B <- 0.012; h <- 0.075; e <- 0.3; delta <- 0.48; b <- 35
parms <- c(r, B, h, e, delta, b)
P0 <- 80; I0 <- 200
N0 <- c(P0, I0)
TT <- seq(0, 50, 0.1)
results <- lsoda(N0, TT, Mod_FP_T2, parms)
Mod_FP_2_DivOsc_Det <- data.frame(results); colnames(Mod_FP_2_DivOsc_Det) <- c("Times", "P", "I")
write.csv(Mod_FP_2_DivOsc_Det, "0_Data/0_Deterministic/Mod_FP_2_DivOsc_Det.csv")

plot(Mod_FP_2_DivOsc_Det$Times, Mod_FP_2_DivOsc_Det$P, type = "l", ylim = c(0, max(Mod_FP_2_DivOsc_Det$I)), main = "Deterministic Simulation of Modified Fenton and Perkins (2010) Model", sub = "Hollings Type II Functional Response, Stable Limit Cycle", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(Mod_FP_2_DivOsc_Det$Times, Mod_FP_2_DivOsc_Det$I, col = "cornflowerblue", lwd = 2)
```

#### Stable Limit Cycle

```{r}
Mod_FP_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = b + e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 2.5; B <- 0.012; h <- 0.075; e <- 0.3; delta <- 0.41; b <- 35
parms <- c(r, B, h, e, delta, b)
P0 <- 80; I0 <- 200
N0 <- c(P0, I0)
TT <- seq(0, 50, 0.1)
results <- lsoda(N0, TT, Mod_FP_T2, parms)
Mod_FP_2_SLC_Det <- data.frame(results); colnames(Mod_FP_2_SLC_Det) <- c("Times", "P", "I")
write.csv(Mod_FP_2_SLC_Det, "0_Data/0_Deterministic/Mod_FP_2_SLC_Det.csv")

plot(Mod_FP_2_SLC_Det$Times, Mod_FP_2_SLC_Det$P, type = "l", ylim = c(0, max(Mod_FP_2_SLC_Det$I)), main = "Deterministic Simulation of Modified Fenton and Perkins (2010) Model", sub = "Hollings Type II Functional Response, Stable Limit Cycle", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(Mod_FP_2_SLC_Det$Times, Mod_FP_2_SLC_Det$I, col = "cornflowerblue", lwd = 2)
```

#### Damping Oscillations

```{r}
Mod_FP_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = b + e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 2.5; B <- 0.008; h <- 0.06; e <- 0.2; delta <- 0.2; b <- 35
parms <- c(r, B, h, e, delta, b)
P0 <- 80; I0 <- 200
N0 <- c(P0, I0)
TT <- seq(0, 200, 0.1)
results <- lsoda(N0, TT, Mod_FP_T2, parms)
Mod_FP_2_DO_Det <- data.frame(results); colnames(Mod_FP_2_DO_Det) <- c("Times", "P", "I")
write.csv(Mod_FP_2_DO_Det, "0_Data/0_Deterministic/Mod_FP_2_DO_Det.csv")

plot(Mod_FP_2_DO_Det$Times, Mod_FP_2_DO_Det$P, type = "l", ylim = c(0, max(Mod_FP_2_DO_Det$I)), main = "Deterministic Simulation of Modified Fenton and Perkins (2010) Model", sub = "Hollings Type II Functional Response, Damping Oscillations", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(Mod_FP_2_DO_Det$Times, Mod_FP_2_DO_Det$I, col = "cornflowerblue", lwd = 2)
```

### Hollings Type III Functional Response

```{r}
Mod_FP_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = b + e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 3.0; B <- 0.0015; h <- 0.2; e <- 0.2; delta <- 0.5; b <- 35
parms <- c(r, B, h, e, delta, b)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 25, 0.1)
results <- lsoda(N0, TT, Mod_FP_T3, parms)
Mod_FP_3_DO_Det <- data.frame(results); colnames(Mod_FP_3_DO_Det) <- c("Times", "P", "I")
write.csv(Mod_FP_3_DO_Det, "0_Data/0_Deterministic/Mod_FP_3_DO_Det.csv")

plot(Mod_FP_3_DO_Det$Times, Mod_FP_3_DO_Det$P, type = "l", ylim = c(0, max(Mod_FP_3_DO_Det$I)), main = "Deterministic Simulation of Modified Fenton and Perkins (2010) Model", sub = "Hollings Type III Functional Response", xlab = "Time", ylab = "Population Abundance", col = "forestgreen", lwd = 2)
lines(Mod_FP_3_DO_Det$Times, Mod_FP_3_DO_Det$I, col = "cornflowerblue", lwd = 2)
```

# Stochastic Simulations

## Antia et al. (1994)

```{r}
x0 <- c(P = 1, I = 1) 
a <- c("P*r",
       "k*P*I", 
       "p*I*(P/(P + o))")
nu <- matrix(c(+1, -1, 0,
               0, 0, +1), nrow = 2, byrow = TRUE)

r <- 0.2; k <- 0.01; p <- 1; o <- 1000
parms1 <- c(r = r, k = k, p = p, o = o)
tf = 100
method <- "OTL"
simName <- "Antia"

Seeds <- seq(1, 5, 1); Antia_Stoch_List <- list()
for (i in Seeds){
  set.seed(i)
  Antia_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  Antia_Stoch <- Antia_Stoch$data; Antia_Stoch <- as.data.frame(Antia_Stoch)
  colnames(Antia_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(Antia_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    Antia_Stoch_List[[i]] <- Antia_Stoch
  } else {
    Antia_Stoch <- Antia_Stoch[1:FirstZero - 1, ]
    Antia_Stoch_List[[i]] <- Antia_Stoch
  }
}
write.csv(Antia_Stoch_List[[1]], "0_Data/1_Stochastic/Antia_Stoch_1.csv")
write.csv(Antia_Stoch_List[[2]], "0_Data/1_Stochastic/Antia_Stoch_2.csv")
write.csv(Antia_Stoch_List[[3]], "0_Data/1_Stochastic/Antia_Stoch_3.csv")
write.csv(Antia_Stoch_List[[4]], "0_Data/1_Stochastic/Antia_Stoch_4.csv")
write.csv(Antia_Stoch_List[[5]], "0_Data/1_Stochastic/Antia_Stoch_5.csv")

plot(Antia_Det$Time[1:1000], Antia_Det$P[1:1000], type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Continuous-Time Antia et al. (1994), Type I FR Model", xlab = "Time", ylab = "Abundance", xlim = c(0, 100), ylim = c(0, 1800))
lines(Antia_Det$Time[1:1000], Antia_Det$I[1:1000], col = "cornflowerblue", lty = 1, lwd = 3)

lines(Antia_Stoch_List[[1]]$Time, Antia_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[1]]$Time, Antia_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[2]]$Time, Antia_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[2]]$Time, Antia_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[3]]$Time, Antia_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[3]]$Time, Antia_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[4]]$Time, Antia_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[4]]$Time, Antia_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[5]]$Time, Antia_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[5]]$Time, Antia_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)
```

## Modified Fenton and Perkins (2010)

### Hollings Type I Functional Response

```{r}
x0 <- c(P = 10, I = 10) 
a <- c("P*r",
       "I*B*P", 
       "b + e*B*P*I",
       "I*delta")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 1.5; B = 0.001; b = 200; e = 0.9; delta = 0.2
parms1 <- c(r = r, B = B, b = b, e = e, delta = delta)
tf = 25
method <- "OTL"
simName <- "ModFentonPerkins"

Seeds <- c(1, 2, 3, 4, 5); ModFentonPerkins_1_Stoch_List <- list()
for (i in Seeds){
  set.seed(i)
  ModFentonPerkins_1_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch$data; ModFentonPerkins_1_Stoch <- as.data.frame(ModFentonPerkins_1_Stoch)
  colnames(ModFentonPerkins_1_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_1_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_1_Stoch_List[[i]] <- ModFentonPerkins_1_Stoch
  } else {
    ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_1_Stoch_List[[i]] <- ModFentonPerkins_1_Stoch
  }
}
write.csv(ModFentonPerkins_1_Stoch_List[[1]], "0_Data/1_Stochastic/ModFentonPerkins_1_Stoch_1.csv")
write.csv(ModFentonPerkins_1_Stoch_List[[2]], "0_Data/1_Stochastic/ModFentonPerkins_1_Stoch_2.csv")
write.csv(ModFentonPerkins_1_Stoch_List[[3]], "0_Data/1_Stochastic/ModFentonPerkins_1_Stoch_3.csv")
write.csv(ModFentonPerkins_1_Stoch_List[[4]], "0_Data/1_Stochastic/ModFentonPerkins_1_Stoch_4.csv")
write.csv(ModFentonPerkins_1_Stoch_List[[5]], "0_Data/1_Stochastic/ModFentonPerkins_1_Stoch_5.csv")

plot(Mod_FP_1_Det$Time[1:260], Mod_FP_1_Det$P[1:260], type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Continuous-Time Modified Fenton and Perkins (2010), Type I FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 3200))
lines(Mod_FP_1_Det$Time[1:260], Mod_FP_1_Det$I[1:260], col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_1_Stoch_List[[1]]$Time, ModFentonPerkins_1_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_1_Stoch_List[[1]]$Time, ModFentonPerkins_1_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_1_Stoch_List[[2]]$Time, ModFentonPerkins_1_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_1_Stoch_List[[2]]$Time, ModFentonPerkins_1_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_1_Stoch_List[[3]]$Time, ModFentonPerkins_1_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_1_Stoch_List[[3]]$Time, ModFentonPerkins_1_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_1_Stoch_List[[4]]$Time, ModFentonPerkins_1_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_1_Stoch_List[[4]]$Time, ModFentonPerkins_1_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_1_Stoch_List[[5]]$Time, ModFentonPerkins_1_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_1_Stoch_List[[5]]$Time, ModFentonPerkins_1_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)
```

### Hollings Type II Functional Response

#### Divergent Oscillations

```{r}
x0 <- c(P = 80, I = 200) 
a <- c("P*r",
       "I*(B*P/1 + B*P*h)", 
       "b + I*e*(B*P/1 + B*P*h)",
       "I*delta")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 2.5; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.48
parms1 <- c(r = r, B = B, h = h, b = b, e = e, delta = delta)
tf = 50
method <- "OTL"
simName <- "ModFentonPerkins"

Seeds <- c(1, 2, 3, 4, 5); ModFentonPerkins_2_DivOsc_Stoch_List <- list()
for (i in Seeds){
  set.seed(i)
  ModFentonPerkins_2_DivOsc_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch$data; ModFentonPerkins_2_DivOsc_Stoch <- as.data.frame(ModFentonPerkins_2_DivOsc_Stoch)
  colnames(ModFentonPerkins_2_DivOsc_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_2_DivOsc_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_2_DivOsc_Stoch_List[[i]] <- ModFentonPerkins_2_DivOsc_Stoch
  } else {
    ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_2_DivOsc_Stoch_List[[i]] <- ModFentonPerkins_2_DivOsc_Stoch
  }
}
write.csv(ModFentonPerkins_2_DivOsc_Stoch_List[[1]], "0_Data/1_Stochastic/ModFentonPerkins_2_DivOsc_Stoch_1.csv")
write.csv(ModFentonPerkins_2_DivOsc_Stoch_List[[2]], "0_Data/1_Stochastic/ModFentonPerkins_2_DivOsc_Stoch_2.csv")
write.csv(ModFentonPerkins_2_DivOsc_Stoch_List[[3]], "0_Data/1_Stochastic/ModFentonPerkins_2_DivOsc_Stoch_3.csv")
write.csv(ModFentonPerkins_2_DivOsc_Stoch_List[[4]], "0_Data/1_Stochastic/ModFentonPerkins_2_DivOsc_Stoch_4.csv")
write.csv(ModFentonPerkins_2_DivOsc_Stoch_List[[5]], "0_Data/1_Stochastic/ModFentonPerkins_2_DivOsc_Stoch_5.csv")

plot(Mod_FP_2_DivOsc_Det$Times, Mod_FP_2_DivOsc_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Continuous-Time Modified Fenton and Perkins (2010), Type II FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 400))
lines(Mod_FP_2_DivOsc_Det$Times, Mod_FP_2_DivOsc_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_2_DivOsc_Stoch_List[[1]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DivOsc_Stoch_List[[1]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DivOsc_Stoch_List[[2]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DivOsc_Stoch_List[[2]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DivOsc_Stoch_List[[3]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DivOsc_Stoch_List[[3]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DivOsc_Stoch_List[[4]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DivOsc_Stoch_List[[4]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DivOsc_Stoch_List[[5]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DivOsc_Stoch_List[[5]]$Time, ModFentonPerkins_2_DivOsc_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)
```

#### Stable Limit Cycle

```{r}
x0 <- c(P = 80, I = 200) 
a <- c("P*r",
       "I*(B*P/1 + B*P*h)", 
       "b + I*e*(B*P/1 + B*P*h)",
       "I*delta")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 2.5; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.41
parms1 <- c(r = r, B = B, h = h, b = b, e = e, delta = delta)
tf = 25
method <- "OTL"
simName <- "ModFentonPerkins"

Seeds <- c(1, 2, 3, 4, 5); ModFentonPerkins_2_SLC_Stoch_List <- list()
for (i in Seeds){
  set.seed(i)
  ModFentonPerkins_2_SLC_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch$data; ModFentonPerkins_2_SLC_Stoch <- as.data.frame(ModFentonPerkins_2_SLC_Stoch)
  colnames(ModFentonPerkins_2_SLC_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_2_SLC_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_2_SLC_Stoch_List[[i]] <- ModFentonPerkins_2_SLC_Stoch
  } else {
    ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_2_SLC_Stoch_List[[i]] <- ModFentonPerkins_2_SLC_Stoch
  }
}
write.csv(ModFentonPerkins_2_SLC_Stoch_List[[1]], "0_Data/1_Stochastic/ModFentonPerkins_2_SLC_Stoch_1.csv")
write.csv(ModFentonPerkins_2_SLC_Stoch_List[[2]], "0_Data/1_Stochastic/ModFentonPerkins_2_SLC_Stoch_2.csv")
write.csv(ModFentonPerkins_2_SLC_Stoch_List[[3]], "0_Data/1_Stochastic/ModFentonPerkins_2_SLC_Stoch_3.csv")
write.csv(ModFentonPerkins_2_SLC_Stoch_List[[4]], "0_Data/1_Stochastic/ModFentonPerkins_2_SLC_Stoch_4.csv")
write.csv(ModFentonPerkins_2_SLC_Stoch_List[[5]], "0_Data/1_Stochastic/ModFentonPerkins_2_SLC_Stoch_5.csv")

plot(Mod_FP_2_SLC_Det$Times[1:260], Mod_FP_2_SLC_Det$P[1:260], type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Continuous-Time Modified Fenton and Perkins (2010), Type II FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 375))
lines(Mod_FP_2_SLC_Det$Times[1:260], Mod_FP_2_SLC_Det$I[1:260], col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_2_SLC_Stoch_List[[1]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_SLC_Stoch_List[[1]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_SLC_Stoch_List[[2]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_SLC_Stoch_List[[2]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_SLC_Stoch_List[[3]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_SLC_Stoch_List[[3]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_SLC_Stoch_List[[4]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_SLC_Stoch_List[[4]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_SLC_Stoch_List[[5]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_SLC_Stoch_List[[5]]$Time, ModFentonPerkins_2_SLC_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)
```

#### Damping Oscillations

```{r}
x0 <- c(P = 80, I = 200) 
a <- c("P*r",
       "I*(B*P/1 + B*P*h)", 
       "b + I*e*(B*P/1 + B*P*h)",
       "I*delta")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 2.5; B = 0.008; h = 0.06; b = 35; e = 0.2; delta = 0.2
parms1 <- c(r = r, B = B, h = h, b = b, e = e, delta = delta)
tf = 100
method <- "OTL"
simName <- "ModFentonPerkins"

Seeds <- c(1, 2, 3, 4, 5); ModFentonPerkins_2_DO_Stoch_List <- list()
for (i in Seeds){
  set.seed(i)
  ModFentonPerkins_2_DO_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch$data; ModFentonPerkins_2_DO_Stoch <- as.data.frame(ModFentonPerkins_2_DO_Stoch)
  colnames(ModFentonPerkins_2_DO_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_2_DO_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_2_DO_Stoch_List[[i]] <- ModFentonPerkins_2_DO_Stoch
  } else {
    ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_2_DO_Stoch_List[[i]] <- ModFentonPerkins_2_DO_Stoch
  }
}
write.csv(ModFentonPerkins_2_DO_Stoch_List[[1]], "0_Data/1_Stochastic/ModFentonPerkins_2_DO_Stoch_1.csv")
write.csv(ModFentonPerkins_2_DO_Stoch_List[[2]], "0_Data/1_Stochastic/ModFentonPerkins_2_DO_Stoch_2.csv")
write.csv(ModFentonPerkins_2_DO_Stoch_List[[3]], "0_Data/1_Stochastic/ModFentonPerkins_2_DO_Stoch_3.csv")
write.csv(ModFentonPerkins_2_DO_Stoch_List[[4]], "0_Data/1_Stochastic/ModFentonPerkins_2_DO_Stoch_4.csv")
write.csv(ModFentonPerkins_2_DO_Stoch_List[[5]], "0_Data/1_Stochastic/ModFentonPerkins_2_DO_Stoch_5.csv")

plot(Mod_FP_2_DO_Det$Times[1:1000], Mod_FP_2_DO_Det$P[1:1000], type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Continuous-Time Modified Fenton and Perkins (2010), Type II FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 600))
lines(Mod_FP_2_DO_Det$Times[1:1000], Mod_FP_2_DO_Det$I[1:1000], col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_2_DO_Stoch_List[[1]]$Time, ModFentonPerkins_2_DO_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DO_Stoch_List[[1]]$Time, ModFentonPerkins_2_DO_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DO_Stoch_List[[2]]$Time, ModFentonPerkins_2_DO_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DO_Stoch_List[[2]]$Time, ModFentonPerkins_2_DO_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DO_Stoch_List[[3]]$Time, ModFentonPerkins_2_DO_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DO_Stoch_List[[3]]$Time, ModFentonPerkins_2_DO_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DO_Stoch_List[[4]]$Time, ModFentonPerkins_2_DO_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DO_Stoch_List[[4]]$Time, ModFentonPerkins_2_DO_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_2_DO_Stoch_List[[5]]$Time, ModFentonPerkins_2_DO_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_2_DO_Stoch_List[[5]]$Time, ModFentonPerkins_2_DO_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)
```

### Hollings Type III Functional Response

```{r}
x0 <- c(P = 1, I = 1) 
a <- c("P*r",
       "I*(B*P^2/1 + B*P^2*h)", 
       "b + I*e*(B*P^2/1 + B*P^2*h)",
       "I*delta")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 3.0; B = 0.0015; h = 0.2; b = 35; e = 0.2; delta = 0.5
parms1 <- c(r = r, B = B, h = h, b = b, e = e, delta = delta)
tf = 25
method <- "OTL"
simName <- "ModFentonPerkins"

Seeds <- c(1, 2, 3, 4, 5); ModFentonPerkins_3_Stoch_List <- list()
for (i in Seeds){
  set.seed(i)
  ModFentonPerkins_3_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch$data; ModFentonPerkins_3_Stoch <- as.data.frame(ModFentonPerkins_3_Stoch)
  colnames(ModFentonPerkins_3_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_3_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_3_Stoch_List[[i]] <- ModFentonPerkins_3_Stoch
  } else {
    ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_3_Stoch_List[[i]] <- ModFentonPerkins_3_Stoch
  }
}
write.csv(ModFentonPerkins_3_Stoch_List[[1]], "0_Data/1_Stochastic/ModFentonPerkins_3_Stoch_1.csv")
write.csv(ModFentonPerkins_3_Stoch_List[[2]], "0_Data/1_Stochastic/ModFentonPerkins_3_Stoch_2.csv")
write.csv(ModFentonPerkins_3_Stoch_List[[3]], "0_Data/1_Stochastic/ModFentonPerkins_3_Stoch_3.csv")
write.csv(ModFentonPerkins_3_Stoch_List[[4]], "0_Data/1_Stochastic/ModFentonPerkins_3_Stoch_4.csv")
write.csv(ModFentonPerkins_3_Stoch_List[[5]], "0_Data/1_Stochastic/ModFentonPerkins_3_Stoch_5.csv")

plot(Mod_FP_3_DO_Det$Times[1:260], Mod_FP_3_DO_Det$P[1:260], type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Continuous-Time Modified Fenton and Perkins (2010), Type III FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 150))
lines(Mod_FP_3_DO_Det$Times[1:260], Mod_FP_3_DO_Det$I[1:260], col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_3_Stoch_List[[1]]$Time, ModFentonPerkins_3_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_3_Stoch_List[[1]]$Time, ModFentonPerkins_3_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_3_Stoch_List[[2]]$Time, ModFentonPerkins_3_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_3_Stoch_List[[2]]$Time, ModFentonPerkins_3_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_3_Stoch_List[[3]]$Time, ModFentonPerkins_3_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_3_Stoch_List[[3]]$Time, ModFentonPerkins_3_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_3_Stoch_List[[4]]$Time, ModFentonPerkins_3_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_3_Stoch_List[[4]]$Time, ModFentonPerkins_3_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_3_Stoch_List[[5]]$Time, ModFentonPerkins_3_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_3_Stoch_List[[5]]$Time, ModFentonPerkins_3_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)
```

# Model-Fitting

## Antia et al. (1994)

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       
               real[] z,     
               real[] theta, 
               real[] x_r,  
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real k = theta[2];
    real p = theta[3];
    real o = theta[4];

    real dP_dt = r*P - k*P*I;
    real dI_dt = p*I*(P/(P + o));
    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;           
  real ts[N];                 
  real y_init[2];             
  real<lower = 0> y[N, 2];    
}
parameters {
  real<lower = 0> r; 
  real<lower = 0> k;
  real<lower = 0> p;
  real<lower = 0> o;
  real<lower = 0> z_init[2];  
  real<lower = 0> sigma[2];   
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, {r, k, p, o},
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  r ~ normal(1, 3); // r = 0.2
  k ~ lognormal(log(0.1), 1); // k = 0.01
  p ~ normal(1, 1); // p = 1
  o ~ normal(1000, 10); // o = 1000
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (m in 1:2) {
    y_init[m] ~ lognormal(log(z_init[m]), sigma[m]);
    y[ , m] ~ lognormal(log(z[, m]), sigma[m]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (m in 1:2) {
    y_init_rep[m] = lognormal_rng(log(z_init[m]), sigma[m]);
    for (n in 1:N)
      y_rep[n, m] = lognormal_rng(log(z[n, m]), sigma[m]);
  }
}
", file = "1_Models/Antia.stan")
```

Let's arrange our data to feed into the model:

```{r}
Antia_StanData_List <- list()
for (i in Seeds){
  Antia_Stoch <- Antia_Stoch_List[[i]]
  N <- length(Antia_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(Antia_Stoch$P[1], Antia_Stoch$I[1])
  y <- as.matrix(Antia_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  Antia_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  Antia_StanData_List[[i]] <- Antia_StanData
}
saveRDS(Antia_StanData_List, "0_Data/2_Stan/Antia_StanData_List.rds")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/Antia.stan")
```

```{r, include = FALSE}
fit <- sampling(model, data = Antia_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/Antia_FitObj_1.rds")

fit <- sampling(model, data = Antia_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/Antia_FitObj_2.rds")

fit <- sampling(model, data = Antia_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/Antia_FitObj_3.rds")

fit <- sampling(model, data = Antia_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/Antia_FitObj_4.rds")

fit <- sampling(model, data = Antia_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/Antia_FitObj_5.rds")
```

## Modified Fenton and Perkins (2010)

### Hollings Type I Functional Response

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*B*P;
    real dI_dt = b + e1*B*P*I - I*delta;

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, B, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // B
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_1_AllParms.stan")
```

Let's arrange our data to feed into the model:

```{r}
ModFentonPerkins_1_StanData_List <- list()
for (i in Seeds){
  ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch_List[[i]]
  N <- length(ModFentonPerkins_1_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(ModFentonPerkins_1_Stoch$P[1], ModFentonPerkins_1_Stoch$I[1])
  y <- as.matrix(ModFentonPerkins_1_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  ModFentonPerkins_1_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  ModFentonPerkins_1_StanData_List[[i]] <- ModFentonPerkins_1_StanData
}
saveRDS(ModFentonPerkins_1_StanData_List, "0_Data/2_Stan/ModFentonPerkins_1_StanData_List.rds")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_1_AllParms.stan")
```

```{r, include = FALSE}
fit <- sampling(model, data = ModFentonPerkins_1_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_1_FitObj_1.rds")

fit <- sampling(model, data = ModFentonPerkins_1_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_1_FitObj_2.rds")

fit <- sampling(model, data = ModFentonPerkins_1_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_1_FitObj_3.rds")

fit <- sampling(model, data = ModFentonPerkins_1_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_1_FitObj_4.rds")

fit <- sampling(model, data = ModFentonPerkins_1_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_1_FitObj_5.rds")
```

### Hollings Type II Functional Response

#### Divergent Oscillations

##### Estimating All Parameters

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real h = theta[3];
    real b = theta[4];
    real e1 = theta[5];
    real delta = theta[6];

    real dP_dt = P*r - I*(B*P/(1 + B*h*P));
    real dI_dt = b + I*(e1*(B*P/(1 + B*h*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[6];   // {r, B, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2, 3}] ~ uniform(0, 1); // B, h
  theta[{4}] ~ uniform(0, 1000); // b
  theta[{5, 6}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_AllParms.stan")
```

Let's arrange our data to feed into the model:

```{r}
ModFentonPerkins_2_DivOsc_StanData_List <- list()
for (i in Seeds){
  ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[i]]
  N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
  y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  ModFentonPerkins_2_DivOsc_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  ModFentonPerkins_2_DivOsc_StanData_List[[i]] <- ModFentonPerkins_2_DivOsc_StanData
}
saveRDS(ModFentonPerkins_2_DivOsc_StanData_List, "0_Data/2_Stan/ModFentonPerkins_2_DivOsc_StanData_List.rds")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_AllParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_5.rds")
```

##### Estimating Five Parameters

###### Exclude Recognition Rate

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real h = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(0.012*P/(1 + 0.012*h*P));
    real dI_dt = b + I*(e1*(0.012*P/(1 + 0.012*h*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // h
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_DivOsc_FiveParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_DivOsc_FiveParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5.rds")
```

###### Exclude Handling Time

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(0.012*P/(1 + B*0.075*P));
    real dI_dt = b + I*(e1*(0.012*P/(1 + B*0.075*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, B, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // B
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_DivOsc_FiveParms-ExHT.stan")
```

```{r}
model <- stan_model("1_Models/FP_2_DivOsc_FiveParms-ExHT.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_5.rds")
```

##### Estimating Four Parameters

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real b = theta[2];
    real e1 = theta[3];
    real delta = theta[4];

    real dP_dt = P*r - I*(0.012*P/(1 + 0.012*0.075*P));
    real dI_dt = b + I*(e1*(0.012*P/(1 + 0.012*0.075*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[4];   // {r, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1000); // b
  theta[{3, 4}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_DivOsc_FourParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_DivOsc_FourParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DivOsc_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_5.rds")

#### Stable Limit Cycle

##### Estimating All Parameters

Writing the model as a .stan file.

write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real h = theta[3];
    real b = theta[4];
    real e1 = theta[5];
    real delta = theta[6];

    real dP_dt = P*r - I*(B*P/(1 + B*h*P));
    real dI_dt = b + I*(e1*(B*P/(1 + B*h*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[6];   // {r, B, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2, 3}] ~ uniform(0, 1); // B, h
  theta[{4}] ~ uniform(0, 1000); // b
  theta[{5, 6}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_AllParms.stan")
```

Let's arrange our data to feed into the model:

```{r}
ModFentonPerkins_2_SLC_StanData_List <- list()
for (i in Seeds){
  ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[i]]
  N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
  y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  ModFentonPerkins_2_SLC_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  ModFentonPerkins_2_SLC_StanData_List[[i]] <- ModFentonPerkins_2_SLC_StanData
}
saveRDS(ModFentonPerkins_2_SLC_StanData_List, "0_Data/2_Stan/ModFentonPerkins_2_SLC_StanData_List.rds")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_AllParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_5.rds")
```

#### Stable Limit Cycle

##### Estimating Five Parameters

###### Exclude Recognition Rate

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real h = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(0.012*P/(1 + 0.012*h*P));
    real dI_dt = b + I*(e1*(0.012*P/(1 + 0.012*h*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // h
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_SLC_FiveParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_SLC_FiveParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_5.rds")
```

###### Exclude Handling Time

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(0.012*P/(1 + B*0.075*P));
    real dI_dt = b + I*(e1*(0.012*P/(1 + B*0.075*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, B, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // B
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_SLC_FiveParms-ExHT.stan")
```

```{r}
model <- stan_model("1_Models/FP_2_SLC_FiveParms-ExHT.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_5.rds")
```

##### Estimating Four Parameters

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real b = theta[2];
    real e1 = theta[3];
    real delta = theta[4];

    real dP_dt = P*r - I*(0.012*P/(1 + 0.012*0.075*P));
    real dI_dt = b + I*(e1*(0.012*P/(1 + 0.012*0.075*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[4];   // {r, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1000); // b
  theta[{3, 4}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_SLC_FourParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_SLC_FourParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_SLC_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_5.rds")
```

#### Damping Oscillations

##### Estimating All Parameters

Let's arrange our data to feed into the model:

```{r}
ModFentonPerkins_2_DO_StanData_List <- list()
for (i in Seeds){
  ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[i]]
  N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
  y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  ModFentonPerkins_2_DO_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  ModFentonPerkins_2_DO_StanData_List[[i]] <- ModFentonPerkins_2_DO_StanData
}
saveRDS(ModFentonPerkins_2_DO_StanData_List, "0_Data/2_Stan/ModFentonPerkins_2_DO_StanData_List.rds")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_AllParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_5.rds")
```

##### Estimating Five Parameters

###### Exclude Recognition Rate

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real h = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(0.008*P/(1 + 0.008*h*P));
    real dI_dt = b + I*(e1*(0.008*P/(1 + 0.008*h*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // h
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_DO_FiveParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_DO_FiveParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_5.rds")
```

###### Exclude Handling Time

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(B*P/(1 + B*0.06*P));
    real dI_dt = b + I*(e1*(B*P/(1 + B*0.06*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, B, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // B
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_DO_FiveParms-ExHT.stan")
```

```{r}
model <- stan_model("1_Models/FP_2_DO_FiveParms-ExHT.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_5.rds")
```

##### Estimating Four Parameters

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real b = theta[2];
    real e1 = theta[3];
    real delta = theta[4];

    real dP_dt = P*r - I*(0.008*P/(1 + 0.008*0.06*P));
    real dI_dt = b + I*(e1*(0.008*P/(1 + 0.008*0.06*P)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[4];   // {r, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1000); // b
  theta[{3, 4}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_2_DO_FourParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_2_DO_FourParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_2_DO_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_5.rds")
```

### Hollings Type III Functional Response

##### Estimating All Parms

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real h = theta[3];
    real b = theta[4];
    real e1 = theta[5];
    real delta = theta[6];

    real dP_dt = P*r - I*(B*P^2/(1 + B*h*P^2));
    real dI_dt = b + I*(e1*(B*P^2/(1 + B*h*P^2)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[6];   // {r, B, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2, 3}] ~ uniform(0, 1); // B, h
  theta[{4}] ~ uniform(0, 1000); // b
  theta[{5, 6}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_3_AllParms.stan")
```

Let's arrange our data to feed into the model:

```{r}
ModFentonPerkins_3_StanData_List <- list()
for (i in Seeds){
  ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[i]]
  N <- length(ModFentonPerkins_3_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
  y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  ModFentonPerkins_3_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  ModFentonPerkins_3_StanData_List[[i]] <- ModFentonPerkins_3_StanData
}
saveRDS(ModFentonPerkins_3_StanData_List, "0_Data/2_Stan/ModFentonPerkins_3_StanData_List.rds")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_3_AllParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_1.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_2.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_3.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_4.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_5.rds")
```

##### Estimating Five Parameters

###### Exclude Recognition Rate

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real h = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(0.0015*P^2/(1 + 0.0015*h*P^2));
    real dI_dt = b + I*(e1*(0.0015*P^2/(1 + 0.0015*h*P^2)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, h, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // h
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_3_FiveParms.stan")
```

```{r}
model <- stan_model("1_Models/FP_3_FiveParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms.rds")
```

###### Exclude Handling Time

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real B = theta[2];
    real b = theta[3];
    real e1 = theta[4];
    real delta = theta[5];

    real dP_dt = P*r - I*(B*P^2/(1 + B*0.2*P^2));
    real dI_dt = b + I*(e1*(B*P^2/(1 + B*0.2*P^2)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[5];   // {r, B, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1); // B
  theta[{3}] ~ uniform(0, 1000); // b
  theta[{4, 5}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_3_FiveParms-ExHT.stan")
```

```{r}
model <- stan_model("1_Models/FP_3_FiveParms-ExHT.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[1]], chains = 4, iter = 1000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_1.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[2]], chains = 4, iter = 1000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_2.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[3]], chains = 4, iter = 1000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_3.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[4]], chains = 4, iter = 1000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_4.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[5]], chains = 4, iter = 1000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_5.rds")
```

##### Estimating Four Parameters

Writing the model as a .stan file.

```{r}
write("
functions {
  real[] dz_dt(real t,       // time
               real[] z,     // system state {prey, predator}
               real[] theta, // parameters
               real[] x_r,   // unused data
               int[] x_i) {
    real P = z[1];
    real I = z[2];

    real r = theta[1];  
    real b = theta[2];
    real e1 = theta[3];
    real delta = theta[4];

    real dP_dt = P*r - I*(0.0015*P^2/(1 + 0.0015*0.2*P^2));
    real dI_dt = b + I*(e1*(0.0015*P^2/(1 + 0.0015*0.2*P^2)) - delta);

    return { dP_dt, dI_dt };
  }
}
data {
  int<lower = 0> N;          // number of measurement times
  real ts[N];                // measurement times > 0
  real y_init[2];            // initial measured populations
  real<lower = 0> y[N, 2];   // measured populations
}
parameters {
  real<lower = 0> theta[4];   // {r, b, e1, delta}
  real<lower = 0> z_init[2];  // initial population
  real<lower = 0> sigma[2];   // measurement errors
}
transformed parameters {
  real z[N, 2]
    = integrate_ode_bdf(dz_dt, z_init, 0, ts, theta,
                         rep_array(0.0, 0), rep_array(0, 0));
}
model {
  theta[{1}] ~ uniform(0, 10); // r
  theta[{2}] ~ uniform(0, 1000); // b
  theta[{3, 4}] ~ uniform(0, 1); // e1, delta
  sigma ~ lognormal(-1, 1);
  z_init ~ lognormal(log(10), 1);
  for (k in 1:2) {
    y_init[k] ~ lognormal(log(z_init[k]), sigma[k]);
    y[ , k] ~ lognormal(log(z[, k]), sigma[k]);
  }
}
generated quantities {
  real y_init_rep[2];
  real y_rep[N, 2];
  for (k in 1:2) {
    y_init_rep[k] = lognormal_rng(log(z_init[k]), sigma[k]);
    for (n in 1:N)
      y_rep[n, k] = lognormal_rng(log(z[n, k]), sigma[k]);
  }
}      
", file = "1_Models/FP_3_FourParms.stan")
```

Next, we'll compile the .stan file:

```{r}
model <- stan_model("1_Models/FP_3_FourParms.stan")
```

```{r}
fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[1]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_1.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[2]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_2.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[3]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_3.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[4]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_4.rds")

fit <- sampling(model, data = ModFentonPerkins_3_StanData_List[[5]], chains = 4, iter = 2000, cores = 4, seed = 123)
saveRDS(fit, file = "2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_5.rds")
```

# Summarizing and Visualizing

```{r}
print(Antia_FitObj1, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(Antia_FitObj2, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(Antia_FitObj3, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(Antia_FitObj4, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(Antia_FitObj5, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_1_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_1_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_1_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_1_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_1_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_SLC_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_SLC_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_SLC_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_DO_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_DO_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_2_DO_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_2_DO_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_3_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_3_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

print(ModFentonPerkins_3_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
print(ModFentonPerkins_3_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
```

## Antia et al. (1994)

```{r}
Antia_FitObj1 <- readRDS("2_FitObjects/Antia_FitObj_1.rds")
Antia_FitObj2 <- readRDS("2_FitObjects/Antia_FitObj_2.rds")
Antia_FitObj3 <- readRDS("2_FitObjects/Antia_FitObj_3.rds")
Antia_FitObj4 <- readRDS("2_FitObjects/Antia_FitObj_4.rds")
Antia_FitObj5 <- readRDS("2_FitObjects/Antia_FitObj_5.rds")

print(Antia_FitObj1, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("r", "k", "p", "o")
stan_trace(Antia_FitObj1, pars)
mcmc_pairs(Antia_FitObj1, pars)
mcmc_dens(Antia_FitObj1, pars) 

print(Antia_FitObj2, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("r", "k", "p", "o")
stan_trace(Antia_FitObj2, pars)
mcmc_pairs(Antia_FitObj2, pars)
mcmc_dens(Antia_FitObj2, pars) 

print(Antia_FitObj3, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("r", "k", "p", "o")
stan_trace(Antia_FitObj3, pars)
mcmc_pairs(Antia_FitObj3, pars)
mcmc_dens(Antia_FitObj3, pars) 

print(Antia_FitObj4, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("r", "k", "p", "o")
stan_trace(Antia_FitObj4, pars)
mcmc_pairs(Antia_FitObj4, pars)
mcmc_dens(Antia_FitObj4, pars) 

print(Antia_FitObj5, pars = c("r", "k", "p", "o", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("r", "k", "p", "o")
stan_trace(Antia_FitObj5, pars)
mcmc_pairs(Antia_FitObj5, pars)
mcmc_dens(Antia_FitObj5, pars) 
```

## Modified Fenton and Perkins (2010)

### Hollings Type I Functional Response

```{r}
ModFentonPerkins_1_FitObj1 <- readRDS("2_FitObjects/ModFentonPerkins_1_FitObj_1.rds")
ModFentonPerkins_1_FitObj2 <- readRDS("2_FitObjects/ModFentonPerkins_1_FitObj_2.rds")
ModFentonPerkins_1_FitObj3 <- readRDS("2_FitObjects/ModFentonPerkins_1_FitObj_3.rds")
ModFentonPerkins_1_FitObj4 <- readRDS("2_FitObjects/ModFentonPerkins_1_FitObj_4.rds")
ModFentonPerkins_1_FitObj5 <- readRDS("2_FitObjects/ModFentonPerkins_1_FitObj_5.rds")

print(ModFentonPerkins_1_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_1_FitObj1, pars)
mcmc_pairs(ModFentonPerkins_1_FitObj1, pars)
mcmc_dens(ModFentonPerkins_1_FitObj1, pars)

print(ModFentonPerkins_1_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_1_FitObj2, pars)
mcmc_pairs(ModFentonPerkins_1_FitObj2, pars)
mcmc_dens(ModFentonPerkins_1_FitObj2, pars)

print(ModFentonPerkins_1_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_1_FitObj3, pars)
mcmc_pairs(ModFentonPerkins_1_FitObj3, pars)
mcmc_dens(ModFentonPerkins_1_FitObj3, pars)

print(ModFentonPerkins_1_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_1_FitObj4, pars)
mcmc_pairs(ModFentonPerkins_1_FitObj4, pars)
mcmc_dens(ModFentonPerkins_1_FitObj4, pars)

print(ModFentonPerkins_1_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_1_FitObj5, pars)
mcmc_pairs(ModFentonPerkins_1_FitObj5, pars)
mcmc_dens(ModFentonPerkins_1_FitObj5, pars)
```

### Hollings Type II Functional Response

#### Divergent Oscillations

```{r}
#### All Parms ####
ModFentonPerkins_2_DivOsc_FitObj1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_1.rds")
ModFentonPerkins_2_DivOsc_FitObj2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_2.rds")
ModFentonPerkins_2_DivOsc_FitObj3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_3.rds")
ModFentonPerkins_2_DivOsc_FitObj4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_4.rds")
ModFentonPerkins_2_DivOsc_FitObj5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_5.rds")

print(ModFentonPerkins_2_DivOsc_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj1, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj1, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj1, pars)

print(ModFentonPerkins_2_DivOsc_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj2, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj2, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj2, pars)

print(ModFentonPerkins_2_DivOsc_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj3, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj3, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj3, pars)

print(ModFentonPerkins_2_DivOsc_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj4, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj4, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj4, pars)

print(ModFentonPerkins_2_DivOsc_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj5, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj5, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj5, pars)

#### Five Parms ####
ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5.rds")

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5, pars)

ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_1.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_2.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_3.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_4.rds")
ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FiveParms-ExHT_5.rds")

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5, pars)

#### Four Parms ####
ModFentonPerkins_2_DivOsc_FitObj_FourParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_1.rds")
ModFentonPerkins_2_DivOsc_FitObj_FourParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_2.rds")
ModFentonPerkins_2_DivOsc_FitObj_FourParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_3.rds")
ModFentonPerkins_2_DivOsc_FitObj_FourParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_4.rds")
ModFentonPerkins_2_DivOsc_FitObj_FourParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DivOsc_FitObj_FourParms_5.rds")

print(ModFentonPerkins_2_DivOsc_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FourParms_1, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FourParms_1, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FourParms_1, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FourParms_2, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FourParms_2, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FourParms_2, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FourParms_3, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FourParms_3, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FourParms_3, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FourParms_4, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FourParms_4, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FourParms_4, pars)

print(ModFentonPerkins_2_DivOsc_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DivOsc_FitObj_FourParms_5, pars)
mcmc_pairs(ModFentonPerkins_2_DivOsc_FitObj_FourParms_5, pars)
mcmc_dens(ModFentonPerkins_2_DivOsc_FitObj_FourParms_5, pars)
```

#### Stable Limit Cycle

```{r}
#### All Parms ####
ModFentonPerkins_2_SLC_FitObj1 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_1.rds")
ModFentonPerkins_2_SLC_FitObj2 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_2.rds")
ModFentonPerkins_2_SLC_FitObj3 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_3.rds")
ModFentonPerkins_2_SLC_FitObj4 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_4.rds")
ModFentonPerkins_2_SLC_FitObj5 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_5.rds")

print(ModFentonPerkins_2_SLC_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_SLC_FitObj1, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj1, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj1, pars)

print(ModFentonPerkins_2_SLC_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_SLC_FitObj2, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj2, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj2, pars)

print(ModFentonPerkins_2_SLC_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_SLC_FitObj3, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj3, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj3, pars)

print(ModFentonPerkins_2_SLC_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_SLC_FitObj4, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj4, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj4, pars)

print(ModFentonPerkins_2_SLC_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_SLC_FitObj5, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj5, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj5, pars)

#### Five Parms ####
ModFentonPerkins_2_SLC_FitObj_FiveParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_1.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_2.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_3.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_4.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms_5.rds")

print(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, pars)

ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_1.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_2.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_3.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_4.rds")
ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FiveParms-ExHT_5.rds")

print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, pars)

print(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, pars)

#### Four Parms ####
ModFentonPerkins_2_SLC_FitObj_FourParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_1.rds")
ModFentonPerkins_2_SLC_FitObj_FourParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_2.rds")
ModFentonPerkins_2_SLC_FitObj_FourParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_3.rds")
ModFentonPerkins_2_SLC_FitObj_FourParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_4.rds")
ModFentonPerkins_2_SLC_FitObj_FourParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_SLC_FitObj_FourParms_5.rds")

print(ModFentonPerkins_2_SLC_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FourParms_1, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FourParms_1, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FourParms_1, pars)

print(ModFentonPerkins_2_SLC_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FourParms_2, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FourParms_2, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FourParms_2, pars)

print(ModFentonPerkins_2_SLC_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FourParms_3, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FourParms_3, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FourParms_3, pars)

print(ModFentonPerkins_2_SLC_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FourParms_4, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FourParms_4, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FourParms_4, pars)

print(ModFentonPerkins_2_SLC_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_SLC_FitObj_FourParms_5, pars)
mcmc_pairs(ModFentonPerkins_2_SLC_FitObj_FourParms_5, pars)
mcmc_dens(ModFentonPerkins_2_SLC_FitObj_FourParms_5, pars)
```

#### Damping Oscillations

```{r}
#### All Parms ####
ModFentonPerkins_2_DO_FitObj1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_1.rds")
ModFentonPerkins_2_DO_FitObj2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_2.rds")
ModFentonPerkins_2_DO_FitObj3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_3.rds")
ModFentonPerkins_2_DO_FitObj4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_4.rds")
ModFentonPerkins_2_DO_FitObj5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_5.rds")

print(ModFentonPerkins_2_DO_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DO_FitObj1, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj1, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj1, pars)

print(ModFentonPerkins_2_DO_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DO_FitObj2, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj2, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj2, pars)

print(ModFentonPerkins_2_DO_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DO_FitObj3, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj3, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj3, pars)

print(ModFentonPerkins_2_DO_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DO_FitObj4, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj4, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj4, pars)

print(ModFentonPerkins_2_DO_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_2_DO_FitObj5, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj5, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj5, pars)

#### Five Parms ####
ModFentonPerkins_2_DO_FitObj_FiveParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_1.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_2.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_3.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_4.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms_5.rds")

print(ModFentonPerkins_2_DO_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms_1, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms_1, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms_1, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms_2, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms_2, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms_2, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms_3, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms_3, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms_3, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms_4, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms_4, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms_4, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms_5, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms_5, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms_5, pars)

ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_1.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_2.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_3.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_4.rds")
ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FiveParms-ExHT_5.rds")

print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, pars)

print(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, pars)

#### Four Parms ####
ModFentonPerkins_2_DO_FitObj_FourParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_1.rds")
ModFentonPerkins_2_DO_FitObj_FourParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_2.rds")
ModFentonPerkins_2_DO_FitObj_FourParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_3.rds")
ModFentonPerkins_2_DO_FitObj_FourParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_4.rds")
ModFentonPerkins_2_DO_FitObj_FourParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_2_DO_FitObj_FourParms_5.rds")

print(ModFentonPerkins_2_DO_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FourParms_1, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FourParms_1, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FourParms_1, pars)

print(ModFentonPerkins_2_DO_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FourParms_2, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FourParms_2, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FourParms_2, pars)

print(ModFentonPerkins_2_DO_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FourParms_3, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FourParms_3, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FourParms_3, pars)

print(ModFentonPerkins_2_DO_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FourParms_4, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FourParms_4, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FourParms_4, pars)

print(ModFentonPerkins_2_DO_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_2_DO_FitObj_FourParms_5, pars)
mcmc_pairs(ModFentonPerkins_2_DO_FitObj_FourParms_5, pars)
mcmc_dens(ModFentonPerkins_2_DO_FitObj_FourParms_5, pars)
```

### Hollings Type III Functional Response

```{r}
#### All Parms ####
ModFentonPerkins_3_FitObj1 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_1.rds")
ModFentonPerkins_3_FitObj2 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_2.rds")
ModFentonPerkins_3_FitObj3 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_3.rds")
ModFentonPerkins_3_FitObj4 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_4.rds")
ModFentonPerkins_3_FitObj5 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_5.rds")

print(ModFentonPerkins_3_FitObj1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_3_FitObj1, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj1, pars)
mcmc_dens(ModFentonPerkins_3_FitObj1, pars)

print(ModFentonPerkins_3_FitObj2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_3_FitObj2, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj2, pars)
mcmc_dens(ModFentonPerkins_3_FitObj2, pars)

print(ModFentonPerkins_3_FitObj3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_3_FitObj3, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj3, pars)
mcmc_dens(ModFentonPerkins_3_FitObj3, pars)

print(ModFentonPerkins_3_FitObj4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_3_FitObj4, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj4, pars)
mcmc_dens(ModFentonPerkins_3_FitObj4, pars)

print(ModFentonPerkins_3_FitObj5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(ModFentonPerkins_3_FitObj5, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj5, pars)
mcmc_dens(ModFentonPerkins_3_FitObj5, pars)

#### Five Parms ####
ModFentonPerkins_3_FitObj_FiveParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms_1.rds")
ModFentonPerkins_3_FitObj_FiveParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms_2.rds")
ModFentonPerkins_3_FitObj_FiveParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms_3.rds")
ModFentonPerkins_3_FitObj_FiveParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms_4.rds")
ModFentonPerkins_3_FitObj_FiveParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms_5.rds")

print(ModFentonPerkins_3_FitObj_FiveParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms_1, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms_1, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms_1, pars)

print(ModFentonPerkins_3_FitObj_FiveParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms_2, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms_2, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms_2, pars)

print(ModFentonPerkins_3_FitObj_FiveParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms_3, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms_3, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms_3, pars)

print(ModFentonPerkins_3_FitObj_FiveParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms_4, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms_4, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms_4, pars)

print(ModFentonPerkins_3_FitObj_FiveParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms_5, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms_5, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms_5, pars)

ModFentonPerkins_3_FitObj_FiveParms.ExHT_1 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_1.rds")
ModFentonPerkins_3_FitObj_FiveParms.ExHT_2 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_2.rds")
ModFentonPerkins_3_FitObj_FiveParms.ExHT_3 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_3.rds")
ModFentonPerkins_3_FitObj_FiveParms.ExHT_4 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_4.rds")
ModFentonPerkins_3_FitObj_FiveParms.ExHT_5 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FiveParms-ExHT_5.rds")

print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms.ExHT_1, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms.ExHT_1, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms.ExHT_1, pars)

print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms.ExHT_2, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms.ExHT_2, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms.ExHT_2, pars)

print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms.ExHT_3, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms.ExHT_3, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms.ExHT_3, pars)

print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms.ExHT_4, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms.ExHT_4, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms.ExHT_4, pars)

print(ModFentonPerkins_3_FitObj_FiveParms.ExHT_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(ModFentonPerkins_3_FitObj_FiveParms.ExHT_5, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FiveParms.ExHT_5, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FiveParms.ExHT_5, pars)

#### Four Parms ####
ModFentonPerkins_3_FitObj_FourParms_1 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_1.rds")
ModFentonPerkins_3_FitObj_FourParms_2 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_2.rds")
ModFentonPerkins_3_FitObj_FourParms_3 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_3.rds")
ModFentonPerkins_3_FitObj_FourParms_4 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_4.rds")
ModFentonPerkins_3_FitObj_FourParms_5 <- readRDS("2_FitObjects/ModFentonPerkins_3_FitObj_FourParms_5.rds")

print(ModFentonPerkins_3_FitObj_FourParms_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_3_FitObj_FourParms_1, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FourParms_1, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FourParms_1, pars)

print(ModFentonPerkins_3_FitObj_FourParms_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_3_FitObj_FourParms_2, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FourParms_2, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FourParms_2, pars)

print(ModFentonPerkins_3_FitObj_FourParms_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_3_FitObj_FourParms_3, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FourParms_3, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FourParms_3, pars)

print(ModFentonPerkins_3_FitObj_FourParms_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_3_FitObj_FourParms_4, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FourParms_4, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FourParms_4, pars)

print(ModFentonPerkins_3_FitObj_FourParms_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(ModFentonPerkins_3_FitObj_FourParms_5, pars)
mcmc_pairs(ModFentonPerkins_3_FitObj_FourParms_5, pars)
mcmc_dens(ModFentonPerkins_3_FitObj_FourParms_5, pars)
```

# Compare Data to Time Series Estimates

## Antia et al. (1994)

```{r}
#### Time Series 1 ####
output <- rstan::extract(Antia_FitObj1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
Antia_Stoch <- Antia_Stoch_List[[1]]
N <- length(Antia_Stoch$Time) - 1
ts <- 1:N
y_init <- c(Antia_Stoch$P[1], Antia_Stoch$I[1])
y <- as.matrix(Antia_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_P)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(Antia_FitObj2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
Antia_Stoch <- Antia_Stoch_List[[2]]
N <- length(Antia_Stoch$Time) - 1
ts <- 1:N
y_init <- c(Antia_Stoch$P[1], Antia_Stoch$I[1])
y <- as.matrix(Antia_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_P)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(Antia_FitObj3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
Antia_Stoch <- Antia_Stoch_List[[3]]
N <- length(Antia_Stoch$Time) - 1
ts <- 1:N
y_init <- c(Antia_Stoch$P[1], Antia_Stoch$I[1])
y <- as.matrix(Antia_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_P)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(Antia_FitObj4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
Antia_Stoch <- Antia_Stoch_List[[4]]
N <- length(Antia_Stoch$Time) - 1
ts <- 1:N
y_init <- c(Antia_Stoch$P[1], Antia_Stoch$I[1])
y <- as.matrix(Antia_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_P)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(Antia_FitObj5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
Antia_Stoch <- Antia_Stoch_List[[5]]
N <- length(Antia_Stoch$Time) - 1
ts <- 1:N
y_init <- c(Antia_Stoch$P[1], Antia_Stoch$I[1])
y <- as.matrix(Antia_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_P)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

## Modified Fenton and Perkins (2010)

### Hollings Type I Functional Response

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_1_FitObj1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch_List[[1]]
N <- length(ModFentonPerkins_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_1_Stoch$P[1], ModFentonPerkins_1_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_1_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topright", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_1_FitObj2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch_List[[2]]
N <- length(ModFentonPerkins_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_1_Stoch$P[1], ModFentonPerkins_1_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_1_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topright", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_1_FitObj3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch_List[[3]]
N <- length(ModFentonPerkins_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_1_Stoch$P[1], ModFentonPerkins_1_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_1_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topright", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_1_FitObj4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch_List[[4]]
N <- length(ModFentonPerkins_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_1_Stoch$P[1], ModFentonPerkins_1_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_1_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topright", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_1_FitObj5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_1_Stoch <- ModFentonPerkins_1_Stoch_List[[5]]
N <- length(ModFentonPerkins_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_1_Stoch$P[1], ModFentonPerkins_1_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_1_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topright", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

### Hollings Type II Functional Response

#### Divergent Oscillations

##### Estimating All Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Five Parameters

###### Excluding Recognition Rate

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

###### Excluding Handling Time

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Four Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DivOsc_Stoch <- ModFentonPerkins_2_DivOsc_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DivOsc_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DivOsc_Stoch$P[1], ModFentonPerkins_2_DivOsc_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DivOsc_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

#### Stable Limit Cycle

##### Estimating All Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Five Parameters

###### Excluding Recognition Rate

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

###### Excluding Handling Time

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Four Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_SLC_Stoch <- ModFentonPerkins_2_SLC_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_SLC_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_SLC_Stoch$P[1], ModFentonPerkins_2_SLC_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_SLC_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

#### Damping Oscillations

##### Estimating All Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Five Parameters

###### Excluding Recognition Rate

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

###### Excluding Handling Time

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Four Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[1]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[2]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[3]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[4]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_2_DO_Stoch <- ModFentonPerkins_2_DO_Stoch_List[[5]]
N <- length(ModFentonPerkins_2_DO_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_2_DO_Stoch$P[1], ModFentonPerkins_2_DO_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_2_DO_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

### Hollings Type III Functional Response

##### Estimating All Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[1]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[2]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[3]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[4]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[5]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Five Parameters

###### Excluding Recognition Rate

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[1]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[2]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[3]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[4]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[5]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

###### Excluding Handling Time

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[1]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[2]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[3]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[4]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[5]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

##### Estimating Four Parameters

```{r}
#### Time Series 1 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[1]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 2 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[2]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 3 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[3]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 4 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[4]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))

#### Time Series 5 ####
output <- rstan::extract(ModFentonPerkins_3_FitObj_FourParms_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
ModFentonPerkins_3_Stoch <- ModFentonPerkins_3_Stoch_List[[5]]
N <- length(ModFentonPerkins_3_Stoch$Time) - 1
ts <- 1:N
y_init <- c(ModFentonPerkins_3_Stoch$P[1], ModFentonPerkins_3_Stoch$I[1])
y <- as.matrix(ModFentonPerkins_3_Stoch[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts, df$P, type = "l", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(df$post_means_I)), col = "forestgreen", lwd = 2)
lines(df$ts, df$I, col = "cornflowerblue", lwd = 2)
lines(df$ts, df$post_means_P, col = "forestgreen", lty = 2, lwd = 2)
lines(df$ts, df$post_means_I, col = "cornflowerblue", lty = 2, lwd = 2)
# legend("topleft", legend = c("Observed parasite abundance", "Observed immune cell abundane", "Estimated parasite abundance", "Estiamted immune cell abundance"), col = c("forestgreen", "cornflowerblue", "forestgreen", "cornflowerblue"), lty = c(1, 1, 2, 2), lwd = c(2, 2, 2, 2))
```

# AUTOREGRESSIVE FRAMEWORK

# Antia et al. (1994)

```{r}
## Deterministic ##
r = 0.25; k = 0.01; p = 1; o = 1000
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 55/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-k*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + p*(P[t - 1]/(P[t - 1] + o))*ts)*I[t - 1]
}
Antia_Det <- data.frame(seq(0.1, 55, 0.1), P, I); colnames(Antia_Det) <- c("Time", "P", "I")
plot(Antia_Det$Time, Antia_Det$P, type = "l", col = "forestgreen",
     main = "Deterministic", xlab = "Time", ylab = "Abundance", ylim = c(0, max(Antia_Det[ , 2:3])))
lines(Antia_Det$Time, Antia_Det$I, col = "cornflowerblue")

## Stochastic ##
DiscreteModel_Dem <- function(P_Last, I_Last){
  ts = 0.1
  r = 0.25; k = 0.01; p = 1; o = 1000
  
  P_B = rpois(1, r*P_Last*ts) 
  P_D = rbinom(1, P_Last, (1-exp(-k*I_Last*ts))) 
  I_B = rpois(1, p*I_Last*((P_Last/(P_Last + o)))*ts) 
  
  P_Next = P_Last + P_B - P_D
  I_Next = I_Last + I_B
  
  P_Last <- P_Next
  I_Last <- I_Next
  
  if (P_Last < 0){
    P_Last <- 0
  }
  
  if (P_Last > 10^9){
    P_Last <- 0
    I_Last <- 0
  }
  return(c(P_Last, I_Last))
}

seeds <- c(6, 7, 8, 9, 10)
ts <- 0.1; t_stop <- 55/ts
P_Last <- 1; I_Last <- 1
Antia_Stoch_List <- list()

for (i in 1:length(seeds)){
  set.seed(seeds[i])
  P_Last <- 1; I_Last <- 1
  Antia_Stoch <- data.frame()
  for (j in 1:t_stop){
    Output = DiscreteModel_Dem(P_Last, I_Last)
    P_Last = Output[1]
    I_Last = Output[2]
    Addition <- c(P_Last, I_Last)
    Antia_Stoch <- data.frame(rbind(Antia_Stoch, Addition))
  }
  Antia_Stoch <- cbind(seq(0.1, 55, 0.1), Antia_Stoch)
  colnames(Antia_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(Antia_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    Antia_Stoch_List[[i]] <- Antia_Stoch
  } else {
    Antia_Stoch <- Antia_Stoch[1:FirstZero - 1, ]
    Antia_Stoch_List[[i]] <- Antia_Stoch
  }
}

## Plot deterministic and stochastic data together
par(mfrow = c(1, 1))
plot(Antia_Det$Time, Antia_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Discrete-Time Antia et al. (1994) Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 2000))
lines(Antia_Det$Time, Antia_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(Antia_Stoch_List[[1]]$Time, Antia_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[1]]$Time, Antia_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[2]]$Time, Antia_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[2]]$Time, Antia_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[3]]$Time, Antia_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[3]]$Time, Antia_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[4]]$Time, Antia_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[4]]$Time, Antia_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(Antia_Stoch_List[[5]]$Time, Antia_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(Antia_Stoch_List[[5]]$Time, Antia_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)

## Data wrangling for Stan ##
StanDataList <- list()
for (i in 1:5){
  Antia_Stoch <- Antia_Stoch_List[[i]]
  N <- length(Antia_Stoch$Time) - 1
  ts <- 1:N
  P_init <- c(Antia_Stoch$P[1])
  I_init <- c(Antia_Stoch$I[1])
  P <- as.vector(Antia_Stoch[2:(N + 1), 2:2])
  I <- as.vector(Antia_Stoch[2:(N + 1), 3:3])
  StanDataList[[i]] <- list(N = N, ts = ts, P_init = P_init, I_init = I_init, P = P, I = I)
}

## Write model ##
write("
data {
  int<lower = 0> N; // Number of observations
  real<lower = 0> P[N];
  real<lower = 0> I[N];
}
parameters {
  real<lower = 0> r; // Replication rate
  real<lower = 0> k; // Rate of destruction of parasite
  real<lower = 0> p; // Max. growth rate of immunity
  real<lower = 0> o; // Parasite density at which immunity slows
  real<lower = 0> sigma; // Error
}
model {
  r ~ normal(0, 1); // 0.2
  k ~ normal(0, 1); // 0.01
  p ~ normal(1, 1); // 1
  o ~ normal(1000, 10); // 1000
  sigma ~ normal(-1, 1);
  for (t in 2:N) {
    P[t] ~ normal((1 + r*0.1 - (1-exp(-k*I[t - 1]*0.1)))*P[t - 1], sigma);
    I[t] ~ normal((1 + p*(P[t - 1]/(P[t - 1] + o))*0.1)*I[t - 1], sigma);
  }
}",
"1_Models/Autoregressive_Antia.stan")

## Compile model ##
model <- stan_model("1_Models/Autoregressive_Antia.stan")

## Fitting ##
A.1.AR.Fit <- sampling(model, data = StanDataList[[1]], chains = 4, iter = 10000, cores = 4, seed = 1)
A.2.AR.Fit <- sampling(model, data = StanDataList[[2]], chains = 4, iter = 10000, cores = 4, seed = 1)
A.3.AR.Fit <- sampling(model, data = StanDataList[[3]], chains = 4, iter = 10000, cores = 4, seed = 1)
A.4.AR.Fit <- sampling(model, data = StanDataList[[4]], chains = 4, iter = 10000, cores = 4, seed = 1)
A.5.AR.Fit <- sampling(model, data = StanDataList[[5]], chains = 4, iter = 10000, cores = 4, seed = 1)

## Model checks ##
# 1
Fit1Summ <- print(A.1.AR.Fit, pars = c("r", "k", "p", "o"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "k", "p", "o")
Output <- rstan::extract(A.1.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(A.1.AR.Fit, parms)
# mcmc_pairs(A.1.AR.Fit, parms)
# mcmc_dens_overlay(A.1.AR.Fit, parms)

r = mean(Output[["r"]]); k = mean(Output[["k"]]); p = mean(Output[["p"]]); o = mean(Output[["o"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 55/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-k*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + p*(P[t - 1]/(P[t - 1] + o))*ts)*I[t - 1]
}
Antia_Est <- data.frame(seq(0.1, 55, 0.1), P, I); colnames(Antia_Est) <- c("Time", "P", "I")

plot(Antia_Stoch_List[[1]]$Time, Antia_Stoch_List[[1]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 1800))
lines(Antia_Stoch_List[[1]]$Time, Antia_Stoch_List[[1]]$I, col = "cornflowerblue", lwd = 2)
lines(Antia_Est$Time, Antia_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(Antia_Est$Time, Antia_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 2
Fit2Summ <- print(A.2.AR.Fit, pars = c("r", "k", "p", "o"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "k", "p", "o")
Output <- rstan::extract(A.2.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(A.2.AR.Fit, parms)
# mcmc_pairs(A.2.AR.Fit, parms)
# mcmc_dens_overlay(A.2.AR.Fit, parms)

r = mean(Output[["r"]]); k = mean(Output[["k"]]); p = mean(Output[["p"]]); o = mean(Output[["o"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 55/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-k*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + p*(P[t - 1]/(P[t - 1] + o))*ts)*I[t - 1]
}
Antia_Est <- data.frame(seq(0.1, 55, 0.1), P, I); colnames(Antia_Est) <- c("Time", "P", "I")

plot(Antia_Stoch_List[[2]]$Time, Antia_Stoch_List[[2]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 1500))
lines(Antia_Stoch_List[[2]]$Time, Antia_Stoch_List[[2]]$I, col = "cornflowerblue", lwd = 2)
lines(Antia_Est$Time, Antia_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(Antia_Est$Time, Antia_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 3
Fit3Summ <- print(A.3.AR.Fit, pars = c("r", "k", "p", "o"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "k", "p", "o")
Output <- rstan::extract(A.3.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(A.3.AR.Fit, parms)
# mcmc_pairs(A.3.AR.Fit, parms)
# mcmc_dens_overlay(A.3.AR.Fit, parms)

r = mean(Output[["r"]]); k = mean(Output[["k"]]); p = mean(Output[["p"]]); o = mean(Output[["o"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 55/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-k*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + p*(P[t - 1]/(P[t - 1] + o))*ts)*I[t - 1]
}
Antia_Est <- data.frame(seq(0.1, 55, 0.1), P, I); colnames(Antia_Est) <- c("Time", "P", "I")

plot(Antia_Stoch_List[[3]]$Time, Antia_Stoch_List[[3]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 1500))
lines(Antia_Stoch_List[[3]]$Time, Antia_Stoch_List[[3]]$I, col = "cornflowerblue", lwd = 2)
lines(Antia_Est$Time, Antia_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(Antia_Est$Time, Antia_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 4
Fit4Summ <- print(A.4.AR.Fit, pars = c("r", "k", "p", "o"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "k", "p", "o")
Output <- rstan::extract(A.4.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(A.4.AR.Fit, parms)
# mcmc_pairs(A.4.AR.Fit, parms)
# mcmc_dens_overlay(A.4.AR.Fit, parms)

r = mean(Output[["r"]]); k = mean(Output[["k"]]); p = mean(Output[["p"]]); o = mean(Output[["o"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 55/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-k*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + p*(P[t - 1]/(P[t - 1] + o))*ts)*I[t - 1]
}
Antia_Est <- data.frame(seq(0.1, 55, 0.1), P, I); colnames(Antia_Est) <- c("Time", "P", "I")

plot(Antia_Stoch_List[[4]]$Time, Antia_Stoch_List[[4]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 1500))
lines(Antia_Stoch_List[[4]]$Time, Antia_Stoch_List[[4]]$I, col = "cornflowerblue", lwd = 2)
lines(Antia_Est$Time, Antia_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(Antia_Est$Time, Antia_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 5
Fit5Summ <- print(A.5.AR.Fit, pars = c("r", "k", "p", "o"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "k", "p", "o")
Output <- rstan::extract(A.5.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(A.5.AR.Fit, parms)
# mcmc_pairs(A.5.AR.Fit, parms)
# mcmc_dens_overlay(A.5.AR.Fit, parms)

r = mean(Output[["r"]]); k = mean(Output[["k"]]); p = mean(Output[["p"]]); o = mean(Output[["o"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 55/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-k*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + p*(P[t - 1]/(P[t - 1] + o))*ts)*I[t - 1]
}
Antia_Est <- data.frame(seq(0.1, 55, 0.1), P, I); colnames(Antia_Est) <- c("Time", "P", "I")

plot(Antia_Stoch_List[[5]]$Time, Antia_Stoch_List[[5]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 1500))
lines(Antia_Stoch_List[[5]]$Time, Antia_Stoch_List[[5]]$I, col = "cornflowerblue", lwd = 2)
lines(Antia_Est$Time, Antia_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(Antia_Est$Time, Antia_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))
```

# Modified Fenton and Perkins (2010)

## Type I

```{r}
## Deterministic ##
r = 1.5; B = 0.001; b = 200; e = 0.9; delta = 0.2
P <- c(); I <- c()
P[1] = 10; I[1] = 10
ts = 0.1; t_stop = 80/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp(-B*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1])*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Det <- data.frame(seq(0.1, 80, 0.1), P, I); colnames(ModFentonPerkins_Det) <- c("Time", "P", "I")
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen",
     main = "Deterministic", xlab = "Time", ylab = "Abundance", ylim = c(0, max(ModFentonPerkins_Det[ , 2:3])))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue")

## Stochastic ##
DiscreteModel_Dem <- function(P_Last, I_Last){
  ts = 0.1
  r = 1.5; B = 0.001; b = 200; e = 0.9; delta = 0.2
  
  P_B = rpois(1, r*P_Last*ts) 
  P_D = rbinom(1, P_Last, (1-exp((-B)*I_Last*ts))) 
  I_B = rpois(1, (b + e*(B*P_Last)*I_Last)*ts)
  I_D = rbinom(1, I_Last, (1-exp(-delta*ts))) 
  
  P_Next = P_Last + P_B - P_D
  I_Next = I_Last + I_B - I_D
  
  P_Last <- P_Next
  I_Last <- I_Next
  
  ## To prevent the populations from going negative
  if (P_Last < 0){
    P_Last <- 0
  }
  
  return(c(P_Last, I_Last))
}

seeds <- c(3, 30, 41, 42, 46)
ts <- 0.1; t_stop <- 80/ts
P_Last <- 10; I_Last <- 10
ModFentonPerkins_Stoch_List <- list()

for (i in 1:length(seeds)){
  set.seed(seeds[i])
  P_Last <- 10; I_Last <- 10
  ModFentonPerkins_Stoch <- data.frame()
  for (j in 1:t_stop){
    Output = DiscreteModel_Dem(P_Last, I_Last)
    P_Last = Output[1]
    I_Last = Output[2]
    Addition <- c(P_Last, I_Last)
    ModFentonPerkins_Stoch <- data.frame(rbind(ModFentonPerkins_Stoch, Addition))
  }
  ModFentonPerkins_Stoch <- cbind(seq(0.1, 80, 0.1), ModFentonPerkins_Stoch)
  colnames(ModFentonPerkins_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  } else {
    ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  }
}

## Plot deterministic and stochastic data together
par(mfrow = c(1, 1))
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Discrete-Time Modified Fenton and Perkins (2010), Type I FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 4000))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)

## Data wrangling for Stan ##
StanDataList <- list()
for (i in 1:5){
  ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch_List[[i]]
  N <- length(ModFentonPerkins_Stoch$Time) - 1
  ts <- 1:N
  P_init <- c(ModFentonPerkins_Stoch$P[1])
  I_init <- c(ModFentonPerkins_Stoch$I[1])
  P <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 2:2])
  I <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 3:3])
  StanDataList[[i]] <- list(N = N, ts = ts, P_init = P_init, I_init = I_init, P = P, I = I)
}

## Write model ##
write("
data {
  int<lower = 0> N;
  real P[N];
  real I[N];
}
parameters {
  real<lower = 0> r; // Replication rate of parasite
  real<lower = 0> B; // Recognition rate of parasite by host immune system
  real<lower = 0> b; // Immigration rate of immune cells in absence of infection
  real<lower = 0> e; // Activation/proliferation rate of host immune system
  real<lower = 0> delta; // Natural mortality rate of host immune cells
  real<lower = 0> sigma; // Error
}
model {
  r ~ uniform(0, 2); // 1.5
  B ~ uniform(0, 1); // 0.001
  b ~ uniform(0, 300); // 200
  e ~ uniform(0, 1); // 0.9
  delta ~ uniform(0, 1); // 0.41
  sigma ~ normal(0, 1);
  for (t in 2:N) {
    P[t] ~ normal((1 + r*0.1 - (1-exp(-B*I[t - 1]*0.1)))*P[t - 1], sigma);
    I[t] ~ normal((1 + b*0.1*(1/I[t - 1]) + e*(B*P[t - 1])*0.1 - (1-exp(-delta*0.1)))*I[t - 1], sigma);
  }
}",
"1_Models/Autoregressive_ModFentonPerkins_1.stan")

## Compile model ##
model <- stan_model("1_Models/Autoregressive_ModFentonPerkins_1.stan")

## Fitting ##
MFP.I.1.AR.Fit <- sampling(model, data = StanDataList[[1]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.I.2.AR.Fit <- sampling(model, data = StanDataList[[2]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.I.3.AR.Fit <- sampling(model, data = StanDataList[[3]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.I.4.AR.Fit <- sampling(model, data = StanDataList[[4]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.I.5.AR.Fit <- sampling(model, data = StanDataList[[5]], chains = 4, iter = 10000, cores = 4, seed = 1)

## Model checks ##
# 1
Fit1Summ <- print(MFP.I.1.AR.Fit, pars = c("r", "B", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "b", "e", "delta")
Output <- rstan::extract(MFP.I.1.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.I.1.AR.Fit, parms)
# mcmc_pairs(MFP.I.1.AR.Fit, parms)
# mcmc_dens_overlay(MFP.I.1.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]])
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 10; I[1] = 10
ts = 0.1; t_stop = 80/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp((-B)*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1])*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 80, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 4000))
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 2
Fit2Summ <- print(MFP.I.2.AR.Fit, pars = c("r", "B", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "b", "e", "delta")
Output <- rstan::extract(MFP.I.2.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.I.2.AR.Fit, parms)
# mcmc_pairs(MFP.I.2.AR.Fit, parms)
# mcmc_dens_overlay(MFP.I.2.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]])
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 10; I[1] = 10
ts = 0.1; t_stop = 80/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp((-B)*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1])*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 80, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 4000))
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 3
Fit3Summ <- print(MFP.I.3.AR.Fit, pars = c("r", "B", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "b", "e", "delta")
Output <- rstan::extract(MFP.I.3.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.I.3.AR.Fit, parms)
# mcmc_pairs(MFP.I.3.AR.Fit, parms)
# mcmc_dens_overlay(MFP.I.3.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 10; I[1] = 10
ts = 0.1; t_stop = 80/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp((-B)*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1])*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 80, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 4000))
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 4
Fit4Summ <- print(MFP.I.4.AR.Fit, pars = c("r", "B", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "b", "e", "delta")
Output <- rstan::extract(MFP.I.4.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.I.4.AR.Fit, parms)
# mcmc_pairs(MFP.I.4.AR.Fit, parms)
# mcmc_dens_overlay(MFP.I.4.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 10; I[1] = 10
ts = 0.1; t_stop = 80/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp((-B)*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1])*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 80, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 4000))
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 5
Fit5Summ <- print(MFP.I.5.AR.Fit, pars = c("r", "B", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "b", "e", "delta")
Output <- rstan::extract(MFP.I.5.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.I.5.AR.Fit, parms)
# mcmc_pairs(MFP.I.5.AR.Fit, parms)
# mcmc_dens_overlay(MFP.I.5.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 10; I[1] = 10
ts = 0.1; t_stop = 80/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp((-B)*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1])*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 80, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 4000))
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))
```

## Type II: Divergent Oscillations

```{r}
## Deterministic ##
r = 2.5; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.41
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Det <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Det) <- c("Time", "P", "I")
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen",
     main = "Deterministic", xlab = "Time", ylab = "Abundance", ylim = c(0, max(ModFentonPerkins_Det[ , 2:3])))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue")

## Stochastic ##
DiscreteModel_Dem <- function(P_Last, I_Last){
  ts = 0.1
  r = 2.5; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.41
  
  P_B = rpois(1, r*P_Last*ts) 
  P_D = rbinom(1, P_Last, (1-exp((-B/(1 + B*h*P_Last))*I_Last*ts))) 
  I_B = rpois(1, (b + e*(B*P_Last/(1 + B*P_Last*h))*I_Last)*ts)
  I_D = rbinom(1, I_Last, (1-exp(-delta*ts))) 
  
  P_Next = P_Last + P_B - P_D
  I_Next = I_Last + I_B - I_D
  
  P_Last <- P_Next
  I_Last <- I_Next
  
  ## To prevent the populations from going negative
  if (P_Last < 0){
    P_Last <- 0
  }
  
  return(c(P_Last, I_Last))
}

seeds <- c(2, 3, 10, 11, 14)
ts <- 0.1; t_stop <- 60/ts
P_Last <- 80; I_Last <- 200
ModFentonPerkins_Stoch_List <- list()

for (i in 1:length(seeds)){
  set.seed(seeds[i])
  P_Last <- 80; I_Last <- 200
  ModFentonPerkins_Stoch <- data.frame()
  for (j in 1:t_stop){
    Output = DiscreteModel_Dem(P_Last, I_Last)
    P_Last = Output[1]
    I_Last = Output[2]
    Addition <- c(P_Last, I_Last)
    ModFentonPerkins_Stoch <- data.frame(rbind(ModFentonPerkins_Stoch, Addition))
  }
  ModFentonPerkins_Stoch <- cbind(seq(0.1, 60, 0.1), ModFentonPerkins_Stoch)
  colnames(ModFentonPerkins_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  } else {
    ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  }
}

## Plot deterministic and stochastic data together
par(mfrow = c(1, 1))
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Discrete-Time Modified Fenton and Perkins (2010), Type II FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 600))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)

## Data wrangling for Stan ##
StanDataList <- list()
for (i in 1:5){
  ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch_List[[i]]
  N <- length(ModFentonPerkins_Stoch$Time) - 1
  ts <- 1:N
  P_init <- c(ModFentonPerkins_Stoch$P[1])
  I_init <- c(ModFentonPerkins_Stoch$I[1])
  P <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 2:2])
  I <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 3:3])
  StanDataList[[i]] <- list(N = N, ts = ts, P_init = P_init, I_init = I_init, P = P, I = I)
}

## Write model ##
write("
data {
  int<lower = 0> N;
  real P[N];
  real I[N];
}
parameters {
  real<lower = 0> r; // Replication rate of parasite
  real<lower = 0> B; // Recognition rate of parasite by host immune system
  real<lower = 0> h; // Handling time of parasite by immune system
  real<lower = 0> b; // Immigration rate of immune cells in absence of infection
  real<lower = 0> e; // Activation/proliferation rate of host immune system
  real<lower = 0> delta; // Natural mortality rate of host immune cells
  real<lower=0> sigma; // Error
}
model {
  r ~ normal(2.5, 1); // 2.5
  B ~ normal(0, 1); // 0.012
  h ~ normal(0, 1); // 0.075
  b ~ normal(35, 1); // 35
  e ~ normal(0, 1); // 0.3
  delta ~ normal(0, 1); // 0.41
  sigma ~ lognormal(-1, 1);
  for (t in 2:N) {
    // P[t] ~ normal(P[t-1] + r*P[t-1]*0.1 - (1-exp((-B/(1 + B*h*P[t-1]))*I[t-1]*0.1))*P[t-1], sigma);
    // I[t] ~ normal(I[t-1] + b*0.1 + e*(B*P[t-1]/(1 + B*P[t-1]*h))*I[t-1]*0.1 - (1-exp(-delta))*I[t-1], sigma);
    P[t] ~ normal((1 + r*0.1 - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*0.1)))*P[t - 1], sigma);
    I[t] ~ normal((1 + b*0.1*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*0.1 - (1-exp(-delta*0.1)))*I[t - 1], sigma);
  }
}",
"1_Models/Autoregressive_ModFentonPerkins_2.stan")

## Compile model ##
model <- stan_model("1_Models/Autoregressive_ModFentonPerkins_2.stan")

## Fitting ##
MFP.II.DivOsc.1.AR.Fit <- sampling(model, data = StanDataList[[1]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DivOsc.2.AR.Fit <- sampling(model, data = StanDataList[[2]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DivOsc.3.AR.Fit <- sampling(model, data = StanDataList[[3]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DivOsc.4.AR.Fit <- sampling(model, data = StanDataList[[4]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DivOsc.5.AR.Fit <- sampling(model, data = StanDataList[[5]], chains = 4, iter = 10000, cores = 4, seed = 1)

## Model checks ##
# 1
Fit1Summ <- print(MFP.II.DivOsc.1.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DivOsc.1.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DivOsc.1.AR.Fit, parms)
# mcmc_pairs(MFP.II.DivOsc.1.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DivOsc.1.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 2
Fit2Summ <- print(MFP.II.DivOsc.2.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DivOsc.2.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DivOsc.2.AR.Fit, parms)
# mcmc_pairs(MFP.II.DivOsc.2.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DivOsc.2.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 3
Fit3Summ <- print(MFP.II.DivOsc.3.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DivOsc.3.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DivOsc.3.AR.Fit, parms)
# mcmc_pairs(MFP.II.DivOsc.3.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DivOsc.3.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 4
Fit4Summ <- print(MFP.II.DivOsc.4.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DivOsc.4.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DivOsc.4.AR.Fit, parms)
# mcmc_pairs(MFP.II.DivOsc.4.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DivOsc.4.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 5
Fit5Summ <- print(MFP.II.DivOsc.5.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DivOsc.5.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DivOsc.5.AR.Fit, parms)
# mcmc_pairs(MFP.II.DivOsc.5.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DivOsc.5.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))
```

## Type II: Stable Limit Cycle

```{r}
## Deterministic ##
r = 2.5; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.34
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Det <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Det) <- c("Time", "P", "I")
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen",
     main = "Deterministic", xlab = "Time", ylab = "Abundance", ylim = c(0, max(ModFentonPerkins_Det[ , 2:3])))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue")

## Stochastic ##
DiscreteModel_Dem <- function(P_Last, I_Last){
  ts = 0.1
  r = 2.5; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.34
  
  P_B = rpois(1, r*P_Last*ts) 
  P_D = rbinom(1, P_Last, (1-exp((-B/(1 + B*h*P_Last))*I_Last*ts))) 
  I_B = rpois(1, (b + e*(B*P_Last/(1 + B*P_Last*h))*I_Last)*ts)
  I_D = rbinom(1, I_Last, (1-exp(-delta*ts))) 
  
  P_Next = P_Last + P_B - P_D
  I_Next = I_Last + I_B - I_D
  
  P_Last <- P_Next
  I_Last <- I_Next
  
  ## To prevent the populations from going negative
  if (P_Last < 0){
    P_Last <- 0
  }
  
  return(c(P_Last, I_Last))
}

seeds <- c(3, 7, 9, 10, 11)
ts <- 0.1; t_stop <- 60/ts
P_Last <- 80; I_Last <- 200
ModFentonPerkins_Stoch_List <- list()

for (i in 1:length(seeds)){
  set.seed(seeds[i])
  P_Last <- 80; I_Last <- 200
  ModFentonPerkins_Stoch <- data.frame()
  for (j in 1:t_stop){
    Output = DiscreteModel_Dem(P_Last, I_Last)
    P_Last = Output[1]
    I_Last = Output[2]
    Addition <- c(P_Last, I_Last)
    ModFentonPerkins_Stoch <- data.frame(rbind(ModFentonPerkins_Stoch, Addition))
  }
  ModFentonPerkins_Stoch <- cbind(seq(0.1, 60, 0.1), ModFentonPerkins_Stoch)
  colnames(ModFentonPerkins_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  } else {
    ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  }
}

## Plot deterministic and stochastic data together
par(mfrow = c(1, 1))
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Discrete-Time Modified Fenton and Perkins (2010), Type II FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 600))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)

## Data wrangling for Stan ##
StanDataList <- list()
for (i in 1:5){
  ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch_List[[i]]
  N <- length(ModFentonPerkins_Stoch$Time) - 1
  ts <- 1:N
  P_init <- c(ModFentonPerkins_Stoch$P[1])
  I_init <- c(ModFentonPerkins_Stoch$I[1])
  P <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 2:2])
  I <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 3:3])
  StanDataList[[i]] <- list(N = N, ts = ts, P_init = P_init, I_init = I_init, P = P, I = I)
}

## Write model ##
write("
data {
  int<lower = 0> N;
  real P[N];
  real I[N];
}
parameters {
  real<lower = 0> r; // Replication rate of parasite
  real<lower = 0> B; // Recognition rate of parasite by host immune system
  real<lower = 0> h; // Handling time of parasite by immune system
  real<lower = 0> b; // Immigration rate of immune cells in absence of infection
  real<lower = 0> e; // Activation/proliferation rate of host immune system
  real<lower = 0> delta; // Natural mortality rate of host immune cells
  real<lower=0> sigma; // Error
}
model {
  r ~ normal(2.5, 1); // 2.5
  B ~ normal(0, 1); // 0.012
  h ~ normal(0, 1); // 0.075
  b ~ normal(35, 1); // 35
  e ~ normal(0, 1); // 0.3
  delta ~ normal(0, 1); // 0.41
  sigma ~ lognormal(-1, 1);
  for (t in 2:N) {
    // P[t] ~ normal(P[t-1] + r*P[t-1]*0.1 - (1-exp((-B/(1 + B*h*P[t-1]))*I[t-1]*0.1))*P[t-1], sigma);
    // I[t] ~ normal(I[t-1] + b*0.1 + e*(B*P[t-1]/(1 + B*P[t-1]*h))*I[t-1]*0.1 - (1-exp(-delta))*I[t-1], sigma);
    P[t] ~ normal((1 + r*0.1 - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*0.1)))*P[t - 1], sigma);
    I[t] ~ normal((1 + b*0.1*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*0.1 - (1-exp(-delta*0.1)))*I[t - 1], sigma);
  }
}",
"1_Models/Autoregressive_ModFentonPerkins_2.stan")

## Compile model ##
model <- stan_model("1_Models/Autoregressive_ModFentonPerkins_2.stan")

## Fitting ##
MFP.II.SLC.1.AR.Fit <- sampling(model, data = StanDataList[[1]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.SLC.2.AR.Fit <- sampling(model, data = StanDataList[[2]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.SLC.3.AR.Fit <- sampling(model, data = StanDataList[[3]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.SLC.4.AR.Fit <- sampling(model, data = StanDataList[[4]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.SLC.5.AR.Fit <- sampling(model, data = StanDataList[[5]], chains = 4, iter = 10000, cores = 4, seed = 1)

## Model checks ##
# 1
Fit1Summ <- print(MFP.II.SLC.1.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.SLC.1.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.SLC.1.AR.Fit, parms)
# mcmc_pairs(MFP.II.SLC.1.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.SLC.1.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 2
Fit2Summ <- print(MFP.II.SLC.2.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.SLC.2.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.SLC.2.AR.Fit, parms)
# mcmc_pairs(MFP.II.SLC.2.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.SLC.2.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 3
Fit3Summ <- print(MFP.II.SLC.3.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.SLC.3.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.SLC.3.AR.Fit, parms)
# mcmc_pairs(MFP.II.SLC.3.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.SLC.3.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 4
Fit4Summ <- print(MFP.II.SLC.4.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.SLC.4.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.SLC.4.AR.Fit, parms)
# mcmc_pairs(MFP.II.SLC.4.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.SLC.4.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 5
Fit5Summ <- print(MFP.II.SLC.5.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.SLC.5.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.SLC.5.AR.Fit, parms)
# mcmc_pairs(MFP.II.SLC.5.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.SLC.5.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))
```

## Type II: Damping Oscillations

```{r}
## Deterministic ##
r = 2.1; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.34
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Det <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Det) <- c("Time", "P", "I")
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen",
     main = "Deterministic", xlab = "Time", ylab = "Abundance", ylim = c(0, max(ModFentonPerkins_Det[ , 2:3])))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue")

## Stochastic ##
DiscreteModel_Dem <- function(P_Last, I_Last){
  ts = 0.1
  r = 2.1; B = 0.012; h = 0.075; b = 35; e = 0.3; delta = 0.34
  
  P_B = rpois(1, r*P_Last*ts) 
  P_D = rbinom(1, P_Last, (1-exp((-B/(1 + B*h*P_Last))*I_Last*ts))) 
  I_B = rpois(1, (b + e*(B*P_Last/(1 + B*P_Last*h))*I_Last)*ts)
  I_D = rbinom(1, I_Last, (1-exp(-delta*ts))) 
  
  P_Next = P_Last + P_B - P_D
  I_Next = I_Last + I_B - I_D
  
  P_Last <- P_Next
  I_Last <- I_Next
  
  ## To prevent the populations from going negative
  if (P_Last < 0){
    P_Last <- 0
  }
  
  return(c(P_Last, I_Last))
}

seeds <- c(3, 4, 5, 6, 7)
ts <- 0.1; t_stop <- 60/ts
P_Last <- 80; I_Last <- 200
ModFentonPerkins_Stoch_List <- list()

for (i in 1:length(seeds)){
  set.seed(seeds[i])
  P_Last <- 80; I_Last <- 200
  ModFentonPerkins_Stoch <- data.frame()
  for (j in 1:t_stop){
    Output = DiscreteModel_Dem(P_Last, I_Last)
    P_Last = Output[1]
    I_Last = Output[2]
    Addition <- c(P_Last, I_Last)
    ModFentonPerkins_Stoch <- data.frame(rbind(ModFentonPerkins_Stoch, Addition))
  }
  ModFentonPerkins_Stoch <- cbind(seq(0.1, 60, 0.1), ModFentonPerkins_Stoch)
  colnames(ModFentonPerkins_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  } else {
    ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  }
}

## Plot deterministic and stochastic data together
par(mfrow = c(1, 1))
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Discrete-Time Modified Fenton and Perkins (2010), Type II FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 350))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)

## Data wrangling for Stan ##
StanDataList <- list()
for (i in 1:5){
  ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch_List[[i]]
  N <- length(ModFentonPerkins_Stoch$Time) - 1
  ts <- 1:N
  P_init <- c(ModFentonPerkins_Stoch$P[1])
  I_init <- c(ModFentonPerkins_Stoch$I[1])
  P <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 2:2])
  I <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 3:3])
  StanDataList[[i]] <- list(N = N, ts = ts, P_init = P_init, I_init = I_init, P = P, I = I)
}

## Write model ##
write("
data {
  int<lower = 0> N;
  real P[N];
  real I[N];
}
parameters {
  real<lower = 0> r; // Replication rate of parasite
  real<lower = 0> B; // Recognition rate of parasite by host immune system
  real<lower = 0> h; // Handling time of parasite by immune system
  real<lower = 0> b; // Immigration rate of immune cells in absence of infection
  real<lower = 0> e; // Activation/proliferation rate of host immune system
  real<lower = 0> delta; // Natural mortality rate of host immune cells
  real<lower=0> sigma; // Error
}
model {
  r ~ normal(2.5, 1); // 2.5
  B ~ normal(0, 1); // 0.012
  h ~ normal(0, 1); // 0.075
  b ~ normal(35, 1); // 35
  e ~ normal(0, 1); // 0.3
  delta ~ normal(0, 1); // 0.41
  sigma ~ lognormal(-1, 1);
  for (t in 2:N) {
    // P[t] ~ normal(P[t-1] + r*P[t-1]*0.1 - (1-exp((-B/(1 + B*h*P[t-1]))*I[t-1]*0.1))*P[t-1], sigma);
    // I[t] ~ normal(I[t-1] + b*0.1 + e*(B*P[t-1]/(1 + B*P[t-1]*h))*I[t-1]*0.1 - (1-exp(-delta))*I[t-1], sigma);
    P[t] ~ normal((1 + r*0.1 - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*0.1)))*P[t - 1], sigma);
    I[t] ~ normal((1 + b*0.1*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*0.1 - (1-exp(-delta*0.1)))*I[t - 1], sigma);
  }
}",
"1_Models/Autoregressive_ModFentonPerkins_2.stan")

## Compile model ##
model <- stan_model("1_Models/Autoregressive_ModFentonPerkins_2.stan")

## Fitting ##
MFP.II.DampOsc.1.AR.Fit <- sampling(model, data = StanDataList[[1]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DampOsc.2.AR.Fit <- sampling(model, data = StanDataList[[2]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DampOsc.3.AR.Fit <- sampling(model, data = StanDataList[[3]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DampOsc.4.AR.Fit <- sampling(model, data = StanDataList[[4]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.II.DampOsc.5.AR.Fit <- sampling(model, data = StanDataList[[5]], chains = 4, iter = 10000, cores = 4, seed = 1)

## Model checks ##
# 1
Fit1Summ <- print(MFP.II.DampOsc.1.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DampOsc.1.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DampOsc.1.AR.Fit, parms)
# mcmc_pairs(MFP.II.DampOsc.1.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DampOsc.1.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 2
Fit2Summ <- print(MFP.II.DampOsc.2.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DampOsc.2.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DampOsc.2.AR.Fit, parms)
# mcmc_pairs(MFP.II.DampOsc.2.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DampOsc.2.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 3
Fit3Summ <- print(MFP.II.DampOsc.3.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DampOsc.3.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DampOsc.3.AR.Fit, parms)
# mcmc_pairs(MFP.II.DampOsc.3.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DampOsc.3.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 4
Fit4Summ <- print(MFP.II.DampOsc.4.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DampOsc.4.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DampOsc.4.AR.Fit, parms)
# mcmc_pairs(MFP.II.DampOsc.4.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DampOsc.4.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 5
Fit5Summ <- print(MFP.II.DampOsc.5.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.II.DampOsc.5.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.II.DampOsc.5.AR.Fit, parms)
# mcmc_pairs(MFP.II.DampOsc.5.AR.Fit, parms)
# mcmc_dens_overlay(MFP.II.DampOsc.5.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 80; I[1] = 200
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B/(1 + B*h*P[t - 1]))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]/(1 + B*P[t - 1]*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 500))
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))
```

## Type III

```{r}
## Deterministic ##
r = 3.0; B = 0.0015; h = 0.2; b = 35; e = 0.2; delta = 0.5
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  P[t] = (1 + r*ts - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Det <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Det) <- c("Time", "P", "I")
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen",
     main = "Deterministic", xlab = "Time", ylab = "Abundance", ylim = c(0, 200)
     #, ylim = c(0, max(ModFentonPerkins_Det[ , 2:3]))
     )
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue")

## Stochastic ##
DiscreteModel_Dem <- function(P_Last, I_Last){
  ts = 0.1
  r = 3.0; B = 0.0015; h = 0.2; b = 35; e = 0.2; delta = 0.5
  
  P_B = rpois(1, r*P_Last*ts) 
  P_D = rbinom(1, P_Last, (1-exp((-B*P_Last/(1 + B*h*P_Last^2))*I_Last*ts))) 
  I_B = rpois(1, (b + e*(B*P_Last^2/(1 + B*P_Last^2*h))*I_Last)*ts)
  I_D = rbinom(1, I_Last, (1-exp(-delta*ts))) 
  
  P_Next = P_Last + P_B - P_D
  I_Next = I_Last + I_B - I_D
  
  P_Last <- P_Next
  I_Last <- I_Next
  
  ## To prevent the populations from going negative
  if (P_Last < 0){
    P_Last <- 0
  }
  
  return(c(P_Last, I_Last))
}

seeds <- c(1, 3, 5, 7, 9)
ts <- 0.1; t_stop <- 60/ts
P_Last <- 1; I_Last <- 1
ModFentonPerkins_Stoch_List <- list()

for (i in 1:length(seeds)){
  set.seed(seeds[i])
  P_Last <- 1; I_Last <- 1
  ModFentonPerkins_Stoch <- data.frame()
  for (j in 1:t_stop){
    Output = DiscreteModel_Dem(P_Last, I_Last)
    P_Last = Output[1]
    I_Last = Output[2]
    Addition <- c(P_Last, I_Last)
    ModFentonPerkins_Stoch <- data.frame(rbind(ModFentonPerkins_Stoch, Addition))
  }
  ModFentonPerkins_Stoch <- cbind(seq(0.1, 60, 0.1), ModFentonPerkins_Stoch)
  colnames(ModFentonPerkins_Stoch) <- c("Time", "P", "I")
  FirstZero <- which(ModFentonPerkins_Stoch$P == 0)[1]
  if (is.na(FirstZero)){
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  } else {
    ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch[1:FirstZero - 1, ]
    ModFentonPerkins_Stoch_List[[i]] <- ModFentonPerkins_Stoch
  }
}

## Plot deterministic and stochastic data together
par(mfrow = c(1, 1))
plot(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$P, type = "l", col = "forestgreen", lty = 1, lwd = 3,
     main = "Discrete-Time Modified Fenton and Perkins (2010), Type III FR Model", xlab = "Time", ylab = "Abundance", ylim = c(0, 200))
lines(ModFentonPerkins_Det$Time, ModFentonPerkins_Det$I, col = "cornflowerblue", lty = 1, lwd = 3)

lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, col = "forestgreen", lty = 3, lwd = 2)
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lty = 3, lwd = 2)

legend("topright", legend = c("Deterministic", "Stochastic"), lty = c(1, 3), lwd = 3)

## Data wrangling for Stan ##
StanDataList <- list()
for (i in 1:5){
  ModFentonPerkins_Stoch <- ModFentonPerkins_Stoch_List[[i]]
  N <- length(ModFentonPerkins_Stoch$Time) - 1
  ts <- 1:N
  P_init <- c(ModFentonPerkins_Stoch$P[1])
  I_init <- c(ModFentonPerkins_Stoch$I[1])
  P <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 2:2])
  I <- as.vector(ModFentonPerkins_Stoch[2:(N + 1), 3:3])
  StanDataList[[i]] <- list(N = N, ts = ts, P_init = P_init, I_init = I_init, P = P, I = I)
}

## Write model ##
write("
data {
  int<lower = 0> N;
  real P[N];
  real I[N];
}
parameters {
  real<lower = 0> r; // Replication rate of parasite
  real<lower = 0> B; // Recognition rate of parasite by host immune system
  real<lower = 0> h; // Handling time of parasite by immune system
  real<lower = 0> b; // Immigration rate of immune cells in absence of infection
  real<lower = 0> e; // Activation/proliferation rate of host immune system
  real<lower = 0> delta; // Natural mortality rate of host immune cells
  real<lower=0> sigma; // Error
}
model {
  r ~ normal(3, 1); // 3.0
  B ~ normal(0, 1); // 0.0015
  h ~ normal(0, 1); // 0.2
  b ~ normal(35, 1); // 35
  e ~ normal(0, 1); // 0.2
  delta ~ normal(0, 1); // 0.5
  sigma ~ lognormal(-1, 1);
  for (t in 2:N) {
    P[t] ~ normal((1 + r*0.1 - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*0.1)))*P[t - 1], sigma);
    I[t] ~ normal((1 + b*0.1*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*0.1 - (1-exp(-delta*0.1)))*I[t - 1], sigma);
  }
}",
"1_Models/Autoregressive_ModFentonPerkins_3.stan")

## Compile model ##
model <- stan_model("1_Models/Autoregressive_ModFentonPerkins_3.stan")

## Fitting ##
MFP.III.1.AR.Fit <- sampling(model, data = StanDataList[[1]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.III.2.AR.Fit <- sampling(model, data = StanDataList[[2]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.III.3.AR.Fit <- sampling(model, data = StanDataList[[3]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.III.4.AR.Fit <- sampling(model, data = StanDataList[[4]], chains = 4, iter = 10000, cores = 4, seed = 1)
MFP.III.5.AR.Fit <- sampling(model, data = StanDataList[[5]], chains = 4, iter = 10000, cores = 4, seed = 1)

## Model checks ##
# 1
Fit1Summ <- print(MFP.III.1.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.III.1.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.III.1.AR.Fit, parms)
# mcmc_pairs(MFP.III.1.AR.Fit, parms)
# mcmc_dens_overlay(MFP.III.1.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 300))
lines(ModFentonPerkins_Stoch_List[[1]]$Time, ModFentonPerkins_Stoch_List[[1]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 2
Fit2Summ <- print(MFP.III.2.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.III.2.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.III.2.AR.Fit, parms)
# mcmc_pairs(MFP.III.2.AR.Fit, parms)
# mcmc_dens_overlay(MFP.III.2.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 300))
lines(ModFentonPerkins_Stoch_List[[2]]$Time, ModFentonPerkins_Stoch_List[[2]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 3
Fit3Summ <- print(MFP.III.3.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.III.3.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.III.3.AR.Fit, parms)
# mcmc_pairs(MFP.III.3.AR.Fit, parms)
# mcmc_dens_overlay(MFP.III.3.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 300))
lines(ModFentonPerkins_Stoch_List[[3]]$Time, ModFentonPerkins_Stoch_List[[3]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 4
Fit4Summ <- print(MFP.III.4.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.III.4.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.III.4.AR.Fit, parms)
# mcmc_pairs(MFP.III.4.AR.Fit, parms)
# mcmc_dens_overlay(MFP.III.4.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 300))
lines(ModFentonPerkins_Stoch_List[[4]]$Time, ModFentonPerkins_Stoch_List[[4]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))

# 5
Fit5Summ <- print(MFP.III.5.AR.Fit, pars = c("r", "B", "h", "b", "e", "delta"),
                  probs = c(0.1, 0.5, 0.9), digits = 3)
parms <- c("r", "B", "h", "b", "e", "delta")
Output <- rstan::extract(MFP.III.5.AR.Fit, permuted = TRUE, include = TRUE)
# stan_trace(MFP.III.5.AR.Fit, parms)
# mcmc_pairs(MFP.III.5.AR.Fit, parms)
# mcmc_dens_overlay(MFP.III.5.AR.Fit, parms)

r = mean(Output[["r"]]); B = mean(Output[["B"]]); h = mean(Output[["h"]]) 
b = mean(Output[["b"]]); e = mean(Output[["e"]]); delta = mean(Output[["delta"]])
P <- c(); I <- c()
P[1] = 1; I[1] = 1
ts = 0.1; t_stop = 60/ts
for (t in 2:t_stop){
  # P[t] = P[t - 1] + r*P[t - 1]*ts - (((B*P[t - 1])/(1 + B*P[t - 1]*h))*I[t - 1]*ts)
  # I[t] = I[t - 1] + b*ts + (e*I[t - 1]*((B*P[t - 1])/(1 + B*P[t - 1]*h))*ts) - delta*I[t - 1]*ts
  P[t] = (1 + r*ts - (1-exp((-B*P[t - 1]/(1 + B*h*P[t - 1]^2))*I[t - 1]*ts)))*P[t - 1]
  I[t] = (1 + b*ts*(1/I[t - 1]) + e*(B*P[t - 1]^2/(1 + B*P[t - 1]^2*h))*ts - (1-exp(-delta*ts)))*I[t - 1]
}
ModFentonPerkins_Est <- data.frame(seq(0.1, 60, 0.1), P, I); colnames(ModFentonPerkins_Est) <- c("Time", "P", "I")

plot(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$P, type = "l", col = "forestgreen", lwd = 2,
     xlab = "Time", ylab = "Abundance", ylim = c(0, 300))
lines(ModFentonPerkins_Stoch_List[[5]]$Time, ModFentonPerkins_Stoch_List[[5]]$I, col = "cornflowerblue", lwd = 2)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$P, col = "forestgreen", lwd = 2, lty = 3)
lines(ModFentonPerkins_Est$Time, ModFentonPerkins_Est$I, col = "cornflowerblue", lwd = 2, lty = 3)
# legend("topleft", legend = c("Data", "Estimate"), lty = c(1, 3))
```

# PLOTTING

# Posterior Distributions of Parameter Estimates

## Antia et al. (1994)

```{r}
colours = c("orchid", "forestgreen", "orange", "red3", "lightblue")

# Antia, Global
A.Global.1 <- rstan::extract(Antia_FitObj1, permuted = TRUE, include = TRUE)
A.Global.2 <- rstan::extract(Antia_FitObj2, permuted = TRUE, include = TRUE)
A.Global.3 <- rstan::extract(Antia_FitObj3, permuted = TRUE, include = TRUE)
A.Global.4 <- rstan::extract(Antia_FitObj4, permuted = TRUE, include = TRUE)
A.Global.5 <- rstan::extract(Antia_FitObj5, permuted = TRUE, include = TRUE)

A.G.r.df <- data.frame(TimeSeries = c(rep("1", length(A.Global.1$r)), rep("2", length(A.Global.2$r)), rep("3", length(A.Global.3$r)), rep("4", length(A.Global.4$r)), rep("5", length(A.Global.5$r))), Estimate = c(A.Global.1$r, A.Global.2$r, A.Global.3$r, A.Global.4$r, A.Global.5$r))
A.G.r <- ggplot(data = A.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.25) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

A.G.k.df <- data.frame(TimeSeries = c(rep("1", length(A.Global.1$k)), rep("2", length(A.Global.2$k)), rep("3", length(A.Global.3$k)), rep("4", length(A.Global.4$k)), rep("5", length(A.Global.5$k))), Estimate = c(A.Global.1$k, A.Global.2$k, A.Global.3$k, A.Global.4$k, A.Global.5$k))
A.G.k <- ggplot(data = A.G.k.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(k), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.01) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

A.G.p.df <- data.frame(TimeSeries = c(rep("1", length(A.Global.1$p)), rep("2", length(A.Global.2$p)), rep("3", length(A.Global.3$p)), rep("4", length(A.Global.4$p)), rep("5", length(A.Global.5$p))), Estimate = c(A.Global.1$p, A.Global.2$p, A.Global.3$p, A.Global.4$p, A.Global.5$p))
A.G.p <- ggplot(data = A.G.p.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(rho), x = "", y = "", fill = "") +
  geom_vline(xintercept = 1) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

A.G.o.df <- data.frame(TimeSeries = c(rep("1", length(A.Global.1$o)), rep("2", length(A.Global.2$o)), rep("3", length(A.Global.3$o)), rep("4", length(A.Global.4$o)), rep("5", length(A.Global.5$o))), Estimate = c(A.Global.1$o, A.Global.2$o, A.Global.3$o, A.Global.4$o, A.Global.5$o))
A.G.o <- ggplot(data = A.G.o.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(phi), x = "", y = "", fill = "") +
  geom_vline(xintercept = 1000) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

A.Global <- plot_grid(A.G.r, A.G.k, A.G.p, A.G.o, nrow = 2)
title <- textGrob("Antia et al. (1994), Global Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(A.Global, top = title, left = y.lab, bottom = x.lab))

# Antia, Autoregressive
A.AR.1 <- rstan::extract(A.1.AR.Fit, permuted = TRUE, include = TRUE)
A.AR.2 <- rstan::extract(A.2.AR.Fit, permuted = TRUE, include = TRUE)
A.AR.3 <- rstan::extract(A.3.AR.Fit, permuted = TRUE, include = TRUE)
A.AR.4 <- rstan::extract(A.4.AR.Fit, permuted = TRUE, include = TRUE)
A.AR.5 <- rstan::extract(A.5.AR.Fit, permuted = TRUE, include = TRUE)

A.AR.r.df <- data.frame(TimeSeries = c(rep("1", length(A.AR.1$r)), rep("2", length(A.AR.2$r)), rep("3", length(A.AR.3$r)), rep("4", length(A.AR.4$r)), rep("5", length(A.AR.5$r))), Estimate = c(A.AR.1$r, A.AR.2$r, A.AR.3$r, A.AR.4$r, A.AR.5$r))
A.AR.r <- ggplot(data = A.AR.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.25) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

A.AR.k.df <- data.frame(TimeSeries = c(rep("1", length(A.AR.1$k)), rep("2", length(A.AR.2$k)), rep("3", length(A.AR.3$k)), rep("4", length(A.AR.4$k)), rep("5", length(A.AR.5$k))), Estimate = c(A.AR.1$k, A.AR.2$k, A.AR.3$k, A.AR.4$k, A.AR.5$k))
A.AR.k <- ggplot(data = A.AR.k.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(k), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.01) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

A.AR.p.df <- data.frame(TimeSeries = c(rep("1", length(A.AR.1$p)), rep("2", length(A.AR.2$p)), rep("3", length(A.AR.3$p)), rep("4", length(A.AR.4$p)), rep("5", length(A.AR.5$p))), Estimate = c(A.AR.1$p, A.AR.2$p, A.AR.3$p, A.AR.4$p, A.AR.5$p))
A.AR.p <- ggplot(data = A.AR.p.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(rho), x = "", y = "", fill = "") +
  geom_vline(xintercept = 1) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

A.AR.o.df <- data.frame(TimeSeries = c(rep("1", length(A.AR.1$o)), rep("2", length(A.AR.2$o)), rep("3", length(A.AR.3$o)), rep("4", length(A.AR.4$o)), rep("5", length(A.AR.5$o))), Estimate = c(A.AR.1$o, A.AR.2$o, A.AR.3$o, A.AR.4$o, A.AR.5$o))
A.AR.o <- ggplot(data = A.AR.o.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(phi), x = "", y = "", fill = "") +
  geom_vline(xintercept = 1000) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

A.AR <- plot_grid(A.AR.r, A.AR.k, A.AR.p, A.AR.o, nrow = 2)
title <- textGrob("Antia et al. (1994), Autoregressive Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(A.AR, top = title, left = y.lab, bottom = x.lab))
```

## MFP (2010), Type I FR

```{r}
# Global
MFP.1.Global.1 <- rstan::extract(ModFentonPerkins_1_FitObj1, permuted = TRUE, include = TRUE)
MFP.1.Global.2 <- rstan::extract(ModFentonPerkins_1_FitObj2, permuted = TRUE, include = TRUE)
MFP.1.Global.3 <- rstan::extract(ModFentonPerkins_1_FitObj3, permuted = TRUE, include = TRUE)
MFP.1.Global.4 <- rstan::extract(ModFentonPerkins_1_FitObj4, permuted = TRUE, include = TRUE)
MFP.1.Global.5 <- rstan::extract(ModFentonPerkins_1_FitObj5, permuted = TRUE, include = TRUE)

MFP.1.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.Global.1$theta[ ,1])), rep("2", length(MFP.1.Global.2$theta[ ,1])), rep("3", length(MFP.1.Global.3$theta[ ,1])), rep("4", length(MFP.1.Global.4$theta[ ,1])), rep("5", length(MFP.1.Global.5$theta[ ,1]))), Estimate = c(MFP.1.Global.1$theta[ ,1], MFP.1.Global.2$theta[ ,1], MFP.1.Global.3$theta[ ,1], MFP.1.Global.4$theta[ ,1], MFP.1.Global.5$theta[ ,1]))
MFP.1.G.r <- ggplot(data = MFP.1.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 1.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.1.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.Global.1$theta[ ,2])), rep("2", length(MFP.1.Global.2$theta[ ,2])), rep("3", length(MFP.1.Global.3$theta[ ,2])), rep("4", length(MFP.1.Global.4$theta[ ,2])), rep("5", length(MFP.1.Global.5$theta[ ,2]))), Estimate = c(MFP.1.Global.1$theta[ ,2], MFP.1.Global.2$theta[ ,2], MFP.1.Global.3$theta[ ,2], MFP.1.Global.4$theta[ ,2], MFP.1.Global.5$theta[ ,2]))
MFP.1.G.B <- ggplot(data = MFP.1.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.001) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.1.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.Global.1$theta[ ,3])), rep("2", length(MFP.1.Global.2$theta[ ,3])), rep("3", length(MFP.1.Global.3$theta[ ,3])), rep("4", length(MFP.1.Global.4$theta[ ,3])), rep("5", length(MFP.1.Global.5$theta[ ,3]))), Estimate = c(MFP.1.Global.1$theta[ ,3], MFP.1.Global.2$theta[ ,3], MFP.1.Global.3$theta[ ,3], MFP.1.Global.4$theta[ ,3], MFP.1.Global.5$theta[ ,3]))
MFP.1.G.b <- ggplot(data = MFP.1.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 200) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.1.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.Global.1$theta[ ,4])), rep("2", length(MFP.1.Global.2$theta[ ,4])), rep("3", length(MFP.1.Global.3$theta[ ,4])), rep("4", length(MFP.1.Global.4$theta[ ,4])), rep("5", length(MFP.1.Global.5$theta[ ,4]))), Estimate = c(MFP.1.Global.1$theta[ ,4], MFP.1.Global.2$theta[ ,4], MFP.1.Global.3$theta[ ,4], MFP.1.Global.4$theta[ ,4], MFP.1.Global.5$theta[ ,4]))
MFP.1.G.e <- ggplot(data = MFP.1.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.9) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.1.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.Global.1$theta[ ,5])), rep("2", length(MFP.1.Global.2$theta[ ,5])), rep("3", length(MFP.1.Global.3$theta[ ,5])), rep("4", length(MFP.1.Global.4$theta[ ,5])), rep("5", length(MFP.1.Global.5$theta[ ,5]))), Estimate = c(MFP.1.Global.1$theta[ ,5], MFP.1.Global.2$theta[ ,5], MFP.1.Global.3$theta[ ,5], MFP.1.Global.4$theta[ ,5], MFP.1.Global.5$theta[ ,5]))
MFP.1.G.d <- ggplot(data = MFP.1.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.1.Global <- plot_grid(MFP.1.G.r, MFP.1.G.B, MFP.1.G.b, MFP.1.G.e, MFP.1.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type I FR, Global Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.1.Global, top = title, left = y.lab, bottom = x.lab))

# Autoregressive
MFP.1.AR.1 <- rstan::extract(MFP.I.1.AR.Fit, permuted = TRUE, include = TRUE)
MFP.1.AR.2 <- rstan::extract(MFP.I.2.AR.Fit, permuted = TRUE, include = TRUE)
MFP.1.AR.3 <- rstan::extract(MFP.I.3.AR.Fit, permuted = TRUE, include = TRUE)
MFP.1.AR.4 <- rstan::extract(MFP.I.4.AR.Fit, permuted = TRUE, include = TRUE)
MFP.1.AR.5 <- rstan::extract(MFP.I.5.AR.Fit, permuted = TRUE, include = TRUE)

MFP.1.AR.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.AR.1$r)), rep("2", length(MFP.1.AR.2$r)), rep("3", length(MFP.1.AR.3$r)), rep("4", length(MFP.1.AR.4$r)), rep("5", length(MFP.1.AR.5$r))), Estimate = c(MFP.1.AR.1$r, MFP.1.AR.2$r, MFP.1.AR.3$r, MFP.1.AR.4$r, MFP.1.AR.5$r))
MFP.1.AR.r <- ggplot(data = MFP.1.AR.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 1.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.1.AR.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.AR.1$B)), rep("2", length(MFP.1.AR.2$B)), rep("3", length(MFP.1.AR.3$B)), rep("4", length(MFP.1.AR.4$B)), rep("5", length(MFP.1.AR.5$B))), Estimate = c(MFP.1.AR.1$B, MFP.1.AR.2$B, MFP.1.AR.3$B, MFP.1.AR.4$B, MFP.1.AR.5$B))
MFP.1.AR.B <- ggplot(data = MFP.1.AR.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.001) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.1.AR.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.AR.1$b)), rep("2", length(MFP.1.AR.2$b)), rep("3", length(MFP.1.AR.3$b)), rep("4", length(MFP.1.AR.4$b)), rep("5", length(MFP.1.AR.5$b))), Estimate = c(MFP.1.AR.1$b, MFP.1.AR.2$b, MFP.1.AR.3$b, MFP.1.AR.4$b, MFP.1.AR.5$b))
MFP.1.AR.b <- ggplot(data = MFP.1.AR.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 200) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.1.AR.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.AR.1$e)), rep("2", length(MFP.1.AR.2$e)), rep("3", length(MFP.1.AR.3$e)), rep("4", length(MFP.1.AR.4$e)), rep("5", length(MFP.1.AR.5$e))), Estimate = c(MFP.1.AR.1$e, MFP.1.AR.2$e, MFP.1.AR.3$e, MFP.1.AR.4$e, MFP.1.AR.5$e))
MFP.1.AR.e <- ggplot(data = MFP.1.AR.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.9) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.1.AR.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.1.AR.1$delta)), rep("2", length(MFP.1.AR.2$delta)), rep("3", length(MFP.1.AR.3$delta)), rep("4", length(MFP.1.AR.4$delta)), rep("5", length(MFP.1.AR.5$delta))), Estimate = c(MFP.1.AR.1$delta, MFP.1.AR.2$delta, MFP.1.AR.3$delta, MFP.1.AR.4$delta, MFP.1.AR.5$delta))
MFP.1.AR.d <- ggplot(data = MFP.1.AR.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.1.AR <- plot_grid(MFP.1.AR.r, MFP.1.AR.B, MFP.1.AR.b, MFP.1.AR.e, MFP.1.AR.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type I FR, Autoregressive Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.1.AR, top = title, left = y.lab, bottom = x.lab))
```

## MFP (2010), Type II FR (DivOsc)

```{r}
# Global
MFP.2.DivOsc.Global.1 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.2 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.3 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.4 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.5 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, permuted = TRUE, include = TRUE)

MFP.2.DivOsc.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,1])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,1])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,1])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,1])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,1], MFP.2.DivOsc.Global.2$theta[ ,1], MFP.2.DivOsc.Global.3$theta[ ,1], MFP.2.DivOsc.Global.4$theta[ ,1], MFP.2.DivOsc.Global.5$theta[ ,1]))
MFP.2.DivOsc.G.r <- ggplot(data = MFP.2.DivOsc.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DivOsc.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,2])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,2])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,2])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,2])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,2], MFP.2.DivOsc.Global.2$theta[ ,2], MFP.2.DivOsc.Global.3$theta[ ,2], MFP.2.DivOsc.Global.4$theta[ ,2], MFP.2.DivOsc.Global.5$theta[ ,2]))
MFP.2.DivOsc.G.B <- ggplot(data = MFP.2.DivOsc.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,3])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,3])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,3])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,3])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,3], MFP.2.DivOsc.Global.2$theta[ ,3], MFP.2.DivOsc.Global.3$theta[ ,3], MFP.2.DivOsc.Global.4$theta[ ,3], MFP.2.DivOsc.Global.5$theta[ ,3]))
MFP.2.DivOsc.G.h <- ggplot(data = MFP.2.DivOsc.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,4])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,4])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,4])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,4])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,4], MFP.2.DivOsc.Global.2$theta[ ,4], MFP.2.DivOsc.Global.3$theta[ ,4], MFP.2.DivOsc.Global.4$theta[ ,4], MFP.2.DivOsc.Global.5$theta[ ,4]))
MFP.2.DivOsc.G.b <- ggplot(data = MFP.2.DivOsc.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,5])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,5])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,5])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,5])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,5]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,5], MFP.2.DivOsc.Global.2$theta[ ,5], MFP.2.DivOsc.Global.3$theta[ ,5], MFP.2.DivOsc.Global.4$theta[ ,5], MFP.2.DivOsc.Global.5$theta[ ,5]))
MFP.2.DivOsc.G.e <- ggplot(data = MFP.2.DivOsc.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,6])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,6])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,6])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,6])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,6]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,6], MFP.2.DivOsc.Global.2$theta[ ,6], MFP.2.DivOsc.Global.3$theta[ ,6], MFP.2.DivOsc.Global.4$theta[ ,6], MFP.2.DivOsc.Global.5$theta[ ,6]))
MFP.2.DivOsc.G.d <- ggplot(data = MFP.2.DivOsc.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.48) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DivOsc.Global <- plot_grid(MFP.2.DivOsc.G.r, MFP.2.DivOsc.G.B, MFP.2.DivOsc.G.h, MFP.2.DivOsc.G.b, MFP.2.DivOsc.G.e, MFP.2.DivOsc.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Divergent Oscillations), Global Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DivOsc.Global, top = title, left = y.lab, bottom = x.lab))

# Autoregressive
MFP.2.DivOsc.AR.1 <- rstan::extract(MFP.II.DivOsc.1.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.AR.2 <- rstan::extract(MFP.II.DivOsc.2.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.AR.3 <- rstan::extract(MFP.II.DivOsc.3.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.AR.4 <- rstan::extract(MFP.II.DivOsc.4.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.AR.5 <- rstan::extract(MFP.II.DivOsc.5.AR.Fit, permuted = TRUE, include = TRUE)

MFP.2.DivOsc.AR.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.AR.1$r)), rep("2", length(MFP.2.DivOsc.AR.2$r)), rep("3", length(MFP.2.DivOsc.AR.3$r)), rep("4", length(MFP.2.DivOsc.AR.4$r)), rep("5", length(MFP.2.DivOsc.AR.5$r))), Estimate = c(MFP.2.DivOsc.AR.1$r, MFP.2.DivOsc.AR.2$r, MFP.2.DivOsc.AR.3$r, MFP.2.DivOsc.AR.4$r, MFP.2.DivOsc.AR.5$r))
MFP.2.DivOsc.AR.r <- ggplot(data = MFP.2.DivOsc.AR.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DivOsc.AR.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.AR.1$B)), rep("2", length(MFP.2.DivOsc.AR.2$B)), rep("3", length(MFP.2.DivOsc.AR.3$B)), rep("4", length(MFP.2.DivOsc.AR.4$B)), rep("5", length(MFP.2.DivOsc.AR.5$B))), Estimate = c(MFP.2.DivOsc.AR.1$B, MFP.2.DivOsc.AR.2$B, MFP.2.DivOsc.AR.3$B, MFP.2.DivOsc.AR.4$B, MFP.2.DivOsc.AR.5$B))
MFP.2.DivOsc.AR.B <- ggplot(data = MFP.2.DivOsc.AR.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.AR.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.AR.1$h)), rep("2", length(MFP.2.DivOsc.AR.2$h)), rep("3", length(MFP.2.DivOsc.AR.3$h)), rep("4", length(MFP.2.DivOsc.AR.4$h)), rep("5", length(MFP.2.DivOsc.AR.5$h))), Estimate = c(MFP.2.DivOsc.AR.1$h, MFP.2.DivOsc.AR.2$h, MFP.2.DivOsc.AR.3$h, MFP.2.DivOsc.AR.4$h, MFP.2.DivOsc.AR.5$h))
MFP.2.DivOsc.AR.h <- ggplot(data = MFP.2.DivOsc.AR.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.AR.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.AR.1$b)), rep("2", length(MFP.2.DivOsc.AR.2$b)), rep("3", length(MFP.2.DivOsc.AR.3$b)), rep("4", length(MFP.2.DivOsc.AR.4$b)), rep("5", length(MFP.2.DivOsc.AR.5$b))), Estimate = c(MFP.2.DivOsc.AR.1$b, MFP.2.DivOsc.AR.2$b, MFP.2.DivOsc.AR.3$b, MFP.2.DivOsc.AR.4$b, MFP.2.DivOsc.AR.5$b))
MFP.2.DivOsc.AR.b <- ggplot(data = MFP.2.DivOsc.AR.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.AR.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.AR.1$e)), rep("2", length(MFP.2.DivOsc.AR.2$e)), rep("3", length(MFP.2.DivOsc.AR.3$e)), rep("4", length(MFP.2.DivOsc.AR.4$e)), rep("5", length(MFP.2.DivOsc.AR.5$e))), Estimate = c(MFP.2.DivOsc.AR.1$e, MFP.2.DivOsc.AR.2$e, MFP.2.DivOsc.AR.3$e, MFP.2.DivOsc.AR.4$e, MFP.2.DivOsc.AR.5$e))
MFP.2.DivOsc.AR.e <- ggplot(data = MFP.2.DivOsc.AR.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.AR.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.AR.1$d)), rep("2", length(MFP.2.DivOsc.AR.2$d)), rep("3", length(MFP.2.DivOsc.AR.3$d)), rep("4", length(MFP.2.DivOsc.AR.4$d)), rep("5", length(MFP.2.DivOsc.AR.5$d))), Estimate = c(MFP.2.DivOsc.AR.1$d, MFP.2.DivOsc.AR.2$d, MFP.2.DivOsc.AR.3$d, MFP.2.DivOsc.AR.4$d, MFP.2.DivOsc.AR.5$d))
MFP.2.DivOsc.AR.d <- ggplot(data = MFP.2.DivOsc.AR.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.41) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DivOsc.AR <- plot_grid(MFP.2.DivOsc.AR.r, MFP.2.DivOsc.AR.B, MFP.2.DivOsc.AR.h, MFP.2.DivOsc.AR.b, MFP.2.DivOsc.AR.e, MFP.2.DivOsc.AR.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Divergent Oscillations), Autoregressive Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DivOsc.AR, top = title, left = y.lab, bottom = x.lab))
```

## MFP (2010), Type II FR (SLC)

```{r}
# Global
MFP.2.SLC.Global.1 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj1, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.2 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj2, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.3 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj3, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.4 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj4, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.5 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj5, permuted = TRUE, include = TRUE)

MFP.2.SLC.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,1])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,1])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,1])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,1])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,1]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,1], MFP.2.SLC.Global.2$theta[ ,1], MFP.2.SLC.Global.3$theta[ ,1], MFP.2.SLC.Global.4$theta[ ,1], MFP.2.SLC.Global.5$theta[ ,1]))
MFP.2.SLC.G.r <- ggplot(data = MFP.2.SLC.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.SLC.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,2])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,2])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,2])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,2])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,2]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,2], MFP.2.SLC.Global.2$theta[ ,2], MFP.2.SLC.Global.3$theta[ ,2], MFP.2.SLC.Global.4$theta[ ,2], MFP.2.SLC.Global.5$theta[ ,2]))
MFP.2.SLC.G.B <- ggplot(data = MFP.2.SLC.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,3])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,3])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,3])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,3])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,3]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,3], MFP.2.SLC.Global.2$theta[ ,3], MFP.2.SLC.Global.3$theta[ ,3], MFP.2.SLC.Global.4$theta[ ,3], MFP.2.SLC.Global.5$theta[ ,3]))
MFP.2.SLC.G.h <- ggplot(data = MFP.2.SLC.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,4])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,4])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,4])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,4])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,4]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,4], MFP.2.SLC.Global.2$theta[ ,4], MFP.2.SLC.Global.3$theta[ ,4], MFP.2.SLC.Global.4$theta[ ,4], MFP.2.SLC.Global.5$theta[ ,4]))
MFP.2.SLC.G.b <- ggplot(data = MFP.2.SLC.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,5])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,5])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,5])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,5])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,5]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,5], MFP.2.SLC.Global.2$theta[ ,5], MFP.2.SLC.Global.3$theta[ ,5], MFP.2.SLC.Global.4$theta[ ,5], MFP.2.SLC.Global.5$theta[ ,5]))
MFP.2.SLC.G.e <- ggplot(data = MFP.2.SLC.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,6])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,6])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,6])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,6])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,6]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,6], MFP.2.SLC.Global.2$theta[ ,6], MFP.2.SLC.Global.3$theta[ ,6], MFP.2.SLC.Global.4$theta[ ,6], MFP.2.SLC.Global.5$theta[ ,6]))
MFP.2.SLC.G.d <- ggplot(data = MFP.2.SLC.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.41) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.SLC.Global <- plot_grid(MFP.2.SLC.G.r, MFP.2.SLC.G.B, MFP.2.SLC.G.h, MFP.2.SLC.G.b, MFP.2.SLC.G.e, MFP.2.SLC.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Divergent Oscillations), Global Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.SLC.Global, top = title, left = y.lab, bottom = x.lab))

# Autoregressive
MFP.2.SLC.AR.1 <- rstan::extract(MFP.II.SLC.1.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.SLC.AR.2 <- rstan::extract(MFP.II.SLC.2.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.SLC.AR.3 <- rstan::extract(MFP.II.SLC.3.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.SLC.AR.4 <- rstan::extract(MFP.II.SLC.4.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.SLC.AR.5 <- rstan::extract(MFP.II.SLC.5.AR.Fit, permuted = TRUE, include = TRUE)

MFP.2.SLC.AR.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.AR.1$r)), rep("2", length(MFP.2.SLC.AR.2$r)), rep("3", length(MFP.2.SLC.AR.3$r)), rep("4", length(MFP.2.SLC.AR.4$r)), rep("5", length(MFP.2.SLC.AR.5$r))), Estimate = c(MFP.2.SLC.AR.1$r, MFP.2.SLC.AR.2$r, MFP.2.SLC.AR.3$r, MFP.2.SLC.AR.4$r, MFP.2.SLC.AR.5$r))
MFP.2.SLC.AR.r <- ggplot(data = MFP.2.SLC.AR.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.SLC.AR.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.AR.1$B)), rep("2", length(MFP.2.SLC.AR.2$B)), rep("3", length(MFP.2.SLC.AR.3$B)), rep("4", length(MFP.2.SLC.AR.4$B)), rep("5", length(MFP.2.SLC.AR.5$B))), Estimate = c(MFP.2.SLC.AR.1$B, MFP.2.SLC.AR.2$B, MFP.2.SLC.AR.3$B, MFP.2.SLC.AR.4$B, MFP.2.SLC.AR.5$B))
MFP.2.SLC.AR.B <- ggplot(data = MFP.2.SLC.AR.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.AR.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.AR.1$h)), rep("2", length(MFP.2.SLC.AR.2$h)), rep("3", length(MFP.2.SLC.AR.3$h)), rep("4", length(MFP.2.SLC.AR.4$h)), rep("5", length(MFP.2.SLC.AR.5$h))), Estimate = c(MFP.2.SLC.AR.1$h, MFP.2.SLC.AR.2$h, MFP.2.SLC.AR.3$h, MFP.2.SLC.AR.4$h, MFP.2.SLC.AR.5$h))
MFP.2.SLC.AR.h <- ggplot(data = MFP.2.SLC.AR.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.AR.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.AR.1$b)), rep("2", length(MFP.2.SLC.AR.2$b)), rep("3", length(MFP.2.SLC.AR.3$b)), rep("4", length(MFP.2.SLC.AR.4$b)), rep("5", length(MFP.2.SLC.AR.5$b))), Estimate = c(MFP.2.SLC.AR.1$b, MFP.2.SLC.AR.2$b, MFP.2.SLC.AR.3$b, MFP.2.SLC.AR.4$b, MFP.2.SLC.AR.5$b))
MFP.2.SLC.AR.b <- ggplot(data = MFP.2.SLC.AR.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.AR.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.AR.1$e)), rep("2", length(MFP.2.SLC.AR.2$e)), rep("3", length(MFP.2.SLC.AR.3$e)), rep("4", length(MFP.2.SLC.AR.4$e)), rep("5", length(MFP.2.SLC.AR.5$e))), Estimate = c(MFP.2.SLC.AR.1$e, MFP.2.SLC.AR.2$e, MFP.2.SLC.AR.3$e, MFP.2.SLC.AR.4$e, MFP.2.SLC.AR.5$e))
MFP.2.SLC.AR.e <- ggplot(data = MFP.2.SLC.AR.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.AR.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.AR.1$d)), rep("2", length(MFP.2.SLC.AR.2$d)), rep("3", length(MFP.2.SLC.AR.3$d)), rep("4", length(MFP.2.SLC.AR.4$d)), rep("5", length(MFP.2.SLC.AR.5$d))), Estimate = c(MFP.2.SLC.AR.1$d, MFP.2.SLC.AR.2$d, MFP.2.SLC.AR.3$d, MFP.2.SLC.AR.4$d, MFP.2.SLC.AR.5$d))
MFP.2.SLC.AR.d <- ggplot(data = MFP.2.SLC.AR.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.34) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.SLC.AR <- plot_grid(MFP.2.SLC.AR.r, MFP.2.SLC.AR.B, MFP.2.SLC.AR.h, MFP.2.SLC.AR.b, MFP.2.SLC.AR.e, MFP.2.SLC.AR.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Stable Limit Cycle), Autoregressive Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.SLC.AR, top = title, left = y.lab, bottom = x.lab))
```

## MFP (2010), Type II FR (DO)

```{r}
# Global
MFP.2.DO.Global.1 <- rstan::extract(ModFentonPerkins_2_DO_FitObj1, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.2 <- rstan::extract(ModFentonPerkins_2_DO_FitObj2, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.3 <- rstan::extract(ModFentonPerkins_2_DO_FitObj3, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.4 <- rstan::extract(ModFentonPerkins_2_DO_FitObj4, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.5 <- rstan::extract(ModFentonPerkins_2_DO_FitObj5, permuted = TRUE, include = TRUE)

MFP.2.DO.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,1])), rep("2", length(MFP.2.DO.Global.2$theta[ ,1])), rep("3", length(MFP.2.DO.Global.3$theta[ ,1])), rep("4", length(MFP.2.DO.Global.4$theta[ ,1])), rep("5", length(MFP.2.DO.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,1], MFP.2.DO.Global.2$theta[ ,1], MFP.2.DO.Global.3$theta[ ,1], MFP.2.DO.Global.4$theta[ ,1], MFP.2.DO.Global.5$theta[ ,1]))
MFP.2.DO.G.r <- ggplot(data = MFP.2.DO.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DO.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,2])), rep("2", length(MFP.2.DO.Global.2$theta[ ,2])), rep("3", length(MFP.2.DO.Global.3$theta[ ,2])), rep("4", length(MFP.2.DO.Global.4$theta[ ,2])), rep("5", length(MFP.2.DO.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,2], MFP.2.DO.Global.2$theta[ ,2], MFP.2.DO.Global.3$theta[ ,2], MFP.2.DO.Global.4$theta[ ,2], MFP.2.DO.Global.5$theta[ ,2]))
MFP.2.DO.G.B <- ggplot(data = MFP.2.DO.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.008) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,3])), rep("2", length(MFP.2.DO.Global.2$theta[ ,3])), rep("3", length(MFP.2.DO.Global.3$theta[ ,3])), rep("4", length(MFP.2.DO.Global.4$theta[ ,3])), rep("5", length(MFP.2.DO.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,3], MFP.2.DO.Global.2$theta[ ,3], MFP.2.DO.Global.3$theta[ ,3], MFP.2.DO.Global.4$theta[ ,3], MFP.2.DO.Global.5$theta[ ,3]))
MFP.2.DO.G.h <- ggplot(data = MFP.2.DO.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.06) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,4])), rep("2", length(MFP.2.DO.Global.2$theta[ ,4])), rep("3", length(MFP.2.DO.Global.3$theta[ ,4])), rep("4", length(MFP.2.DO.Global.4$theta[ ,4])), rep("5", length(MFP.2.DO.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,4], MFP.2.DO.Global.2$theta[ ,4], MFP.2.DO.Global.3$theta[ ,4], MFP.2.DO.Global.4$theta[ ,4], MFP.2.DO.Global.5$theta[ ,4]))
MFP.2.DO.G.b <- ggplot(data = MFP.2.DO.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,5])), rep("2", length(MFP.2.DO.Global.2$theta[ ,5])), rep("3", length(MFP.2.DO.Global.3$theta[ ,5])), rep("4", length(MFP.2.DO.Global.4$theta[ ,5])), rep("5", length(MFP.2.DO.Global.5$theta[ ,5]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,5], MFP.2.DO.Global.2$theta[ ,5], MFP.2.DO.Global.3$theta[ ,5], MFP.2.DO.Global.4$theta[ ,5], MFP.2.DO.Global.5$theta[ ,5]))
MFP.2.DO.G.e <- ggplot(data = MFP.2.DO.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,6])), rep("2", length(MFP.2.DO.Global.2$theta[ ,6])), rep("3", length(MFP.2.DO.Global.3$theta[ ,6])), rep("4", length(MFP.2.DO.Global.4$theta[ ,6])), rep("5", length(MFP.2.DO.Global.5$theta[ ,6]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,6], MFP.2.DO.Global.2$theta[ ,6], MFP.2.DO.Global.3$theta[ ,6], MFP.2.DO.Global.4$theta[ ,6], MFP.2.DO.Global.5$theta[ ,6]))
MFP.2.DO.G.d <- ggplot(data = MFP.2.DO.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.34) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DO.Global <- plot_grid(MFP.2.DO.G.r, MFP.2.DO.G.B, MFP.2.DO.G.h, MFP.2.DO.G.b, MFP.2.DO.G.e, MFP.2.DO.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Damping Oscillations), Global Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DO.Global, top = title, left = y.lab, bottom = x.lab))

# Autoregressive
MFP.2.DO.AR.1 <- rstan::extract(MFP.II.DampOsc.1.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DO.AR.2 <- rstan::extract(MFP.II.DampOsc.2.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DO.AR.3 <- rstan::extract(MFP.II.DampOsc.3.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DO.AR.4 <- rstan::extract(MFP.II.DampOsc.4.AR.Fit, permuted = TRUE, include = TRUE)
MFP.2.DO.AR.5 <- rstan::extract(MFP.II.DampOsc.5.AR.Fit, permuted = TRUE, include = TRUE)

MFP.2.DO.AR.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.AR.1$r)), rep("2", length(MFP.2.DO.AR.2$r)), rep("3", length(MFP.2.DO.AR.3$r)), rep("4", length(MFP.2.DO.AR.4$r)), rep("5", length(MFP.2.DO.AR.5$r))), Estimate = c(MFP.2.DO.AR.1$r, MFP.2.DO.AR.2$r, MFP.2.DO.AR.3$r, MFP.2.DO.AR.4$r, MFP.2.DO.AR.5$r))
MFP.2.DO.AR.r <- ggplot(data = MFP.2.DO.AR.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.1) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DO.AR.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.AR.1$B)), rep("2", length(MFP.2.DO.AR.2$B)), rep("3", length(MFP.2.DO.AR.3$B)), rep("4", length(MFP.2.DO.AR.4$B)), rep("5", length(MFP.2.DO.AR.5$B))), Estimate = c(MFP.2.DO.AR.1$B, MFP.2.DO.AR.2$B, MFP.2.DO.AR.3$B, MFP.2.DO.AR.4$B, MFP.2.DO.AR.5$B))
MFP.2.DO.AR.B <- ggplot(data = MFP.2.DO.AR.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.AR.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.AR.1$h)), rep("2", length(MFP.2.DO.AR.2$h)), rep("3", length(MFP.2.DO.AR.3$h)), rep("4", length(MFP.2.DO.AR.4$h)), rep("5", length(MFP.2.DO.AR.5$h))), Estimate = c(MFP.2.DO.AR.1$h, MFP.2.DO.AR.2$h, MFP.2.DO.AR.3$h, MFP.2.DO.AR.4$h, MFP.2.DO.AR.5$h))
MFP.2.DO.AR.h <- ggplot(data = MFP.2.DO.AR.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.AR.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.AR.1$b)), rep("2", length(MFP.2.DO.AR.2$b)), rep("3", length(MFP.2.DO.AR.3$b)), rep("4", length(MFP.2.DO.AR.4$b)), rep("5", length(MFP.2.DO.AR.5$b))), Estimate = c(MFP.2.DO.AR.1$b, MFP.2.DO.AR.2$b, MFP.2.DO.AR.3$b, MFP.2.DO.AR.4$b, MFP.2.DO.AR.5$b))
MFP.2.DO.AR.b <- ggplot(data = MFP.2.DO.AR.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.AR.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.AR.1$e)), rep("2", length(MFP.2.DO.AR.2$e)), rep("3", length(MFP.2.DO.AR.3$e)), rep("4", length(MFP.2.DO.AR.4$e)), rep("5", length(MFP.2.DO.AR.5$e))), Estimate = c(MFP.2.DO.AR.1$e, MFP.2.DO.AR.2$e, MFP.2.DO.AR.3$e, MFP.2.DO.AR.4$e, MFP.2.DO.AR.5$e))
MFP.2.DO.AR.e <- ggplot(data = MFP.2.DO.AR.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.AR.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.AR.1$d)), rep("2", length(MFP.2.DO.AR.2$d)), rep("3", length(MFP.2.DO.AR.3$d)), rep("4", length(MFP.2.DO.AR.4$d)), rep("5", length(MFP.2.DO.AR.5$d))), Estimate = c(MFP.2.DO.AR.1$d, MFP.2.DO.AR.2$d, MFP.2.DO.AR.3$d, MFP.2.DO.AR.4$d, MFP.2.DO.AR.5$d))
MFP.2.DO.AR.d <- ggplot(data = MFP.2.DO.AR.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.34) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DO.AR <- plot_grid(MFP.2.DO.AR.r, MFP.2.DO.AR.B, MFP.2.DO.AR.h, MFP.2.DO.AR.b, MFP.2.DO.AR.e, MFP.2.DO.AR.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Damping Oscillations), Autoregressive Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DO.AR, top = title, left = y.lab, bottom = x.lab))
```

## MFP (2010), Type III FR

```{r}
# Global
MFP.3.Global.1 <- rstan::extract(ModFentonPerkins_3_FitObj1, permuted = TRUE, include = TRUE)
MFP.3.Global.2 <- rstan::extract(ModFentonPerkins_3_FitObj2, permuted = TRUE, include = TRUE)
MFP.3.Global.3 <- rstan::extract(ModFentonPerkins_3_FitObj3, permuted = TRUE, include = TRUE)
MFP.3.Global.4 <- rstan::extract(ModFentonPerkins_3_FitObj4, permuted = TRUE, include = TRUE)
MFP.3.Global.5 <- rstan::extract(ModFentonPerkins_3_FitObj5, permuted = TRUE, include = TRUE)

MFP.3.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.Global.1$theta[ ,1])), rep("2", length(MFP.3.Global.2$theta[ ,1])), rep("3", length(MFP.3.Global.3$theta[ ,1])), rep("4", length(MFP.3.Global.4$theta[ ,1])), rep("5", length(MFP.3.Global.5$theta[ ,1]))), Estimate = c(MFP.3.Global.1$theta[ ,1], MFP.3.Global.2$theta[ ,1], MFP.3.Global.3$theta[ ,1], MFP.3.Global.4$theta[ ,1], MFP.3.Global.5$theta[ ,1]))
MFP.3.G.r <- ggplot(data = MFP.3.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.3.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.Global.1$theta[ ,2])), rep("2", length(MFP.3.Global.2$theta[ ,2])), rep("3", length(MFP.3.Global.3$theta[ ,2])), rep("4", length(MFP.3.Global.4$theta[ ,2])), rep("5", length(MFP.3.Global.5$theta[ ,2]))), Estimate = c(MFP.3.Global.1$theta[ ,2], MFP.3.Global.2$theta[ ,2], MFP.3.Global.3$theta[ ,2], MFP.3.Global.4$theta[ ,2], MFP.3.Global.5$theta[ ,2]))
MFP.3.G.B <- ggplot(data = MFP.3.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.0015) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.Global.1$theta[ ,3])), rep("2", length(MFP.3.Global.2$theta[ ,3])), rep("3", length(MFP.3.Global.3$theta[ ,3])), rep("4", length(MFP.3.Global.4$theta[ ,3])), rep("5", length(MFP.3.Global.5$theta[ ,3]))), Estimate = c(MFP.3.Global.1$theta[ ,3], MFP.3.Global.2$theta[ ,3], MFP.3.Global.3$theta[ ,3], MFP.3.Global.4$theta[ ,3], MFP.3.Global.5$theta[ ,3]))
MFP.3.G.h <- ggplot(data = MFP.3.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.Global.1$theta[ ,4])), rep("2", length(MFP.3.Global.2$theta[ ,4])), rep("3", length(MFP.3.Global.3$theta[ ,4])), rep("4", length(MFP.3.Global.4$theta[ ,4])), rep("5", length(MFP.3.Global.5$theta[ ,4]))), Estimate = c(MFP.3.Global.1$theta[ ,4], MFP.3.Global.2$theta[ ,4], MFP.3.Global.3$theta[ ,4], MFP.3.Global.4$theta[ ,4], MFP.3.Global.5$theta[ ,4]))
MFP.3.G.b <- ggplot(data = MFP.3.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.Global.1$theta[ ,5])), rep("2", length(MFP.3.Global.2$theta[ ,5])), rep("3", length(MFP.3.Global.3$theta[ ,5])), rep("4", length(MFP.3.Global.4$theta[ ,5])), rep("5", length(MFP.3.Global.5$theta[ ,5]))), Estimate = c(MFP.3.Global.1$theta[ ,5], MFP.3.Global.2$theta[ ,5], MFP.3.Global.3$theta[ ,5], MFP.3.Global.4$theta[ ,5], MFP.3.Global.5$theta[ ,5]))
MFP.3.G.e <- ggplot(data = MFP.3.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.Global.1$theta[ ,6])), rep("2", length(MFP.3.Global.2$theta[ ,6])), rep("3", length(MFP.3.Global.3$theta[ ,6])), rep("4", length(MFP.3.Global.4$theta[ ,6])), rep("5", length(MFP.3.Global.5$theta[ ,6]))), Estimate = c(MFP.3.Global.1$theta[ ,6], MFP.3.Global.2$theta[ ,6], MFP.3.Global.3$theta[ ,6], MFP.3.Global.4$theta[ ,6], MFP.3.Global.5$theta[ ,6]))
MFP.3.G.d <- ggplot(data = MFP.3.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.3.Global <- plot_grid(MFP.3.G.r, MFP.3.G.B, MFP.3.G.h, MFP.3.G.b, MFP.3.G.e, MFP.3.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type III FR, Global Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.3.Global, top = title, left = y.lab, bottom = x.lab))

# Autoregressive
MFP.3.AR.1 <- rstan::extract(MFP.III.1.AR.Fit, permuted = TRUE, include = TRUE)
MFP.3.AR.2 <- rstan::extract(MFP.III.2.AR.Fit, permuted = TRUE, include = TRUE)
MFP.3.AR.3 <- rstan::extract(MFP.III.3.AR.Fit, permuted = TRUE, include = TRUE)
MFP.3.AR.4 <- rstan::extract(MFP.III.4.AR.Fit, permuted = TRUE, include = TRUE)
MFP.3.AR.5 <- rstan::extract(MFP.III.5.AR.Fit, permuted = TRUE, include = TRUE)

MFP.3.AR.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.AR.1$r)), rep("2", length(MFP.3.AR.2$r)), rep("3", length(MFP.3.AR.3$r)), rep("4", length(MFP.3.AR.4$r)), rep("5", length(MFP.3.AR.5$r))), Estimate = c(MFP.3.AR.1$r, MFP.3.AR.2$r, MFP.3.AR.3$r, MFP.3.AR.4$r, MFP.3.AR.5$r))
MFP.3.AR.r <- ggplot(data = MFP.3.AR.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.3.AR.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.AR.1$B)), rep("2", length(MFP.3.AR.2$B)), rep("3", length(MFP.3.AR.3$B)), rep("4", length(MFP.3.AR.4$B)), rep("5", length(MFP.3.AR.5$B))), Estimate = c(MFP.3.AR.1$B, MFP.3.AR.2$B, MFP.3.AR.3$B, MFP.3.AR.4$B, MFP.3.AR.5$B))
MFP.3.AR.B <- ggplot(data = MFP.3.AR.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.0015) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.AR.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.AR.1$h)), rep("2", length(MFP.3.AR.2$h)), rep("3", length(MFP.3.AR.3$h)), rep("4", length(MFP.3.AR.4$h)), rep("5", length(MFP.3.AR.5$h))), Estimate = c(MFP.3.AR.1$h, MFP.3.AR.2$h, MFP.3.AR.3$h, MFP.3.AR.4$h, MFP.3.AR.5$h))
MFP.3.AR.h <- ggplot(data = MFP.3.AR.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.AR.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.AR.1$b)), rep("2", length(MFP.3.AR.2$b)), rep("3", length(MFP.3.AR.3$b)), rep("4", length(MFP.3.AR.4$b)), rep("5", length(MFP.3.AR.5$b))), Estimate = c(MFP.3.AR.1$b, MFP.3.AR.2$b, MFP.3.AR.3$b, MFP.3.AR.4$b, MFP.3.AR.5$b))
MFP.3.AR.b <- ggplot(data = MFP.3.AR.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.AR.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.AR.1$e)), rep("2", length(MFP.3.AR.2$e)), rep("3", length(MFP.3.AR.3$e)), rep("4", length(MFP.3.AR.4$e)), rep("5", length(MFP.3.AR.5$e))), Estimate = c(MFP.3.AR.1$e, MFP.3.AR.2$e, MFP.3.AR.3$e, MFP.3.AR.4$e, MFP.3.AR.5$e))
MFP.3.AR.e <- ggplot(data = MFP.3.AR.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.3.AR.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.3.AR.1$d)), rep("2", length(MFP.3.AR.2$d)), rep("3", length(MFP.3.AR.3$d)), rep("4", length(MFP.3.AR.4$d)), rep("5", length(MFP.3.AR.5$d))), Estimate = c(MFP.3.AR.1$d, MFP.3.AR.2$d, MFP.3.AR.3$d, MFP.3.AR.4$d, MFP.3.AR.5$d))
MFP.3.AR.d <- ggplot(data = MFP.3.AR.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.3.AR <- plot_grid(MFP.3.AR.r, MFP.3.AR.B, MFP.3.AR.h, MFP.3.AR.b, MFP.3.AR.e, MFP.3.AR.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type III FR, Autoregressive Model Parameter Estimates")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.3.AR, top = title, left = y.lab, bottom = x.lab))
```

## Fewer Parameter Estimates

### MFP, Type II, DivOsc

```{r}
# Five Parms, Give B
MFP.2.DivOsc.Global.1 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.2 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.3 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.4 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.5 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)

MFP.2.DivOsc.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,1])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,1])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,1])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,1])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,1], MFP.2.DivOsc.Global.2$theta[ ,1], MFP.2.DivOsc.Global.3$theta[ ,1], MFP.2.DivOsc.Global.4$theta[ ,1], MFP.2.DivOsc.Global.5$theta[ ,1]))
MFP.2.DivOsc.G.r <- ggplot(data = MFP.2.DivOsc.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DivOsc.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,2])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,2])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,2])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,2])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,2], MFP.2.DivOsc.Global.2$theta[ ,2], MFP.2.DivOsc.Global.3$theta[ ,2], MFP.2.DivOsc.Global.4$theta[ ,2], MFP.2.DivOsc.Global.5$theta[ ,2]))
MFP.2.DivOsc.G.h <- ggplot(data = MFP.2.DivOsc.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,3])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,3])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,3])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,3])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,3], MFP.2.DivOsc.Global.2$theta[ ,3], MFP.2.DivOsc.Global.3$theta[ ,3], MFP.2.DivOsc.Global.4$theta[ ,3], MFP.2.DivOsc.Global.5$theta[ ,3]))
MFP.2.DivOsc.G.b <- ggplot(data = MFP.2.DivOsc.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,4])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,4])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,4])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,4])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,4], MFP.2.DivOsc.Global.2$theta[ ,4], MFP.2.DivOsc.Global.3$theta[ ,4], MFP.2.DivOsc.Global.4$theta[ ,4], MFP.2.DivOsc.Global.5$theta[ ,4]))
MFP.2.DivOsc.G.e <- ggplot(data = MFP.2.DivOsc.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,5])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,5])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,5])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,5])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,5]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,5], MFP.2.DivOsc.Global.2$theta[ ,5], MFP.2.DivOsc.Global.3$theta[ ,5], MFP.2.DivOsc.Global.4$theta[ ,5], MFP.2.DivOsc.Global.5$theta[ ,5]))
MFP.2.DivOsc.G.d <- ggplot(data = MFP.2.DivOsc.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.48) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DivOsc.Global <- plot_grid(MFP.2.DivOsc.G.r, MFP.2.DivOsc.G.h, MFP.2.DivOsc.G.b, MFP.2.DivOsc.G.e, MFP.2.DivOsc.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Divergent Oscillations), Global Model Parameter Estimates (Provide True Value of β)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DivOsc.Global, top = title, left = y.lab, bottom = x.lab))

# Five Parms, Give h
MFP.2.DivOsc.Global.1 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.2 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.3 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.4 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.5 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)

MFP.2.DivOsc.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,1])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,1])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,1])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,1])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,1], MFP.2.DivOsc.Global.2$theta[ ,1], MFP.2.DivOsc.Global.3$theta[ ,1], MFP.2.DivOsc.Global.4$theta[ ,1], MFP.2.DivOsc.Global.5$theta[ ,1]))
MFP.2.DivOsc.G.r <- ggplot(data = MFP.2.DivOsc.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DivOsc.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,2])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,2])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,2])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,2])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,2], MFP.2.DivOsc.Global.2$theta[ ,2], MFP.2.DivOsc.Global.3$theta[ ,2], MFP.2.DivOsc.Global.4$theta[ ,2], MFP.2.DivOsc.Global.5$theta[ ,2]))
MFP.2.DivOsc.G.B <- ggplot(data = MFP.2.DivOsc.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,3])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,3])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,3])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,3])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,3], MFP.2.DivOsc.Global.2$theta[ ,3], MFP.2.DivOsc.Global.3$theta[ ,3], MFP.2.DivOsc.Global.4$theta[ ,3], MFP.2.DivOsc.Global.5$theta[ ,3]))
MFP.2.DivOsc.G.b <- ggplot(data = MFP.2.DivOsc.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,4])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,4])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,4])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,4])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,4], MFP.2.DivOsc.Global.2$theta[ ,4], MFP.2.DivOsc.Global.3$theta[ ,4], MFP.2.DivOsc.Global.4$theta[ ,4], MFP.2.DivOsc.Global.5$theta[ ,4]))
MFP.2.DivOsc.G.e <- ggplot(data = MFP.2.DivOsc.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,5])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,5])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,5])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,5])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,5]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,5], MFP.2.DivOsc.Global.2$theta[ ,5], MFP.2.DivOsc.Global.3$theta[ ,5], MFP.2.DivOsc.Global.4$theta[ ,5], MFP.2.DivOsc.Global.5$theta[ ,5]))
MFP.2.DivOsc.G.d <- ggplot(data = MFP.2.DivOsc.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.48) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DivOsc.Global <- plot_grid(MFP.2.DivOsc.G.r, MFP.2.DivOsc.G.B, MFP.2.DivOsc.G.b, MFP.2.DivOsc.G.e, MFP.2.DivOsc.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Divergent Oscillations), Global Model Parameter Estimates (Provide True Value of h)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DivOsc.Global, top = title, left = y.lab, bottom = x.lab))

# Four Parms
MFP.2.DivOsc.Global.1 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.2 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.3 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.4 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
MFP.2.DivOsc.Global.5 <- rstan::extract(ModFentonPerkins_2_DivOsc_FitObj_FourParms_5, permuted = TRUE, include = TRUE)

MFP.2.DivOsc.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,1])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,1])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,1])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,1])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,1], MFP.2.DivOsc.Global.2$theta[ ,1], MFP.2.DivOsc.Global.3$theta[ ,1], MFP.2.DivOsc.Global.4$theta[ ,1], MFP.2.DivOsc.Global.5$theta[ ,1]))
MFP.2.DivOsc.G.r <- ggplot(data = MFP.2.DivOsc.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DivOsc.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,2])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,2])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,2])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,2])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,2], MFP.2.DivOsc.Global.2$theta[ ,2], MFP.2.DivOsc.Global.3$theta[ ,2], MFP.2.DivOsc.Global.4$theta[ ,2], MFP.2.DivOsc.Global.5$theta[ ,2]))
MFP.2.DivOsc.G.b <- ggplot(data = MFP.2.DivOsc.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,3])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,3])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,3])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,3])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,3], MFP.2.DivOsc.Global.2$theta[ ,3], MFP.2.DivOsc.Global.3$theta[ ,3], MFP.2.DivOsc.Global.4$theta[ ,3], MFP.2.DivOsc.Global.5$theta[ ,3]))
MFP.2.DivOsc.G.e <- ggplot(data = MFP.2.DivOsc.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DivOsc.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DivOsc.Global.1$theta[ ,4])), rep("2", length(MFP.2.DivOsc.Global.2$theta[ ,4])), rep("3", length(MFP.2.DivOsc.Global.3$theta[ ,4])), rep("4", length(MFP.2.DivOsc.Global.4$theta[ ,4])), rep("5", length(MFP.2.DivOsc.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DivOsc.Global.1$theta[ ,4], MFP.2.DivOsc.Global.2$theta[ ,4], MFP.2.DivOsc.Global.3$theta[ ,4], MFP.2.DivOsc.Global.4$theta[ ,4], MFP.2.DivOsc.Global.5$theta[ ,4]))
MFP.2.DivOsc.G.d <- ggplot(data = MFP.2.DivOsc.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.48) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DivOsc.Global <- plot_grid(MFP.2.DivOsc.G.r, MFP.2.DivOsc.G.b, MFP.2.DivOsc.G.e, MFP.2.DivOsc.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Divergent Oscillations), Global Model Parameter Estimates (Provide True Values of β and h)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DivOsc.Global, top = title, left = y.lab, bottom = x.lab))
```

### MFP, Type II, SLC

```{r}
# Five Parms, Give B
MFP.2.SLC.Global.1 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.2 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.3 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.4 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.5 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)

MFP.2.SLC.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,1])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,1])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,1])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,1])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,1]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,1], MFP.2.SLC.Global.2$theta[ ,1], MFP.2.SLC.Global.3$theta[ ,1], MFP.2.SLC.Global.4$theta[ ,1], MFP.2.SLC.Global.5$theta[ ,1]))
MFP.2.SLC.G.r <- ggplot(data = MFP.2.SLC.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.SLC.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,2])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,2])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,2])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,2])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,2]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,2], MFP.2.SLC.Global.2$theta[ ,2], MFP.2.SLC.Global.3$theta[ ,2], MFP.2.SLC.Global.4$theta[ ,2], MFP.2.SLC.Global.5$theta[ ,2]))
MFP.2.SLC.G.h <- ggplot(data = MFP.2.SLC.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.075) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,3])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,3])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,3])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,3])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,3]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,3], MFP.2.SLC.Global.2$theta[ ,3], MFP.2.SLC.Global.3$theta[ ,3], MFP.2.SLC.Global.4$theta[ ,3], MFP.2.SLC.Global.5$theta[ ,3]))
MFP.2.SLC.G.b <- ggplot(data = MFP.2.SLC.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,4])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,4])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,4])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,4])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,4]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,4], MFP.2.SLC.Global.2$theta[ ,4], MFP.2.SLC.Global.3$theta[ ,4], MFP.2.SLC.Global.4$theta[ ,4], MFP.2.SLC.Global.5$theta[ ,4]))
MFP.2.SLC.G.e <- ggplot(data = MFP.2.SLC.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,5])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,5])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,5])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,5])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,5]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,5], MFP.2.SLC.Global.2$theta[ ,5], MFP.2.SLC.Global.3$theta[ ,5], MFP.2.SLC.Global.4$theta[ ,5], MFP.2.SLC.Global.5$theta[ ,5]))
MFP.2.SLC.G.d <- ggplot(data = MFP.2.SLC.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.41) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.SLC.Global <- plot_grid(MFP.2.SLC.G.r, MFP.2.SLC.G.h, MFP.2.SLC.G.b, MFP.2.SLC.G.e, MFP.2.SLC.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Stable Limit Cycle), Global Model Parameter Estimates (Provide True Value of β)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.SLC.Global, top = title, left = y.lab, bottom = x.lab))

# Five Parms, Give h
MFP.2.SLC.Global.1 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.2 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.3 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.4 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.5 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)

MFP.2.SLC.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,1])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,1])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,1])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,1])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,1]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,1], MFP.2.SLC.Global.2$theta[ ,1], MFP.2.SLC.Global.3$theta[ ,1], MFP.2.SLC.Global.4$theta[ ,1], MFP.2.SLC.Global.5$theta[ ,1]))
MFP.2.SLC.G.r <- ggplot(data = MFP.2.SLC.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.SLC.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,2])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,2])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,2])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,2])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,2]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,2], MFP.2.SLC.Global.2$theta[ ,2], MFP.2.SLC.Global.3$theta[ ,2], MFP.2.SLC.Global.4$theta[ ,2], MFP.2.SLC.Global.5$theta[ ,2]))
MFP.2.SLC.G.B <- ggplot(data = MFP.2.SLC.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.012) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,3])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,3])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,3])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,3])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,3]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,3], MFP.2.SLC.Global.2$theta[ ,3], MFP.2.SLC.Global.3$theta[ ,3], MFP.2.SLC.Global.4$theta[ ,3], MFP.2.SLC.Global.5$theta[ ,3]))
MFP.2.SLC.G.b <- ggplot(data = MFP.2.SLC.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,4])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,4])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,4])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,4])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,4]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,4], MFP.2.SLC.Global.2$theta[ ,4], MFP.2.SLC.Global.3$theta[ ,4], MFP.2.SLC.Global.4$theta[ ,4], MFP.2.SLC.Global.5$theta[ ,4]))
MFP.2.SLC.G.e <- ggplot(data = MFP.2.SLC.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,5])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,5])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,5])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,5])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,5]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,5], MFP.2.SLC.Global.2$theta[ ,5], MFP.2.SLC.Global.3$theta[ ,5], MFP.2.SLC.Global.4$theta[ ,5], MFP.2.SLC.Global.5$theta[ ,5]))
MFP.2.SLC.G.d <- ggplot(data = MFP.2.SLC.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.41) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.SLC.Global <- plot_grid(MFP.2.SLC.G.r, MFP.2.SLC.G.B, MFP.2.SLC.G.b, MFP.2.SLC.G.e, MFP.2.SLC.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Stable Limit Cycle), Global Model Parameter Estimates (Provide True Value of h)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.SLC.Global, top = title, left = y.lab, bottom = x.lab))

# Four Parms
MFP.2.SLC.Global.1 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.2 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.3 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.4 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
MFP.2.SLC.Global.5 <- rstan::extract(ModFentonPerkins_2_SLC_FitObj_FourParms_5, permuted = TRUE, include = TRUE)

MFP.2.SLC.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,1])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,1])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,1])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,1])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,1]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,1], MFP.2.SLC.Global.2$theta[ ,1], MFP.2.SLC.Global.3$theta[ ,1], MFP.2.SLC.Global.4$theta[ ,1], MFP.2.SLC.Global.5$theta[ ,1]))
MFP.2.SLC.G.r <- ggplot(data = MFP.2.SLC.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.SLC.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,2])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,2])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,2])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,2])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,2]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,2], MFP.2.SLC.Global.2$theta[ ,2], MFP.2.SLC.Global.3$theta[ ,2], MFP.2.SLC.Global.4$theta[ ,2], MFP.2.SLC.Global.5$theta[ ,2]))
MFP.2.SLC.G.b <- ggplot(data = MFP.2.SLC.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,3])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,3])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,3])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,3])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,3]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,3], MFP.2.SLC.Global.2$theta[ ,3], MFP.2.SLC.Global.3$theta[ ,3], MFP.2.SLC.Global.4$theta[ ,3], MFP.2.SLC.Global.5$theta[ ,3]))
MFP.2.SLC.G.e <- ggplot(data = MFP.2.SLC.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.3) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.SLC.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.SLC.Global.1$theta[ ,4])), rep("2", length(MFP.2.SLC.Global.2$theta[ ,4])), rep("3", length(MFP.2.SLC.Global.3$theta[ ,4])), rep("4", length(MFP.2.SLC.Global.4$theta[ ,4])), rep("5", length(MFP.2.SLC.Global.5$theta[ ,4]))), Estimate = c(MFP.2.SLC.Global.1$theta[ ,4], MFP.2.SLC.Global.2$theta[ ,4], MFP.2.SLC.Global.3$theta[ ,4], MFP.2.SLC.Global.4$theta[ ,4], MFP.2.SLC.Global.5$theta[ ,4]))
MFP.2.SLC.G.d <- ggplot(data = MFP.2.SLC.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.41) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.SLC.Global <- plot_grid(MFP.2.SLC.G.r, MFP.2.SLC.G.b, MFP.2.SLC.G.e, MFP.2.SLC.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Stable Limit Cycle), Global Model Parameter Estimates (Provide True Values of β and h)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.SLC.Global, top = title, left = y.lab, bottom = x.lab))
```

### MFP, Type II, DO

```{r}
# Five Parms, Give B
MFP.2.DO.Global.1 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_1, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.2 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_2, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.3 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_3, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.4 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_4, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.5 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms_5, permuted = TRUE, include = TRUE)

MFP.2.DO.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,1])), rep("2", length(MFP.2.DO.Global.2$theta[ ,1])), rep("3", length(MFP.2.DO.Global.3$theta[ ,1])), rep("4", length(MFP.2.DO.Global.4$theta[ ,1])), rep("5", length(MFP.2.DO.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,1], MFP.2.DO.Global.2$theta[ ,1], MFP.2.DO.Global.3$theta[ ,1], MFP.2.DO.Global.4$theta[ ,1], MFP.2.DO.Global.5$theta[ ,1]))
MFP.2.DO.G.r <- ggplot(data = MFP.2.DO.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DO.G.h.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,2])), rep("2", length(MFP.2.DO.Global.2$theta[ ,2])), rep("3", length(MFP.2.DO.Global.3$theta[ ,2])), rep("4", length(MFP.2.DO.Global.4$theta[ ,2])), rep("5", length(MFP.2.DO.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,2], MFP.2.DO.Global.2$theta[ ,2], MFP.2.DO.Global.3$theta[ ,2], MFP.2.DO.Global.4$theta[ ,2], MFP.2.DO.Global.5$theta[ ,2]))
MFP.2.DO.G.h <- ggplot(data = MFP.2.DO.G.h.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(h), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.06) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,3])), rep("2", length(MFP.2.DO.Global.2$theta[ ,3])), rep("3", length(MFP.2.DO.Global.3$theta[ ,3])), rep("4", length(MFP.2.DO.Global.4$theta[ ,3])), rep("5", length(MFP.2.DO.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,3], MFP.2.DO.Global.2$theta[ ,3], MFP.2.DO.Global.3$theta[ ,3], MFP.2.DO.Global.4$theta[ ,3], MFP.2.DO.Global.5$theta[ ,3]))
MFP.2.DO.G.b <- ggplot(data = MFP.2.DO.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,4])), rep("2", length(MFP.2.DO.Global.2$theta[ ,4])), rep("3", length(MFP.2.DO.Global.3$theta[ ,4])), rep("4", length(MFP.2.DO.Global.4$theta[ ,4])), rep("5", length(MFP.2.DO.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,4], MFP.2.DO.Global.2$theta[ ,4], MFP.2.DO.Global.3$theta[ ,4], MFP.2.DO.Global.4$theta[ ,4], MFP.2.DO.Global.5$theta[ ,4]))
MFP.2.DO.G.e <- ggplot(data = MFP.2.DO.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,5])), rep("2", length(MFP.2.DO.Global.2$theta[ ,5])), rep("3", length(MFP.2.DO.Global.3$theta[ ,5])), rep("4", length(MFP.2.DO.Global.4$theta[ ,5])), rep("5", length(MFP.2.DO.Global.5$theta[ ,5]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,5], MFP.2.DO.Global.2$theta[ ,5], MFP.2.DO.Global.3$theta[ ,5], MFP.2.DO.Global.4$theta[ ,5], MFP.2.DO.Global.5$theta[ ,5]))
MFP.2.DO.G.d <- ggplot(data = MFP.2.DO.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DO.Global <- plot_grid(MFP.2.DO.G.r, MFP.2.DO.G.h, MFP.2.DO.G.b, MFP.2.DO.G.e, MFP.2.DO.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Damping Oscillations), Global Model Parameter Estimates (Provide True Value of β)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DO.Global, top = title, left = y.lab, bottom = x.lab))

# Five Parms, Give h
MFP.2.DO.Global.1 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_1, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.2 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_2, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.3 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_3, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.4 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_4, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.5 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FiveParms.ExHT_5, permuted = TRUE, include = TRUE)

MFP.2.DO.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,1])), rep("2", length(MFP.2.DO.Global.2$theta[ ,1])), rep("3", length(MFP.2.DO.Global.3$theta[ ,1])), rep("4", length(MFP.2.DO.Global.4$theta[ ,1])), rep("5", length(MFP.2.DO.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,1], MFP.2.DO.Global.2$theta[ ,1], MFP.2.DO.Global.3$theta[ ,1], MFP.2.DO.Global.4$theta[ ,1], MFP.2.DO.Global.5$theta[ ,1]))
MFP.2.DO.G.r <- ggplot(data = MFP.2.DO.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DO.G.B.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,2])), rep("2", length(MFP.2.DO.Global.2$theta[ ,2])), rep("3", length(MFP.2.DO.Global.3$theta[ ,2])), rep("4", length(MFP.2.DO.Global.4$theta[ ,2])), rep("5", length(MFP.2.DO.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,2], MFP.2.DO.Global.2$theta[ ,2], MFP.2.DO.Global.3$theta[ ,2], MFP.2.DO.Global.4$theta[ ,2], MFP.2.DO.Global.5$theta[ ,2]))
MFP.2.DO.G.B <- ggplot(data = MFP.2.DO.G.B.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(beta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.008) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,3])), rep("2", length(MFP.2.DO.Global.2$theta[ ,3])), rep("3", length(MFP.2.DO.Global.3$theta[ ,3])), rep("4", length(MFP.2.DO.Global.4$theta[ ,3])), rep("5", length(MFP.2.DO.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,3], MFP.2.DO.Global.2$theta[ ,3], MFP.2.DO.Global.3$theta[ ,3], MFP.2.DO.Global.4$theta[ ,3], MFP.2.DO.Global.5$theta[ ,3]))
MFP.2.DO.G.b <- ggplot(data = MFP.2.DO.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,4])), rep("2", length(MFP.2.DO.Global.2$theta[ ,4])), rep("3", length(MFP.2.DO.Global.3$theta[ ,4])), rep("4", length(MFP.2.DO.Global.4$theta[ ,4])), rep("5", length(MFP.2.DO.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,4], MFP.2.DO.Global.2$theta[ ,4], MFP.2.DO.Global.3$theta[ ,4], MFP.2.DO.Global.4$theta[ ,4], MFP.2.DO.Global.5$theta[ ,4]))
MFP.2.DO.G.e <- ggplot(data = MFP.2.DO.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,5])), rep("2", length(MFP.2.DO.Global.2$theta[ ,5])), rep("3", length(MFP.2.DO.Global.3$theta[ ,5])), rep("4", length(MFP.2.DO.Global.4$theta[ ,5])), rep("5", length(MFP.2.DO.Global.5$theta[ ,5]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,5], MFP.2.DO.Global.2$theta[ ,5], MFP.2.DO.Global.3$theta[ ,5], MFP.2.DO.Global.4$theta[ ,5], MFP.2.DO.Global.5$theta[ ,5]))
MFP.2.DO.G.d <- ggplot(data = MFP.2.DO.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DO.Global <- plot_grid(MFP.2.DO.G.r, MFP.2.DO.G.B, MFP.2.DO.G.b, MFP.2.DO.G.e, MFP.2.DO.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Damping Oscillations), Global Model Parameter Estimates (Provide True Value of h)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DO.Global, top = title, left = y.lab, bottom = x.lab))

# Four Parms
MFP.2.DO.Global.1 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_1, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.2 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_2, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.3 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_3, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.4 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_4, permuted = TRUE, include = TRUE)
MFP.2.DO.Global.5 <- rstan::extract(ModFentonPerkins_2_DO_FitObj_FourParms_5, permuted = TRUE, include = TRUE)

MFP.2.DO.G.r.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,1])), rep("2", length(MFP.2.DO.Global.2$theta[ ,1])), rep("3", length(MFP.2.DO.Global.3$theta[ ,1])), rep("4", length(MFP.2.DO.Global.4$theta[ ,1])), rep("5", length(MFP.2.DO.Global.5$theta[ ,1]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,1], MFP.2.DO.Global.2$theta[ ,1], MFP.2.DO.Global.3$theta[ ,1], MFP.2.DO.Global.4$theta[ ,1], MFP.2.DO.Global.5$theta[ ,1]))
MFP.2.DO.G.r <- ggplot(data = MFP.2.DO.G.r.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(r), x = "", y = "", fill = "") +
  geom_vline(xintercept = 2.5) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none") 

MFP.2.DO.G.b.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,2])), rep("2", length(MFP.2.DO.Global.2$theta[ ,2])), rep("3", length(MFP.2.DO.Global.3$theta[ ,2])), rep("4", length(MFP.2.DO.Global.4$theta[ ,2])), rep("5", length(MFP.2.DO.Global.5$theta[ ,2]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,2], MFP.2.DO.Global.2$theta[ ,2], MFP.2.DO.Global.3$theta[ ,2], MFP.2.DO.Global.4$theta[ ,2], MFP.2.DO.Global.5$theta[ ,2]))
MFP.2.DO.G.b <- ggplot(data = MFP.2.DO.G.b.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(b), x = "", y = "", fill = "") +
  geom_vline(xintercept = 35) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.e.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,3])), rep("2", length(MFP.2.DO.Global.2$theta[ ,3])), rep("3", length(MFP.2.DO.Global.3$theta[ ,3])), rep("4", length(MFP.2.DO.Global.4$theta[ ,3])), rep("5", length(MFP.2.DO.Global.5$theta[ ,3]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,3], MFP.2.DO.Global.2$theta[ ,3], MFP.2.DO.Global.3$theta[ ,3], MFP.2.DO.Global.4$theta[ ,3], MFP.2.DO.Global.5$theta[ ,3]))
MFP.2.DO.G.e <- ggplot(data = MFP.2.DO.G.e.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(e), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    legend.position = "none")

MFP.2.DO.G.d.df <- data.frame(TimeSeries = c(rep("1", length(MFP.2.DO.Global.1$theta[ ,4])), rep("2", length(MFP.2.DO.Global.2$theta[ ,4])), rep("3", length(MFP.2.DO.Global.3$theta[ ,4])), rep("4", length(MFP.2.DO.Global.4$theta[ ,4])), rep("5", length(MFP.2.DO.Global.5$theta[ ,4]))), Estimate = c(MFP.2.DO.Global.1$theta[ ,4], MFP.2.DO.Global.2$theta[ ,4], MFP.2.DO.Global.3$theta[ ,4], MFP.2.DO.Global.4$theta[ ,4], MFP.2.DO.Global.5$theta[ ,4]))
MFP.2.DO.G.d <- ggplot(data = MFP.2.DO.G.d.df, aes(x = Estimate, group = TimeSeries, fill = TimeSeries), colour = colours) +
  geom_density(alpha = 0.4) +
  labs(title = expression(delta), x = "", y = "", fill = "") +
  geom_vline(xintercept = 0.2) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank())

MFP.2.DO.Global <- plot_grid(MFP.2.DO.G.r, MFP.2.DO.G.b, MFP.2.DO.G.e, MFP.2.DO.G.d, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR (Damping Oscillations), Global Model Parameter Estimates (Provide True Values of β and h)")
y.lab <- textGrob("Density", rot = 90)
x.lab <- textGrob("Estimate")
grid.arrange(arrangeGrob(MFP.2.DO.Global, top = title, left = y.lab, bottom = x.lab))
```

```{r}

```

# 95% CIs

```{r}
Model <- c("MFP_2_DO", "MFP_2_SLC", "MFP_2_DivOsc")

# ## r
# MFP_1.1_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj1, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.2_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj2, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.3_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj3, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.4_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj4, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.5_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj5, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_2.1_DO_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj1, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.2_DO_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj2, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.3_DO_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj3, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.4_DO_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj4, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.5_DO_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj5, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_2.1_SLC_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj1, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.2_SLC_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj2, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.3_SLC_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj3, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.4_SLC_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj4, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.5_SLC_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj5, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_2.1_DivOsc_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.2_DivOsc_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.3_DivOsc_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.4_DivOsc_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.5_DivOsc_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_3.1_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj1, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.2_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj2, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.3_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj3, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.4_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj4, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.5_r <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj5, pars = "theta[1]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# df.r <- data.frame(MFP_1.1_r, MFP_1.2_r, MFP_1.3_r, MFP_1.4_r, MFP_1.5_r,
#                    MFP_2.1_DO_r, MFP_2.2_DO_r, MFP_2.3_DO_r, MFP_2.4_DO_r, MFP_2.5_DO_r, 
#                    MFP_2.1_SLC_r, MFP_2.2_SLC_r, MFP_2.3_SLC_r,MFP_2.4_SLC_r, MFP_2.5_SLC_r, 
#                    MFP_2.1_DivOsc_r, MFP_2.2_DivOsc_r, MFP_2.3_DivOsc_r,MFP_2.4_DivOsc_r, MFP_2.5_SLC_r,
#                    MFP_3.1_r, MFP_3.2_r, MFP_3.3_r, MFP_3.4_r, MFP_3.5_r)
# df.r <- as.matrix(df.r); df.r <- t(df.r); df.r <- as.data.frame(df.r); colnames(df.r) <- c("Lower", "Mean", "Upper")
# Model <- c(rownames(df.r)); df.r <- cbind(Model, df.r); df.r <- as.data.frame(df.r)
# 
# colours <- c(rep("red3", 5), rep("orange", 5), rep("forestgreen", 5), rep("orchid", 5), rep("lightblue3", 5))
# 
# ggplot(df.r, aes(x = Model, y = Mean, colour = colours)) + geom_point() +  
#   geom_errorbar(aes(ymin = Lower, ymax = Upper)) +
#   labs(y = "Mean Estimate of r") +
#   ylim(0, 6) +
#   theme_bw() +
#   theme(axis.line = element_line(colour = "black"),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.border = element_blank(),
#     panel.background = element_blank()) +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, colour = "black")) +
#   theme(legend.position = "none") 
# 
## B
MFP_1.1_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj1, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.2_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj2, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.3_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj3, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.4_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj4, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.5_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj5, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DO_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj1, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DO_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj2, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DO_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj3, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DO_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj4, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DO_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj5, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_SLC_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj1, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_SLC_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj2, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_SLC_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj3, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_SLC_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj4, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_SLC_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj5, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DivOsc_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DivOsc_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DivOsc_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DivOsc_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DivOsc_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_3.1_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj1, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.2_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj2, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.3_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj3, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.4_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj4, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.5_B <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj5, pars = "theta[2]")[[1]], probs = c(0.025, 0.5, 0.975)))

df.B <- data.frame(# MFP_1.1_B, MFP_1.2_B, MFP_1.3_B, MFP_1.4_B, MFP_1.5_B,
                   MFP_2.1_DO_B, MFP_2.2_DO_B, MFP_2.3_DO_B, MFP_2.4_DO_B, MFP_2.5_DO_B, 
                   MFP_2.1_SLC_B, MFP_2.2_SLC_B, MFP_2.3_SLC_B,MFP_2.4_SLC_B, MFP_2.5_SLC_B, 
                   MFP_2.1_DivOsc_B, MFP_2.2_DivOsc_B, MFP_2.3_DivOsc_B,MFP_2.4_DivOsc_B, MFP_2.5_DivOsc_B)
                   # , MFP_3.1_B, MFP_3.2_B, MFP_3.3_B, MFP_3.4_B, MFP_3.5_B)
df.B <- as.matrix(df.B); df.B <- t(df.B); df.B <- as.data.frame(df.B); colnames(df.B) <- c("Lower", "Mean", "Upper")
Model <- c(rownames(df.B)); df.B <- cbind(Model, df.B); df.B <- as.data.frame(df.B)
TrueVal <- c(rep(0.008, 5), rep(0.012, 5), rep(0.012, 5))
df.B <- as.data.frame(cbind(df.B, TrueVal))
df.B$Model <- factor(df.B$Model, levels = Model)

colours <- c(rep("orange", 5), rep("orchid", 5), rep("lightblue3", 5))
xlabs <- c("Damping Oscillations, TS 1", "Damping Oscillations, TS 2", "Damping Oscillations, TS 3", "Damping Oscillations, TS 4", "Damping Oscillations, TS 5",
           "Stable Limit Cycle, TS 1", "Stable Limit Cycle, TS 2", "Stable Limit Cycle, TS 3", "Stable Limit Cycle, TS 4", "Stable Limit Cycle, TS 5",
           "Divergent Oscillations, TS 1", "Divergent Oscillations, TS 2", "Divergent Oscillations, TS 3","Divergent Oscillations, TS 4", "Divergent Oscillations, TS 5")

Global.B <- ggplot(df.B, aes(x = Model, y = Mean)) + geom_point(colour = colours) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), colour = colours) +
  geom_point(aes(x = Model, y = TrueVal), shape = 4, colour = "black", alpha = 1) +
  labs(x = "", y = "Model Estimates of β") +
  ylim(0, 1) +
  scale_x_discrete(labels = c("")) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_text(colour = "black")) +
  theme(legend.position = "none") 

## h
MFP_1.1_h <- c(0, 0, 0)
MFP_1.2_h <- c(0, 0, 0)
MFP_1.3_h <- c(0, 0, 0)
MFP_1.4_h <- c(0, 0, 0)
MFP_1.5_h <- c(0, 0, 0)

MFP_2.1_DO_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj1, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DO_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj2, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DO_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj3, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DO_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj4, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DO_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj5, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_SLC_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj1, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_SLC_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj2, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_SLC_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj3, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_SLC_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj4, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_SLC_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj5, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DivOsc_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DivOsc_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DivOsc_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DivOsc_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DivOsc_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_3.1_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj1, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.2_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj2, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.3_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj3, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.4_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj4, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.5_h <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj5, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))

df.h <- data.frame(# MFP_1.1_h, MFP_1.2_h, MFP_1.3_h, MFP_1.4_h, MFP_1.5_h,
                   MFP_2.1_DO_h, MFP_2.2_DO_h, MFP_2.3_DO_h, MFP_2.4_DO_h, MFP_2.5_DO_h, 
                   MFP_2.1_SLC_h, MFP_2.2_SLC_h, MFP_2.3_SLC_h,MFP_2.4_SLC_h, MFP_2.5_SLC_h, 
                   MFP_2.1_DivOsc_h, MFP_2.2_DivOsc_h, MFP_2.3_DivOsc_h,MFP_2.4_DivOsc_h, MFP_2.5_DivOsc_h)
                   # , MFP_3.1_h, MFP_3.2_h, MFP_3.3_h, MFP_3.4_h, MFP_3.5_h)
df.h <- as.matrix(df.h); df.h <- t(df.h); df.h <- as.data.frame(df.h); colnames(df.h) <- c("Lower", "Mean", "Upper")
Model <- c(rownames(df.h)); df.h <- cbind(Model, df.h); df.h <- as.data.frame(df.h)
TrueVal <- c(rep(0.06, 5), rep(0.075, 5), rep(0.075, 5))
df.h <- as.data.frame(cbind(df.h, TrueVal))
df.h$Model <- factor(df.h$Model, levels = Model)

colours <- c(rep("orange", 5), rep("orchid", 5), rep("lightblue3", 5))
xlabs <- c("Damping Oscillations, TS 1", "Damping Oscillations, TS 2", "Damping Oscillations, TS 3", "Damping Oscillations, TS 4", "Damping Oscillations, TS 5",
           "Stable Limit Cycle, TS 1", "Stable Limit Cycle, TS 2", "Stable Limit Cycle, TS 3", "Stable Limit Cycle, TS 4", "Stable Limit Cycle, TS 5",
           "Divergent Oscillations, TS 1", "Divergent Oscillations, TS 2", "Divergent Oscillations, TS 3","Divergent Oscillations, TS 4", "Divergent Oscillations, TS 5")

Global.h <- ggplot(df.h, aes(x = Model, y = Mean)) + geom_point(colour = colours) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), colour = colours) +
  geom_point(aes(x = Model, y = TrueVal), shape = 4, colour = "black", alpha = 1) +
  labs(x = "", y = "Model Estimates of h") +
  ylim(0, 1) +
  scale_x_discrete(labels = c("")) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_text(colour = "black")) +
  theme(legend.position = "none") 

# ## b
# MFP_1.1_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj1, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.2_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj2, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.3_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj3, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.4_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj4, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_1.5_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj5, pars = "theta[3]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_2.1_DO_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj1, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.2_DO_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj2, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.3_DO_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj3, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.4_DO_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj4, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.5_DO_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj5, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_2.1_SLC_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj1, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.2_SLC_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj2, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.3_SLC_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj3, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.4_SLC_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj4, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.5_SLC_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj5, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_2.1_DivOsc_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.2_DivOsc_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.3_DivOsc_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.4_DivOsc_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_2.5_DivOsc_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# MFP_3.1_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj1, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.2_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj2, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.3_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj3, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.4_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj4, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# MFP_3.5_b <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj5, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
# 
# df.b <- data.frame(MFP_1.1_b, MFP_1.2_b, MFP_1.3_b, MFP_1.4_b, MFP_1.5_b,
#                    MFP_2.1_DO_b, MFP_2.2_DO_b, MFP_2.3_DO_b, MFP_2.4_DO_b, MFP_2.5_DO_b, 
#                    MFP_2.1_SLC_b, MFP_2.2_SLC_b, MFP_2.3_SLC_b,MFP_2.4_SLC_b, MFP_2.5_SLC_b, 
#                    MFP_2.1_DivOsc_b, MFP_2.2_DivOsc_b, MFP_2.3_DivOsc_b,MFP_2.4_DivOsc_b, MFP_2.5_DivOsc_b,
#                    MFP_3.1_b, MFP_3.2_b, MFP_3.3_b, MFP_3.4_b, MFP_3.5_b)
# df.b <- as.matrix(df.b); df.b <- t(df.b); df.b <- as.data.frame(df.b); colnames(df.b) <- c("Lower", "Mean", "Upper")
# Model <- c(rownames(df.b)); df.b <- cbind(Model, df.b); df.b <- as.data.frame(df.b)
# 
# colours <- c(rep("red3", 5), rep("orange", 5), rep("forestgreen", 5), rep("orchid", 5), rep("lightblue3", 5))
# 
# ggplot(df.b, aes(x = Model, y = Mean, colour = colours)) + geom_point() +  
#   geom_errorbar(aes(ymin = Lower, ymax = Upper)) +
#   labs(y = "Mean Estimate of b") +
#   ylim(0, 250) +
#   theme_bw() +
#   theme(axis.line = element_line(colour = "black"),
#     panel.grid.major = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.border = element_blank(),
#     panel.background = element_blank()) +
#   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, colour = "black")) +
#   theme(legend.position = "none") 

## e
MFP_1.1_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj1, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.2_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj2, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.3_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj3, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.4_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj4, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.5_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj5, pars = "theta[4]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DO_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj1, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DO_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj2, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DO_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj3, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DO_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj4, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DO_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj5, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_SLC_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj1, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_SLC_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj2, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_SLC_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj3, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_SLC_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj4, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_SLC_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj5, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DivOsc_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DivOsc_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DivOsc_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DivOsc_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DivOsc_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_3.1_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj1, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.2_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj2, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.3_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj3, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.4_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj4, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.5_e <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj5, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))

df.e <- data.frame(# MFP_1.1_e, MFP_1.2_e, MFP_1.3_e, MFP_1.4_e, MFP_1.5_e,
                   MFP_2.1_DO_e, MFP_2.2_DO_e, MFP_2.3_DO_e, MFP_2.4_DO_e, MFP_2.5_DO_e, 
                   MFP_2.1_SLC_e, MFP_2.2_SLC_e, MFP_2.3_SLC_e,MFP_2.4_SLC_e, MFP_2.5_SLC_e, 
                   MFP_2.1_DivOsc_e, MFP_2.2_DivOsc_e, MFP_2.3_DivOsc_e,MFP_2.4_DivOsc_e, MFP_2.5_DivOsc_e)
                   # , MFP_3.1_e, MFP_3.2_e, MFP_3.3_e, MFP_3.4_e, MFP_3.5_e)
df.e <- as.matrix(df.e); df.e <- t(df.e); df.e <- as.data.frame(df.e); colnames(df.e) <- c("Lower", "Mean", "Upper")
Model <- c(rownames(df.e)); df.e <- cbind(Model, df.e); df.e <- as.data.frame(df.e)
TrueVal <- c(rep(0.2, 5), rep(0.3, 5), rep(0.3, 5))
df.e <- as.data.frame(cbind(df.e, TrueVal))
df.e$Model <- factor(df.e$Model, levels = Model)

colours <- c(rep("orange", 5), rep("orchid", 5), rep("lightblue3", 5))
xlabs <- c("Damping Oscillations, TS 1", "Damping Oscillations, TS 2", "Damping Oscillations, TS 3", "Damping Oscillations, TS 4", "Damping Oscillations, TS 5",
           "Stable Limit Cycle, TS 1", "Stable Limit Cycle, TS 2", "Stable Limit Cycle, TS 3", "Stable Limit Cycle, TS 4", "Stable Limit Cycle, TS 5",
           "Divergent Oscillations, TS 1", "Divergent Oscillations, TS 2", "Divergent Oscillations, TS 3","Divergent Oscillations, TS 4", "Divergent Oscillations, TS 5")

Global.e <- ggplot(df.e, aes(x = Model, y = Mean)) + geom_point(colour = colours) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), colour = colours) +
  geom_point(aes(x = Model, y = TrueVal), shape = 4, colour = "black", alpha = 1) +
  labs(x = "", y = "Model Estimates of e") +
  ylim(0, 1) +
  scale_x_discrete(labels = c("")) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_text(colour = "black")) +
  theme(legend.position = "none") 

## delta
MFP_1.1_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj1, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.2_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj2, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.3_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj3, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.4_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj4, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_1.5_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_1_FitObj5, pars = "theta[5]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DO_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj1, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DO_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj2, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DO_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj3, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DO_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj4, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DO_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DO_FitObj5, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_SLC_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj1, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_SLC_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj2, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_SLC_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj3, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_SLC_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj4, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_SLC_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_SLC_FitObj5, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_2.1_DivOsc_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj1, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.2_DivOsc_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj2, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.3_DivOsc_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj3, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.4_DivOsc_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj4, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_2.5_DivOsc_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_2_DivOsc_FitObj5, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))

MFP_3.1_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj1, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.2_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj2, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.3_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj3, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.4_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj4, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))
MFP_3.5_delta <- as.numeric(quantile(rstan::extract(ModFentonPerkins_3_FitObj5, pars = "theta[6]")[[1]], probs = c(0.025, 0.5, 0.975)))

df.delta <- data.frame(# MFP_1.1_delta, MFP_1.2_delta, MFP_1.3_delta, MFP_1.4_delta, MFP_1.5_delta,
                   MFP_2.1_DO_delta, MFP_2.2_DO_delta, MFP_2.3_DO_delta, MFP_2.4_DO_delta, MFP_2.5_DO_delta, 
                   MFP_2.1_SLC_delta, MFP_2.2_SLC_delta, MFP_2.3_SLC_delta,MFP_2.4_SLC_delta, MFP_2.5_SLC_delta, 
                   MFP_2.1_DivOsc_delta, MFP_2.2_DivOsc_delta, MFP_2.3_DivOsc_delta,MFP_2.4_DivOsc_delta, MFP_2.5_DivOsc_delta)
                   # , MFP_3.1_delta, MFP_3.2_delta, MFP_3.3_delta, MFP_3.4_delta, MFP_3.5_delta)
df.delta <- as.matrix(df.delta); df.delta <- t(df.delta); df.delta <- as.data.frame(df.delta); colnames(df.delta) <- c("Lower", "Mean", "Upper")
Model <- c(rownames(df.delta)); df.delta <- cbind(Model, df.delta); df.delta <- as.data.frame(df.delta)
TrueVal <- c(rep(0.2, 5), rep(0.41, 5), rep(0.48, 5))
df.delta <- as.data.frame(cbind(df.delta, TrueVal))
df.delta$Model <- factor(df.delta$Model, levels = Model)

colours <- c(rep("orange", 5), rep("orchid", 5), rep("lightblue3", 5))
xlabs <- c("Damping Oscillations, TS 1", "Damping Oscillations, TS 2", "Damping Oscillations, TS 3", "Damping Oscillations, TS 4", "Damping Oscillations, TS 5",
           "Stable Limit Cycle, TS 1", "Stable Limit Cycle, TS 2", "Stable Limit Cycle, TS 3", "Stable Limit Cycle, TS 4", "Stable Limit Cycle, TS 5",
           "Divergent Oscillations, TS 1", "Divergent Oscillations, TS 2", "Divergent Oscillations, TS 3","Divergent Oscillations, TS 4", "Divergent Oscillations, TS 5")

Global.delta <- ggplot(df.delta, aes(x = Model, y = Mean)) + geom_point(colour = colours) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), colour = colours) +
  geom_point(aes(x = Model, y = TrueVal), shape = 4, colour = "black", alpha = 1) +
  labs(x = "", y = "Model Estimates of δ") +
  ylim(0, 1) +
  scale_x_discrete(labels = xlabs) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, colour = "black")) +
  theme(axis.text.y = element_text(colour = "black")) +
  theme(legend.position = "none") 

# Plotting them together
Global.Plots <- plot_grid(Global.B, Global.h, Global.e, Global.delta, nrow = 4)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR | Global Model Fitting")
x.lab <- textGrob("Generating Model and Corresponding Time Series")
grid.arrange(arrangeGrob(Global.Plots, top = title, bottom = x.lab))

## Autoregressive Model
# DivOsc and SLC differ in delta 
# SLC and DampOsc differ in r
# DivOsc and DampOsc differ in delta and r

# DivOsc, delta
AR_DivOsc.1_delta <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.1.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.2_delta <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.2.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.3_delta <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.3.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.4_delta <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.4.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.5_delta <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.5.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
# DivOsc, r
AR_DivOsc.1_r <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.1.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.2_r <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.2.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.3_r <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.3.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.4_r <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.4.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DivOsc.5_r <- as.numeric(quantile(rstan::extract(MFP.II.DivOsc.5.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
# SLC, delta
AR_SLC.1_delta <- as.numeric(quantile(rstan::extract(MFP.II.SLC.1.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.2_delta <- as.numeric(quantile(rstan::extract(MFP.II.SLC.2.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.3_delta <- as.numeric(quantile(rstan::extract(MFP.II.SLC.3.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.4_delta <- as.numeric(quantile(rstan::extract(MFP.II.SLC.4.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.5_delta <- as.numeric(quantile(rstan::extract(MFP.II.SLC.5.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
# SLC, r
AR_SLC.1_r <- as.numeric(quantile(rstan::extract(MFP.II.SLC.1.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.2_r <- as.numeric(quantile(rstan::extract(MFP.II.SLC.2.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.3_r <- as.numeric(quantile(rstan::extract(MFP.II.SLC.3.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.4_r <- as.numeric(quantile(rstan::extract(MFP.II.SLC.4.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_SLC.5_r <- as.numeric(quantile(rstan::extract(MFP.II.SLC.5.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
# DampOsc, delta
AR_DampOsc.1_delta <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.1.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.2_delta <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.2.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.3_delta <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.3.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.4_delta <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.4.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.5_delta <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.5.AR.Fit, pars = "delta")[[1]], probs = c(0.025, 0.5, 0.975)))
# DampOsc, r
AR_DampOsc.1_r <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.1.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.2_r <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.2.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.3_r <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.3.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.4_r <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.4.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))
AR_DampOsc.5_r <- as.numeric(quantile(rstan::extract(MFP.II.DampOsc.5.AR.Fit, pars = "r")[[1]], probs = c(0.025, 0.5, 0.975)))

# delta
df.delta <- data.frame(AR_DampOsc.1_delta, AR_DampOsc.2_delta, AR_DampOsc.3_delta, AR_DampOsc.4_delta, AR_DampOsc.5_delta,
                       AR_SLC.1_delta, AR_SLC.2_delta, AR_SLC.3_delta, AR_SLC.4_delta, AR_SLC.5_delta, 
                       AR_DivOsc.1_delta, AR_DivOsc.2_delta, AR_DivOsc.3_delta, AR_DivOsc.4_delta, AR_DivOsc.5_delta)
df.delta <- as.matrix(df.delta); df.delta <- t(df.delta); df.delta <- as.data.frame(df.delta); colnames(df.delta) <- c("Lower", "Mean", "Upper")
Model <- c(rownames(df.delta)); df.delta <- cbind(Model, df.delta); df.delta <- as.data.frame(df.delta)
TrueVal <- c(rep(0.34, 5), rep(0.34, 5), rep(0.41, 5))
df.delta <- as.data.frame(cbind(df.delta, TrueVal))
df.delta$Model <- factor(df.delta$Model, levels = Model)

colours <- c(rep("orange", 5), rep("orchid", 5), rep("lightblue3", 5))
xlabs <- c("Damping Oscillations, TS 1", "Damping Oscillations, TS 2", "Damping Oscillations, TS 3", "Damping Oscillations, TS 4", "Damping Oscillations, TS 5",
           "Stable Limit Cycle, TS 1", "Stable Limit Cycle, TS 2", "Stable Limit Cycle, TS 3", "Stable Limit Cycle, TS 4", "Stable Limit Cycle, TS 5",
           "Divergent Oscillations, TS 1", "Divergent Oscillations, TS 2", "Divergent Oscillations, TS 3","Divergent Oscillations, TS 4", "Divergent Oscillations, TS 5")

AR.delta <- ggplot(df.delta, aes(x = Model, y = Mean)) + geom_point(colour = colours) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), colour = colours) +
  geom_point(aes(x = Model, y = TrueVal), shape = 4, colour = "black", alpha = 1) +
  labs(x = "", y = "Model Estimates of δ") +
  ylim(0.25, 0.5) +
  scale_x_discrete(labels = xlabs) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, colour = "black")) +
  theme(axis.text.y = element_text(colour = "black")) +
  theme(legend.position = "none") 

# r
df.r <- data.frame(AR_DampOsc.1_r, AR_DampOsc.2_r, AR_DampOsc.3_r, AR_DampOsc.4_r, AR_DampOsc.5_r,
                       AR_SLC.1_r, AR_SLC.2_r, AR_SLC.3_r, AR_SLC.4_r, AR_SLC.5_r, 
                       AR_DivOsc.1_r, AR_DivOsc.2_r, AR_DivOsc.3_r, AR_DivOsc.4_r, AR_DivOsc.5_r)
df.r <- as.matrix(df.r); df.r <- t(df.r); df.r <- as.data.frame(df.r); colnames(df.r) <- c("Lower", "Mean", "Upper")
Model <- c(rownames(df.r)); df.r <- cbind(Model, df.r); df.r <- as.data.frame(df.r)
TrueVal <- c(rep(2.1, 5), rep(2.5, 5), rep(2.5, 5))
df.r <- as.data.frame(cbind(df.r, TrueVal))
df.r$Model <- factor(df.r$Model, levels = Model)

colours <- c(rep("orange", 5), rep("orchid", 5), rep("lightblue3", 5))
xlabs <- c("Damping Oscillations, TS 1", "Damping Oscillations, TS 2", "Damping Oscillations, TS 3", "Damping Oscillations, TS 4", "Damping Oscillations, TS 5",
           "Stable Limit Cycle, TS 1", "Stable Limit Cycle, TS 2", "Stable Limit Cycle, TS 3", "Stable Limit Cycle, TS 4", "Stable Limit Cycle, TS 5",
           "Divergent Oscillations, TS 1", "Divergent Oscillations, TS 2", "Divergent Oscillations, TS 3","Divergent Oscillations, TS 4", "Divergent Oscillations, TS 5")

AR.r <- ggplot(df.r, aes(x = Model, y = Mean)) + geom_point(colour = colours) +  
  geom_errorbar(aes(ymin = Lower, ymax = Upper), colour = colours) +
  geom_point(aes(x = Model, y = TrueVal), shape = 4, colour = "black", alpha = 1) +
  labs(x = "", y = "Model Estimates of r") +
  ylim(1.5, 3.5) +
  scale_x_discrete(labels = xlabs) +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) +
  theme(axis.text.x = element_blank()) +
  theme(axis.text.y = element_text(colour = "black")) +
  theme(legend.position = "none") 

# Plotting them together
AR.Plots <- plot_grid(AR.r, AR.delta, nrow = 2)
title <- textGrob("Modified Fenton and Perkins (2010), Type II FR | Autoregressive (AR-1) Model Fitting")
x.lab <- textGrob("Generating Model and Corresponding Time Series")
grid.arrange(arrangeGrob(AR.Plots, top = title, bottom = x.lab))
```
