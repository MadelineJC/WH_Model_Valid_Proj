---
title: "Chapter 1, Continuing"
author: "M. Jarvis-Cross"
output: html_document
---

```{r, include = FALSE}
library(readr)
library(tidyverse)
library(deSolve)
library(GillespieSSA)
library(rstan)
library(bayesplot)
library(brms)
library(reshape2)
library(MCMCvis)
```

# Models & Dynamics

+----------+---------------------+----------------------------+--------------------------+
|          | Antia et al.        | Fenton and Perkins         | Mod. Fenton and Perkins  |
+==========+=====================+============================+==========================+
| Type I   | NA                  | 1.  Stable limit cycle     | 1.  Damping oscillations |
+----------+---------------------+----------------------------+--------------------------+
| Type II  | Stable, extirpation | 1.  Stable limit cycle     | 1.  Stable limit cycle   |
|          |                     | 2.  Divergent oscillations | 2.  Damping oscillations |
+----------+---------------------+----------------------------+--------------------------+
| Type III | NA                  | 1.  Stable limit cycle     | 1.  Damping oscillations |
|          |                     | 2.  Damping oscillations   |                          |
+----------+---------------------+----------------------------+--------------------------+

# To Do:

0.  Use single microparasite models from Fenton and Perkins (*Parasitology*, 2010) to fit the unmodified model with Type I, II, and III FRs

<!-- -->

1.  ~~Use LV model to generate stochastic data; fit BC model to those data~~

    (a) Fit modified (with $b$) Fenton and Perkins w/ a Type I FR

2.  ~~Autoregressive model: Compare true and estimated data in a plot like you did with global model to identify potential structural unidentifiability~~

3.  ~~Fit NM model to deterministic data~~

4.  Look at how changing single parameters values ($\theta$, $h$, maybe $c$) change the time series data

5.  ~~Fit NM model to a few different stochastic time series~~

## 0. Use single microparasite models from Fenton and Perkins (*Parasitology*, 2010) to do above

The proposed LV model:

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

With TI functional response, $f(P)=\beta P$

With a TII functional response, $f(P)=\frac{\beta P}{1+h \beta P}$

With a TIII functional response, $f(P)=\frac{\beta P^2}{1+h \beta P^2}$

### TI FR

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

Where, $f(P)=\beta P$

-   Is a marginally/neutrally stable system.

Now, let's simulate data:

```{r}
FP_T1 <- function(t, y, p){
  r <- p[1]; B <- p[2]; e <- p[3]; delta <- p[4]
  P <- y[1]; I <- y[2]
  dP = r*P - I*B*P
  dI = e*B*P*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; e <- 0.1; delta <- 0.01
parms <- c(r, B, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 500, 1)
results <- lsoda(N0, TT, FP_T1, parms)
FP_1_Det <- data.frame(results); colnames(FP_1_Det) <- c("Times", "P", "I")

plot(FP_1_Det$Times, FP_1_Det$P, type = "l", col = "cornflowerblue", xlab = "Time", ylab = "Population Abundance")
lines(FP_1_Det$Times, FP_1_Det$I, col = "firebrick2")
```

```{r}
x0 <- c(P = 1, I = 1) # Unity
a <- c("r*P",
       "I*B*P", 
       "e*B*P*I",
       "delta*I")
nu <- matrix(c(+1, -1, 0, 0,
               0, 0, +1, -1), nrow = 2, byrow = TRUE)

r <- 0.1; B <- 0.05; e <- 0.1; delta <- 0.01
parms <- c(r = r, B = B, e = e, delta = delta)
tf = 200
method <- "OTL"
simName <- "FP_1_Stoch"
set.seed(123)
FP_1_Stoch <- suppressWarnings(ssa(x0, a, nu, parms, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
FP_1_Stoch <- as.data.frame(FP_1_Stoch$data)
colnames(FP_1_Stoch) <- c("Time", "P", "I")
FirstZero <- which(FP_1_Stoch$P == 0)[1]
FP_1_Stoch <- FP_1_Stoch[1:FirstZero - 1, ]

plot(FP_1_Stoch$Time, FP_1_Stoch$P, type = "l", col = "cornflowerblue", main = "Demographically Stochastic FP_1_Stoch Model", sub = "Initial Conditions: At Unity", xlab = "Time", ylab = "Population Abundance")
points(FP_1_Stoch$Time, FP_1_Stoch$I, type = "l", col = "firebrick2")

## Starting at equilibrium
x0 <- c(P = 20, I = 2) # Equilibrium values: P = delta/e*B; I = r/B
set.seed(123)
FP_1_Stoch <- suppressWarnings(ssa(x0, a, nu, parms, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
FP_1_Stoch <- as.data.frame(FP_1_Stoch$data)
colnames(FP_1_Stoch) <- c("Time", "P", "I")
FirstZero <- which(FP_1_Stoch$P == 0)[1]
FP_1_Stoch <- FP_1_Stoch[1:FirstZero - 1, ]

plot(FP_1_Stoch$Time, FP_1_Stoch$P, type = "l", col = "cornflowerblue", main = "Demographically Stochastic FP_1_Stoch Model", sub = "Initial Conditions: At Equilibrium", xlab = "Time", ylab = "Population Abundance")
points(FP_1_Stoch$Time, FP_1_Stoch$I, type = "l", col = "firebrick2")
```

```{r}
## Data
N <- length(FP_1_Det$Time) - 1
ts <- 1:N
y_init <- c(FP_1_Det$P[1], FP_1_Det$I[1])
y <- as.matrix(FP_1_Det[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
FP_1_Det_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

N <- length(FP_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(FP_1_Stoch$P[1], FP_1_Stoch$I[1])
y <- as.matrix(FP_1_Stoch[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
FP_1_Stoch_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1.stan")
# model <- stan_model("Chapter1Review/FP_1.stan")

## Fit
fit <- sampling(model, data = FP_1_Det_Stan, iter = 2000, chains = 2, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Det_FitObj.rds")
# saveRDS(fit, file = "Chapter1Review/FP_1_Det_FitObj.rds")

fit <- sampling(model, data = FP_1_Stoch_Stan, iter = 2000, chains = 2, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Stoch_FitObj.rds")
# saveRDS(fit, file = "Chapter1Review/FP_1_Stoch_FitObj.rds")
```

```{r}
## Deterministic
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Det_FitObj.rds")
## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 

## Stochastic
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Stoch_FitObj.rds")
## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
#             mean se_mean    sd   10%    50%    90% n_eff  Rhat
# theta[1]   0.461   0.062 0.456 0.163  0.311  1.003    54 1.070
# theta[2]   0.061   0.009 0.067 0.018  0.039  0.131    55 1.066
# theta[3]   0.737   0.030 0.602 0.091  0.584  1.604   396 1.008
# theta[4]   0.307   0.043 0.284 0.121  0.223  0.526    43 1.083
# sigma[1]   0.425   0.005 0.098 0.316  0.407  0.553   457 1.008
# sigma[2]   0.835   0.006 0.177 0.639  0.807  1.062   803 1.001
# z_init[1]  8.142   0.100 2.312 5.615  7.816 11.005   533 1.005
# z_init[2] 14.913   0.522 6.948 7.348 13.650 24.034   177 1.020
## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 
```

```{r}
output <- rstan::extract(fit, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
# NM_1_Det
N <- length(NM_1_Det$Time) - 1
ts <- 1:N
y_init <- c(NM_1_Det$P[1], NM_1_Det$I[1])
y <- as.matrix(NM_1_Det[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts[1:200], df$P[1:200], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:200], df$I[1:200], col = "red4")
lines(df$ts[1:200], df$post_means_P[1:200], col = "cornflowerblue")
lines(df$ts[1:200], df$post_means_I[1:200], col = "firebrick2")

plot(df$ts[1:2000], df$P[1:2000], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:2000], df$I[1:2000], col = "red4")
lines(df$ts[1:2000], df$post_means_P[1:2000], col = "cornflowerblue")
lines(df$ts[1:2000], df$post_means_I[1:2000], col = "firebrick2")
```

### TII FR

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

Where, $f(P)=\frac{\beta P}{1+h \beta P}$

-   An unstable system that produces divergent oscillations.

Now, let's simulate data:

#### Oscillations

```{r}
NM_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; h <- 0; e <- 0.1; delta <- 0.01
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 5000, 0.1)
results <- lsoda(N0, TT, NM_T2, parms)
NM_2_Det <- data.frame(results); colnames(NM_2_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_2_Det[ ,2:3])

plot(NM_2_Det$Times, NM_2_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_2_Det$Times, NM_2_Det$I, col = "firebrick2")

plot(NM_2_Det$Times[0:20001], NM_2_Det$P[0:20001], type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_2_Det$Times[0:20001], NM_2_Det$I[0:20001], col = "firebrick2")

P_Max <- max(NM_2_Det$P); P_left <- P_Max - 0.0001; P_right <- P_Max + 0.0001
plot(NM_2_Det$Times, NM_2_Det$P, type = "l", col = "cornflowerblue", ylim = c(P_left, P_right), xlab = "Time", ylab = "Population Abundance")

I_Max <- max(NM_2_Det$I); I_left <- I_Max - 0.00001; I_right <- I_Max + 0.00001
plot(NM_2_Det$Times, NM_2_Det$I, type = "l", col = "firebrick2", ylim = c(I_left, I_right), xlab = "Time", ylab = "Population Abundance")
```

#### Divergent Oscillations

```{r}
NM_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 0.05; B <- 0.05; h <- 0.1; e <- 0.1; delta <- 0.01
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 5000, 0.1)
results <- lsoda(N0, TT, NM_T2, parms)
NM_2_Det <- data.frame(results); colnames(NM_2_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_2_Det[ ,2:3])

plot(NM_2_Det$Times, NM_2_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_2_Det$Times, NM_2_Det$I, col = "firebrick2")
```

### TIII FR

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

Where, $f(P)=\frac{\beta P^2}{1+h \beta P^2}$

-   Stable when: $e>2 \delta h$

Now, let's simulate data:

#### Oscillations

```{r}
NM_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 0.04; B <- 0.05; h <- 10; e <- 0.2; delta <- 0.01; print(e > 2*delta*h)
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, NM_T3, parms)
NM_3_Det <- data.frame(results); colnames(NM_3_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_3_Det[ ,2:3])

plot(NM_3_Det$Times, NM_3_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_3_Det$Times, NM_3_Det$I, col = "firebrick2")
```

#### Damping Oscillations

```{r}
NM_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; h <- 2.5; e <- 0.1; delta <- 0.008; print(e > 2*delta*h)
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, NM_T3, parms)
NM_3_Det <- data.frame(results); colnames(NM_3_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_3_Det[ ,2:3])

plot(NM_3_Det$Times, NM_3_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_3_Det$Times, NM_3_Det$I, col = "firebrick2")
```

```{r}
x0 <- c(P = 1, I = 1) 
a <- c("r*P",
       "I*(B*P^2/(1 + h*B*P^2))", 
       "e*(B*P^2/(1 + h*B*P^2))*I",
       "delta*I")
nu <- matrix(c(+1, -1, 0, 0,
               0, 0, +1, -1), nrow = 2, byrow = TRUE)

r <- 0.1; B <- 0.05; h <- 2.5; e <- 0.1; delta <- 0.008
parms <- c(r = r, B = B, h = h, e = e, delta = delta)
tf = 500
method <- "OTL"
simName <- "FP_TypeI"
set.seed(1)
FP_TypeI <- suppressWarnings(ssa(x0, a, nu, parms, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
FP_TypeI <- as.data.frame(FP_TypeI$data)
colnames(FP_TypeI) <- c("Time", "P", "I")

FirstZero <- which(FP_TypeI$P == 0)[1]
FP_TypeI <- FP_TypeI[1:FirstZero - 1, ]

#write_csv(LV_StochSim, file = "Chapter1Review/Data/LV_StochSim.csv")

plot(FP_TypeI$Time, FP_TypeI$P, type = "l", col = "cornflowerblue", main = "Demographically Stochastic FP_TypeI Model", xlab = "Time", ylab = "Population Abundance")
points(FP_TypeI$Time, FP_TypeI$I, type = "l", col = "firebrick2")
```

```{r}
## Data
N <- length(NM_3_Det$Time) - 1
ts <- 1:N
y_init <- c(NM_3_Det$P[1], NM_3_Det$I[1])
y <- as.matrix(NM_3_Det[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
NM_3_Det_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_Type3.stan")

## Fit
fit <- sampling(model, data = NM_3_Det_Stan, iter = 4000, chains = 2, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_Type3_FitObj.rds")
```

```{r}
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_Type3_FitObj.rds")

## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

#             mean se_mean    sd   10%    50%    90% n_eff  Rhat
# theta[1]   0.702   0.024 0.406 0.289  0.605  1.215   275 1.006
# theta[2]   0.014   0.001 0.044 0.004  0.010  0.027  2215 1.000
# theta[3]   1.317   0.060 0.841 0.365  1.204  2.374   199 1.010
# theta[4]   1.448   0.031 0.677 0.629  1.382  2.306   470 1.000
# theta[5]   0.407   0.015 0.233 0.171  0.363  0.706   242 1.001
# sigma[1]   1.625   0.053 0.450 1.140  1.532  2.273    74 1.026
# sigma[2]   0.993   0.017 0.251 0.691  0.959  1.319   208 1.004
# z_init[1] 11.925   0.301 6.847 5.275 10.480 19.460   518 1.003
# z_init[2]  9.523   0.412 6.590 3.756  8.063 16.882   255 1.008

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 
```

```{r}
output <- rstan::extract(fit, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
# NM_1_Det
N <- length(NM_3_Det$Time) - 1
ts <- 1:N
y_init <- c(NM_3_Det$P[1], NM_3_Det$I[1])
y <- as.matrix(NM_3_Det[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts[1:200], df$P[1:200], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:200], df$I[1:200], col = "red4")
lines(df$ts[1:200], df$post_means_P[1:200], col = "cornflowerblue")
lines(df$ts[1:200], df$post_means_I[1:200], col = "firebrick2")

plot(df$ts[1:2000], df$P[1:2000], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:2000], df$I[1:2000], col = "red4")
lines(df$ts[1:2000], df$post_means_P[1:2000], col = "cornflowerblue")
lines(df$ts[1:2000], df$post_means_I[1:2000], col = "firebrick2")
```

## 1. Use LV model to generate stochastic data; fit BC model to those data

The proposed LV model:

$\frac{du}{dt} = (\alpha - \beta v)u$

$\frac{dv}{dt} = (-\gamma + \delta u)v$

```{r}
LV_Model <- function(t, y, p){
  alpha <- p[1]; beta <- p[2]; gamma <- p[3]; delta <- p[4] 
  u <- y[1]; v <- y[2]
  du = (alpha - beta * v) * u
  dv = (-gamma + delta * u) * v
  list(c(du, dv))
}
alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024 # From posterior estimates
parms <- c(alpha, beta, gamma, delta)

## Initial conditions as per Bob Carpenter's work
u0 <- 33.956; v0 <- 5.933 # In thousands, as per Carpenter
N0 <- c(u0, v0)
TT <- seq(1, 21, 1) # Twenty years, assessed every year
results <- lsoda(N0, TT, LV_Model, parms, verbose = FALSE)
LV_DetSim_BC <- data.frame(results); colnames(LV_DetSim_BC) <- c("Time", "Lynx", "Hare")

plot(LV_DetSim_BC$Time, LV_DetSim_BC$Lynx, type = "l", col = "navy", main = "Deterministic LV Model", sub = "Initial Conditions: As per Carpenter", xlab = "Time", ylab = "Population Abundance", ylim = c(0, 100))
points(LV_DetSim_BC$Time, LV_DetSim_BC$Hare, type = "l", col = "red4")
points(1:21, lynx_hare_df$Lynx, type = "l", col = "cornflowerblue")
points(1:21, lynx_hare_df$Hare, type = "l", col = "firebrick2")

## At/near equilibrium
# u0 <- 33.45833; v0 <- 19.46429 # At equilibrium
u0 <- 30; v0 <- 20 # Near equilibrium
N0 <- c(u0, v0)
TT <- seq(0, 25, 1) # Twenty years, assessed every year
results <- lsoda(N0, TT, LV_Model, parms, verbose = FALSE)
LV_DetSim_Eq <- data.frame(results); colnames(LV_DetSim_Eq) <- c("Time", "Lynx", "Hare")

plot(LV_DetSim_Eq$Time, LV_DetSim_Eq$Lynx, type = "l", col = "navy", main = "Deterministic LV Model", sub = "Initial Conditions: Near Equilibrium", xlab = "Time", ylab = "Population Abundance", ylim = c(min(LV_DetSim_Eq[ ,2:3]), max(LV_DetSim_Eq[ ,2:3])))
points(LV_DetSim_Eq$Time, LV_DetSim_Eq$Hare, type = "l", col = "red4")
```

Now, let's generate some stochastic data:

```{r}
## Initial conditions as per Bob Carpenter's work
x0 <- c(u = 4, v = 30) # Given by Carpenter
a <- c("alpha*u",
       "beta*v*u", 
       "gamma*v",
       "delta*u*v")
nu <- matrix(c(+1, -1, 0, 0,
               0, 0, -1, +1), nrow = 2, byrow = TRUE)
alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024
parms1 <- c(alpha = alpha, beta = beta, gamma = gamma, delta = delta)
tf = 25
method <- "OTL"
simName <- "LV"
set.seed(1)
LV_StochSim_BC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
LV_StochSim_BC <- LV_StochSim_BC$data; LV_StochSim_BC <- as.data.frame(LV_StochSim_BC)
colnames(LV_StochSim_BC) <- c("Time", "Lynx", "Hare")
FirstZero <- which(LV_StochSim_BC$Hare == 0)[1]
LV_StochSim_BC <- LV_StochSim_BC[1:FirstZero - 1, ]

plot(LV_StochSim_BC$Time, LV_StochSim_BC$Lynx, type = "l", col = "navy", main = "Demographically Stochastic LV Model", sub = "Initial Conditions: As per Carpenter", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(LV_StochSim_BC[ ,2:3])))
points(LV_StochSim_BC$Time, LV_StochSim_BC$Hare, type = "l", col = "red4")

plot(LV_DetSim_BC$Time, LV_DetSim_BC$Lynx, type = "l", col = "navy", main = "Deterministic LV Model", sub = "Initial Conditions: As per Carpenter",  xlab = "Time", ylab = "Population Abundance")
lines(LV_DetSim_BC$Time, LV_DetSim_BC$Hare, col = "red4")
lines(LV_StochSim_BC$Time, LV_StochSim_BC$Lynx, col = "navy", lty = 2)
lines(LV_StochSim_BC$Time, LV_StochSim_BC$Hare, col = "red4", lty = 2)

## At/near equilibrium
x0 <- c(u = 30, v = 20) # At equilibrium: u = gamma/delta; v = alpha/beta
set.seed(1)
LV_StochSim_Eq <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
LV_StochSim_Eq <- LV_StochSim_Eq$data; LV_StochSim_Eq <- as.data.frame(LV_StochSim_Eq)
colnames(LV_StochSim_Eq) <- c("Time", "Lynx", "Hare")
FirstZero <- which(LV_StochSim_Eq$Hare == 0)[1]
LV_StochSim_Eq <- LV_StochSim_Eq[1:FirstZero - 1, ]

plot(LV_StochSim_Eq$Time, LV_StochSim_Eq$Lynx, type = "l", col = "navy", main = "Demographically Stochastic LV Model", sub = "Initial Conditions: Near Equilibrium", xlab = "Time", ylab = "Population Abundance", ylim = c(0, max(LV_StochSim_Eq[ ,2:3])))
points(LV_StochSim_Eq$Time, LV_StochSim_Eq$Hare, type = "l", col = "red4")

plot(LV_DetSim_Eq$Time, LV_DetSim_Eq$Lynx, type = "l", col = "navy", main = "Deterministic LV Model", sub = "Initial Conditions: Near Equilibrium",  xlab = "Time", ylab = "Population Abundance", ylim = c(min(LV_StochSim_Eq[ ,2:3]), max(LV_StochSim_Eq[ ,2:3])))
lines(LV_DetSim_Eq$Time, LV_DetSim_Eq$Hare, col = "red4")
lines(LV_StochSim_Eq$Time, LV_StochSim_Eq$Lynx, col = "navy", lty = 2)
lines(LV_StochSim_Eq$Time, LV_StochSim_Eq$Hare, col = "red4", lty = 2)
```

Here's the data BC used, for comparison:

```{r}
# Read in data
lynx_hare_df <- read_csv("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/hudson-bay-lynx-hare.csv")
lynx_hare_df <- as.data.frame(lynx_hare_df)

# Plotting
plot(lynx_hare_df$Year, lynx_hare_df$Lynx, type = "l", col = "cornflowerblue", ylim = c(0, max(lynx_hare_df$Hare)), main = "Empirical Data Used to Fit LV Model", xlab = "Year", ylab = "Population Abundance", lwd = 2)
lines(lynx_hare_df$Year, lynx_hare_df$Hare, col = "firebrick2", lwd = 2)

df <- data.frame(cbind(lynx_hare_df$Year, lynx_hare_df$Lynx, lynx_hare_df$Hare, LV_DetSim_BC$Lynx, LV_DetSim_BC$Hare, LV_StochSim_BC$Lynx, LV_StochSim_BC$Hare)) 
colnames(df) <- c("Year", "Dat_Lynx", "Dat_Hare", "Det_Lynx", "Det_Hare", "Stoch_Lynx", "Stoch_Hare") 
df <- df[1:nrow(lynx_hare_df), ]

plot(df$Year, df$Dat_Lynx, type = "l", col = "cornflowerblue", xlab = "Year", ylab = "Population Abundance", ylim = c(0, 120), lwd = 2)
lines(df$Year, df$Dat_Hare, col = "firebrick2", lwd = 2)
lines(df$Year, df$Det_Lynx, col = "navy", lwd = 2)
lines(df$Year, df$Det_Hare, col = "red4", lwd = 2)
lines(df$Year, df$Stoch_Lynx, col = "navy", lty = 2, lwd = 2)
lines(df$Year, df$Stoch_Hare, col = "red4", lty = 2, lwd = 2)
legend("topright", legend = c("Dat_Lynx", "Dat_Hare", "Det_Lynx", "Det_Hare", "Stoch_Lynx", "Stoch_Hare"), col = c("cornflowerblue", "firebrick2", "navy", "red4", "navy", "red4"), lty = c(1, 1, 1, 1, 2, 2))
```

Okay, now let's fit the LV model to our generated data:

```{r, eval = FALSE}
## Data
N <- length(LV_StochSim_BC$Time) - 1
ts <- 1:N
y_init <- c(LV_StochSim_BC$Hare[1], LV_StochSim_BC$Lynx[1])
y <- as.matrix(LV_StochSim_BC[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
LV_StochSim_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/lotka-volterra.stan")

## Fit
fit <- sampling(model, data = LV_StochSim_Stan, iter = 2000, chains = 4, cores = 4, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/GenDat_FitObj.rds")
```

```{r}
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/GenDat_FitObj.rds")

## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd   10%    50%    90% n_eff  Rhat
# theta[1]   0.635   0.060 0.503 0.200  0.354  1.403    69 1.035
# theta[2]   0.037   0.004 0.037 0.007  0.015  0.095    82 1.030
# theta[3]   0.866   0.042 0.409 0.318  0.882  1.392    95 1.035
# theta[4]   0.083   0.004 0.039 0.029  0.083  0.134    84 1.033
# sigma[1]   1.533   0.057 0.477 0.851  1.556  2.136    70 1.033
# sigma[2]   0.885   0.045 0.413 0.472  0.712  1.477    83 1.032
# z_init[1] 13.702   0.819 8.689 6.538 11.134 23.904   112 1.032
# z_init[2]  9.340   0.507 5.782 4.870  7.126 17.168   130 1.031

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 
```

That's not ideal! Let's compare the "real" data to the estimation.

```{r}
rows <- nrow(LV_StochSim_BC); dim <- ncol(LV_StochSim_BC) - 1

z_init_draws <- extract(fit)$z_init
z_draws <- extract(fit)$z
y_init_rep_draws <- extract(fit)$y_init_rep
y_rep_draws <- extract(fit)$y_rep
predicted_pelts <- matrix(NA, rows, dim)
min_pelts <- matrix(NA, rows, dim)
max_pelts <- matrix(NA, rows, dim)
for (k in 1:2) {
  predicted_pelts[1, k] <- mean(y_init_rep_draws[ , k])
  min_pelts[1, k] <- quantile(y_init_rep_draws[ , k], 0.25)
  max_pelts[1, k] <- quantile(y_init_rep_draws[ , k], 0.75)
  for (n in 2:rows) {
    predicted_pelts[n, k] <- mean(y_rep_draws[ , n - 1, k])
    min_pelts[n, k] <- quantile(y_rep_draws[ , n - 1, k], 0.25)
    max_pelts[n, k] <- quantile(y_rep_draws[ , n - 1, k], 0.75)
  }
}

lynx_hare_df <- LV_StochSim_BC
lynx_hare_melted_df <- melt(as.matrix(lynx_hare_df[, 2:3]))
colnames(lynx_hare_melted_df) <- c("year", "species", "pelts")
lynx_hare_melted_df$year <-
  lynx_hare_melted_df$year +
  rep(0, length(lynx_hare_melted_df$year))

Nmelt <- dim(lynx_hare_melted_df)[1]
lynx_hare_observe_df <- lynx_hare_melted_df
lynx_hare_observe_df$source <- rep("measurement", Nmelt)

lynx_hare_predict_df <-
  data.frame(year = rep(1:rows, 2),
             species = c(rep("Lynx", rows), rep("Hare", rows)),
             pelts = c(predicted_pelts[, 2],
                       predicted_pelts[, 1]),
             min_pelts = c(min_pelts[, 2], min_pelts[, 1]),
             max_pelts = c(max_pelts[, 2], max_pelts[, 1]),
             source = rep("prediction", rows*2))

lynx_hare_observe_df$min_pelts = lynx_hare_predict_df$min_pelts
lynx_hare_observe_df$max_pelts = lynx_hare_predict_df$max_pelts

lynx_hare_observe_predict_df <-
  rbind(lynx_hare_observe_df, lynx_hare_predict_df)

population_plot2 <-
  ggplot(data = lynx_hare_observe_predict_df,
         aes(x = year, y = pelts, color = source)) +
  geom_vline(xintercept = 1, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  facet_wrap( ~ species, ncol = 1) +
  geom_ribbon(aes(ymin = min_pelts, ymax = max_pelts),
	      colour = NA, fill = "orchid", alpha = 0.2) +
  geom_line() +
  geom_point() +
  ylab("Pelts (Thousands)") +
  xlab("Year") +
  theme(legend.position = "bottom") +
  theme_minimal()
population_plot2
```

### Outcome:

While the posterior captures the true parameter values, the sampler didn't seem to explore the parameter space well, resulting in non-normal posterior distributions. Additionally, estimates did not reproduce data, which is strange.

**What if we try the model to data generated with the same model/parameters, but initial conditions near equilibrium?**

```{r}
## Data
N <- length(LV_StochSim_Eq$Time) - 1
ts <- 1:N
y_init <- c(LV_StochSim_Eq$Hare[1], LV_StochSim_Eq$Lynx[1])
y <- as.matrix(LV_StochSim_Eq[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
LV_StochSim_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/lotka-volterra.stan")

## Fit
fit <- sampling(model, data = LV_StochSim_Stan, iter = 2000, chains = 4, cores = 4, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/GenDat_FitObj_Eq.rds")
```

```{r}
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Bob-Carpenter_Example/GenDat_FitObj_Eq.rds")

## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd    10%    50%    90% n_eff  Rhat
# theta[1]   0.800   0.025 0.474  0.306  0.658  1.504   362 1.021
# theta[2]   0.030   0.001 0.020  0.010  0.023  0.060   382 1.019
# theta[3]   0.941   0.013 0.351  0.511  0.916  1.421   724 1.008
# theta[4]   0.076   0.001 0.030  0.039  0.075  0.115   801 1.008
# sigma[1]   1.245   0.008 0.297  0.914  1.201  1.629  1398 1.000
# sigma[2]   0.485   0.009 0.182  0.287  0.449  0.731   406 1.014
# z_init[1] 13.983   0.132 5.182  8.131 13.312 20.468  1530 1.001
# z_init[2] 20.709   0.205 6.090 14.344 19.323 29.016   879 1.006

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars)
```

BUT! How well does it reproduce the data?

```{r}
rows <- nrow(LV_StochSim_Eq); dim <- ncol(LV_StochSim_Eq) - 1

z_init_draws <- extract(fit)$z_init
z_draws <- extract(fit)$z
y_init_rep_draws <- extract(fit)$y_init_rep
y_rep_draws <- extract(fit)$y_rep
predicted_pelts <- matrix(NA, rows, dim)
min_pelts <- matrix(NA, rows, dim)
max_pelts <- matrix(NA, rows, dim)
for (k in 1:2) {
  predicted_pelts[1, k] <- mean(y_init_rep_draws[ , k])
  min_pelts[1, k] <- quantile(y_init_rep_draws[ , k], 0.25)
  max_pelts[1, k] <- quantile(y_init_rep_draws[ , k], 0.75)
  for (n in 2:rows) {
    predicted_pelts[n, k] <- mean(y_rep_draws[ , n - 1, k])
    min_pelts[n, k] <- quantile(y_rep_draws[ , n - 1, k], 0.25)
    max_pelts[n, k] <- quantile(y_rep_draws[ , n - 1, k], 0.75)
  }
}

lynx_hare_df <- LV_StochSim_Eq
lynx_hare_melted_df <- melt(as.matrix(lynx_hare_df[, 2:3]))
colnames(lynx_hare_melted_df) <- c("year", "species", "pelts")
lynx_hare_melted_df$year <-
  lynx_hare_melted_df$year +
  rep(0, length(lynx_hare_melted_df$year))

Nmelt <- dim(lynx_hare_melted_df)[1]
lynx_hare_observe_df <- lynx_hare_melted_df
lynx_hare_observe_df$source <- rep("measurement", Nmelt)

lynx_hare_predict_df <-
  data.frame(year = rep(1:rows, 2),
             species = c(rep("Lynx", rows), rep("Hare", rows)),
             pelts = c(predicted_pelts[, 2],
                       predicted_pelts[, 1]),
             min_pelts = c(min_pelts[, 2], min_pelts[, 1]),
             max_pelts = c(max_pelts[, 2], max_pelts[, 1]),
             source = rep("prediction", rows*2))

lynx_hare_observe_df$min_pelts = lynx_hare_predict_df$min_pelts
lynx_hare_observe_df$max_pelts = lynx_hare_predict_df$max_pelts

lynx_hare_observe_predict_df <-
  rbind(lynx_hare_observe_df, lynx_hare_predict_df)

population_plot2 <-
  ggplot(data = lynx_hare_observe_predict_df,
         aes(x = year, y = pelts, color = source)) +
  geom_vline(xintercept = 1, color = "grey") +
  geom_hline(yintercept = 0, color = "grey") +
  facet_wrap( ~ species, ncol = 1) +
  geom_ribbon(aes(ymin = min_pelts, ymax = max_pelts),
	      colour = NA, fill = "orchid", alpha = 0.2) +
  geom_line() +
  geom_point() +
  ylab("Pelts (Thousands)") +
  xlab("Year") +
  theme(legend.position = "bottom") +
  theme_minimal()
population_plot2
```

Still not great!!

### (a) Fit NM with Type I (rather than Type II) functional response to data

Okay, so with a Type I functional response, the model would look something like this:

$\frac{dP}{dt} = rP - (\theta P)H$

$\frac{dH}{dt} = b + (c(\theta P) - \mu)H$

With a Type I FR *without* $b$, we see a neutrally stable model. When we add $b$, we get damping oscillations.

Let's simulate some data:

```{r}
NM_T1 <- function(t,y,p){
  r <- p[1]; O <- p[2]; c <- p[3]; u <- p[4]
  P <- y[1]; H <- y[2]
  dP = r*P - H*O*P
  dH = H*(c*O*P - u)
  list(c(dP, dH))
}
r <- 0.1; O <- 0.05; c <- 0.1; u <- 0.01
parms <- c(r, O, c, u)
P0 <- 1; H0 <- 1
N0 <- c(P0, H0)
TT <- seq(0, 1000, 0.1) 
results <- lsoda(N0, TT, NM_T1, parms)
NM_Det <- data.frame(results); colnames(NM_Det) <- c("Time", "P", "H")

plot(NM_Det$Time, NM_Det$P, type = "l", col = "cornflowerblue", xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (Without b)")
lines(NM_Det$Time, NM_Det$H, col = "firebrick2")

## With b (1st Parameterization)
NowakMay_T1 <- function(t,y,p){
  r <- p[1]; O <- p[2]; b <- p[3]; c <- p[4]; u <- p[5]
  P <- y[1]; H <- y[2]
  dP = P*r - H*(O*P)
  dH = b + H*(c*(O*P) - u)
  list(c(dP,dH))
}
r <- 1.5; O <- 0.001; b <- 200; c <- 0.9; u <- 0.2
parms <- c(r, O, b, c, u)
P0 <- 1; H0 <- 1
N0 <- c(P0, H0)
TT <- seq(0, 100, 0.1) 
results <- lsoda(N0, TT, NowakMay_T1, parms)
NM_DetSim <- data.frame(results); colnames(NM_DetSim) <- c("Time", "Parasites", "ImmuneCells")

plot(NM_DetSim$Time, NM_DetSim$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_DetSim$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (With b (1st Parameterization))")
lines(NM_DetSim$Time, NM_DetSim$ImmuneCells, col = "firebrick2")
```

Now, for some stochastic implementations:

```{r}
## Without b
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P)", 
       "H*c*(O*P)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r <- 1; O <- 0.001; c <- 0.8; u <- 0.2
parms1 <- c(r = r, O = O, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T1"
set.seed(4)
NowakMay_T1 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_T1 <- NowakMay_T1$data 
NM_StochSim_T1 <- as.data.frame(NM_StochSim_T1)
colnames(NM_StochSim_T1) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_T1, file = "Chapter1Review/Data/NM_StochSim_T1_1.csv")

plot(NM_StochSim_T1$Time, NM_StochSim_T1$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_T1$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (Without b)")
lines(NM_StochSim_T1$Time, NM_StochSim_T1$ImmuneCells, col = "firebrick2")

## With b (1st Parameterization)
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P)", 
       "b + H*c*(O*P)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r <- 2; O <- 0.001; b <- 200; c <- 1; u <- 0.3
parms1 <- c(r = r, O = O, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T1"
set.seed(2)
NowakMay_T1 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_T1 <- NowakMay_T1$data 
NM_StochSim_T1 <- as.data.frame(NM_StochSim_T1)
colnames(NM_StochSim_T1) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_T1, file = "Chapter1Review/Data/NM_StochSim_T1_2.csv")

plot(NM_StochSim_T1$Time, NM_StochSim_T1$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_T1$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (With b (1st Parameterization))")
lines(NM_StochSim_T1$Time, NM_StochSim_T1$ImmuneCells, col = "firebrick2")

## With b (2nd Parameterization)
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P)", 
       "b + H*c*(O*P)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r <- 1; O <- 0.001; b <- 200; c <- 1; u <- 0.2
parms1 <- c(r = r, O = O, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T1"
set.seed(1)
NowakMay_T1 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_T1 <- NowakMay_T1$data 
NM_StochSim_T1 <- as.data.frame(NM_StochSim_T1)
colnames(NM_StochSim_T1) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_T1, file = "Chapter1Review/Data/NM_StochSim_T1_3.csv")

plot(NM_StochSim_T1$Time, NM_StochSim_T1$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_T1$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (With b (1st Parameterization))")
lines(NM_StochSim_T1$Time, NM_StochSim_T1$ImmuneCells, col = "firebrick2")
```

Okay, I tried to fit the model with the Type I response to the third time series (considering the first two are very short), and it was also too short! Didn't work! See code below.

```{r, eval = FALSE}
## With b (2nd Parameterization)
NM_StochSim_T1 <- read_csv("Chapter1Review/Data/NM_StochSim_T1_3.csv"); head(NM_StochSim_T1)
First0 <- which(NM_StochSim_T1$Parasites == 0); First0 <- First0[1]-1; NM_StochSim_T1 <- NM_StochSim_T1[1:First0, ]
N <- length(NM_StochSim_T1$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_T1$Parasites[1], NM_StochSim_T1$ImmuneCells[1])
y <- as.matrix(NM_StochSim_T1[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_T1 <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_T1_With-b.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_T1, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_T1_With-b-2_FitObj.rds")
```

#### Outcome:

This didn't work, not because the model was necessarily hard to fit, but because the stochastic time series weren't long enough. I could try again with deterministic time series.

## 2. Autoregressive model: Compare true and estimated data in a plot like you did with global model to identify potential structural unidentifiability

Okay, so, here's the data we gave the autoregressive model:

```{r}
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (LONG)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")
```

And here's the fit we got, using an autoregressive framework:

```{r}
fit <- readRDS("Chapter1Review/FitObjs/NM_DamOsc_14_FitObj.rds")

## Summarise the fit
fitSumm <- print(fit, pars = c("r", "b", "c", "u"),
                 probs=c(0.1, 0.5, 0.9), digits = 3)

#     mean se_mean     sd    10%    50%    90% n_eff  Rhat
# r  0.794   0.001  0.029  0.759  0.795  0.830   751 1.000
# b 62.857   0.740 16.276 42.479 62.628 84.084   484 1.010
# c  0.195   0.001  0.020  0.170  0.194  0.220   635 1.001
# u  0.339   0.003  0.076  0.246  0.333  0.438   473 1.011

## Viz
pars <- c("r", "b", "c", "u")
stan_trace(fit, pars)
mcmc_pairs(fit, pars)
mcmc_dens(fit, pars) 
```

Now, let's compare the data to the estimates. If the data and estimates are comparable, we have an unidentifiability problem.

```{r}
output <- rstan::extract(fit, permuted = TRUE, include = TRUE)
r_mean <- mean(output$r)
b_mean <- mean(output$b)
c_mean <- mean(output$c)
u_mean <- mean(output$u)

P <- c(NM_StochSim_DamOsc$Parasites[1]); H <- c(NM_StochSim_DamOsc$ImmuneCells[1])

for (t in 2:nrow(NM_StochSim_DamOsc)){
  P[t] <- P[t-1] + r_mean*P[t-1] - (1-exp((-0.008/(1 + 0.008*0.06*P[t-1]))*H[t-1]))*P[t-1]
  H[t] <- H[t-1] + b_mean + c_mean*(0.008*P[t-1]/(1 + 0.008*P[t-1]*0.06))*H[t-1] - (1-exp(-u_mean))*H[t-1]
}

df <- as.data.frame(cbind(seq(1, nrow(NM_StochSim_DamOsc), 1), NM_StochSim_DamOsc$Parasites, NM_StochSim_DamOsc$ImmuneCells, P, H))
colnames(df) <- c("t", "real_P", "real_H", "est_P", "est_H")

plot(df$t, df$real_P, type = "l", col = "cornflowerblue", ylim = c(0, max(df$real_H)), xlab = "Time", ylab = "Population Abundance")
lines(df$t, df$real_H, col = "firebrick2")
lines(df$t, df$est_P, col = "cornflowerblue", lty = 2)
lines(df$t, df$est_H, col = "firebrick2", lty = 2)
```

### Outcome:

The parameter estimates made by the autoregressive model do not replicate the data given to the model. It seems a good idea to return to this model, and make sure it's written correctly. As it stands, the model seems to think it knows what it's doing, but it doesn't.

## 3. Fit NM model to deterministic data

Here's some deterministic data:

```{r}
NowakMay_T2_Dam <- function(t,y,p){
  r <- p[1]; O <- p[2]; h <- p[3]
  b <- p[4]; c <- p[5]; u <- p[6]
  P <- y[1]; H <- y[2]
  dP = P*r - H*(O*P/(1 + O*P*h))
  dH = b + H*(c*(O*P/(1 + O*P*h)) - u)
  list(c(dP, dH))
}
r <- 2.5; O <- 0.008; h <- 0.06
b <- 35; c <- 0.2; u <- 0.2
parms <- c(r, O, h, b, c, u)
P0 <- 80; H0 <- 200 
N0 <- c(P0, H0)
TT <- seq(0, 100, 1) 
results <- lsoda(N0, TT, NowakMay_T2_Dam, parms)
NM_DetSim <- data.frame(results); colnames(NM_DetSim) <- c("Time", "Parasites", "ImmuneCells")

write_csv(NM_DetSim, "Chapter1Review/Data/NM_DetSim_DamOsc.csv")

plot(NM_DetSim$Time, NM_DetSim$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_DetSim$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations")
lines(NM_DetSim$Time, NM_DetSim$ImmuneCells, col = "firebrick2")
```

Now, let's use these data to fit the model. We'll start with 6 free parameters.

```{r}
## Data
NM_DetSim <- read_csv("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Data/NM_DetSim_DamOsc.csv"); head(NM_DetSim)
N <- length(NM_DetSim$Time) - 1
ts <- 1:N
y_init <- c(NM_DetSim$Parasites[1], NM_DetSim$ImmuneCells[1])
y <- as.matrix(NM_DetSim[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])

NM_DetSim <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Stan_Models/NM_DamOsc_3.stan")

## Fitting
fit <- sampling(model, data = NM_DetSim, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FitObjs/NM_DetSim_DamOsc_FitObj.rds")
```

```{r}
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FitObjs/NM_DetSim_DamOsc_FitObj.rds")

## Summarise the fit
fitSumm <- print(fit, pars = c("theta", "sigma", "z_init"),
                 probs=c(0.1, 0.5, 0.9), digits = 3)

#              mean se_mean    sd     10%     50%     90% n_eff  Rhat
# theta[1]    2.917   0.019 0.408   2.442   2.884   3.444   448 1.009
# theta[2]    0.010   0.000 0.001   0.008   0.010   0.012   466 1.009
# theta[3]    0.028   0.001 0.026   0.003   0.017   0.063   481 1.002
# theta[4]   25.357   0.404 8.647  16.058  23.771  37.188   459 1.004
# theta[5]    0.248   0.004 0.079   0.161   0.238   0.343   461 1.008
# theta[6]    0.186   0.002 0.036   0.146   0.180   0.234   405 1.006
# sigma[1]    0.573   0.001 0.044   0.518   0.569   0.629  1243 1.005
# sigma[2]    0.083   0.000 0.006   0.076   0.083   0.091  1437 1.001
# z_init[1]  52.458   0.204 7.485  43.473  51.791  62.297  1347 0.999
# z_init[2] 223.265   0.339 9.173 171.701 223.451 234.972   737 1.007

## Viz
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(fit, pars)
mcmc_pairs(fit, pars)
mcmc_dens(fit, pars)
```

For comparison, here's the fit to demographically stochastic data:

```{r}
fit <- readRDS("Chapter1Review/FitObjs/NM_DamOsc_3_FitObj.rds")

## Summarise the fit
fitSumm <- print(fit, pars = c("theta", "sigma", "z_init"),
                 probs=c(0.1, 0.5, 0.9), digits = 3)

#              mean se_mean    sd     10%     50%     90% n_eff  Rhat
# theta[1]    2.917   0.019 0.408   2.442   2.884   3.444   448 1.009
# theta[2]    0.010   0.000 0.001   0.008   0.010   0.012   466 1.009
# theta[3]    0.028   0.001 0.026   0.003   0.017   0.063   481 1.002
# theta[4]   25.357   0.404 8.647  16.058  23.771  37.188   459 1.004
# theta[5]    0.248   0.004 0.079   0.161   0.238   0.343   461 1.008
# theta[6]    0.186   0.002 0.036   0.146   0.180   0.234   405 1.006
# sigma[1]    0.573   0.001 0.044   0.518   0.569   0.629  1243 1.005
# sigma[2]    0.083   0.000 0.006   0.076   0.083   0.091  1437 1.001
# z_init[1]  52.458   0.204 7.485  43.473  51.791  62.297  1347 0.999
# z_init[2] 223.265   0.339 9.173 171.701 223.451 234.972   737 1.007

## Viz
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(fit, pars)
mcmc_pairs(fit, pars)
mcmc_dens(fit, pars)
```

## 4. Look at how changing single parameters values ($\theta$, $h$, maybe $c$) change the timeseries data

## 5. Fit NM model to a few different stochastic time series

Let's start by generating a few stochastic time series:

```{r}
# First, the original data:
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P/1 + O*P*h)", 
       "b + H*c*(O*P/1 + O*P*h)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 2.5; O = 0.008; h = 0.06; b = 35; c = 0.2; u = 0.2
parms1 <- c(r = r, O = O, h = h, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T2_Dam"
set.seed(5)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 2nd time series
set.seed(9)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc_2.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 2)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 3rd time series
set.seed(10)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc_3.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 3)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 4th time series
set.seed(13)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")

FirstZero <- which(NM_StochSim_DamOsc$Parasites == 0)[1]
NM_StochSim_DamOsc <- NM_StochSim_DamOsc[1:FirstZero - 1, ]


write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc_4.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 4)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")
```

Okay, now, let's compare these to the deterministic simulation:

```{r}
# 1st time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 1)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 2nd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_2.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 2)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 3rd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_3.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 3)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 4th time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_4.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 4)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

```

As we can see, the oscillations in Time Series 2 and Time Series 3 are pretty offset from the oscillations in the deterministic simulation. So, let's fit the model to Time Series 2, 3, and 4, and see what happens.

```{r}
# 2nd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_2.csv"); head(NM_StochSim_DamOsc)
N <- length(NM_StochSim_DamOsc$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_DamOsc$Parasites[1], NM_StochSim_DamOsc$ImmuneCells[1])
y <- as.matrix(NM_StochSim_DamOsc[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_DamOsc <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_DamOsc_3.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_DamOsc, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_DamOsc_TS2_FitObj.rds")

# 3rd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_3.csv"); head(NM_StochSim_DamOsc)
N <- length(NM_StochSim_DamOsc$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_DamOsc$Parasites[1], NM_StochSim_DamOsc$ImmuneCells[1])
y <- as.matrix(NM_StochSim_DamOsc[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_DamOsc <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_DamOsc_3.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_DamOsc, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_DamOsc_TS3_FitObj.rds")

# 4th time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_4.csv"); head(NM_StochSim_DamOsc)
N <- length(NM_StochSim_DamOsc$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_DamOsc$Parasites[1], NM_StochSim_DamOsc$ImmuneCells[1])
y <- as.matrix(NM_StochSim_DamOsc[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_DamOsc <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_DamOsc_3.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_DamOsc, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_DamOsc_TS4_FitObj.rds")
```
