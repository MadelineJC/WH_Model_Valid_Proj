---
title: "Chapter 1, Continuing"
author: "M. Jarvis-Cross"
output: html_document
---

```{r, include = FALSE}
library(readr)
library(tidyverse)
library(deSolve)
library(GillespieSSA)
library(rstan)
library(bayesplot)
library(brms)
library(reshape2)
library(MCMCvis)
```

# Models & Dynamics

+----------+---------------------+----------------------------+--------------------------+
|          | Antia et al.        | Fenton and Perkins         | Mod. Fenton and Perkins  |
+==========+=====================+============================+==========================+
| Type I   | NA                  | 1.  Stable limit cycle     | 1.  Damping oscillations |
+----------+---------------------+----------------------------+--------------------------+
| Type II  | Stable, extirpation | 1.  Stable limit cycle     | 1.  Stable limit cycle   |
|          |                     | 2.  Divergent oscillations | 2.  Damping oscillations |
+----------+---------------------+----------------------------+--------------------------+
| Type III | NA                  | 1.  Stable limit cycle     | 1.  Damping oscillations |
|          |                     | 2.  Damping oscillations   |                          |
+----------+---------------------+----------------------------+--------------------------+

# To Do:

0.  Use single microparasite models from Fenton and Perkins (*Parasitology*, 2010) to fit the unmodified model with Type I, II, and III FRs
1.  ~~Use LV model to generate stochastic data; fit BC model to those data~~
    (a) Fit modified (with $b$) Fenton and Perkins w/ a Type I FR
2.  ~~Autoregressive model: Compare true and estimated data in a plot like you did with global model to identify potential structural unidentifiability~~
3.  ~~Fit NM model to deterministic data~~
4.  Look at how changing single parameters values ($\theta$, $h$, maybe $c$) change the time series data
5.  ~~Fit NM model to a few different stochastic time series~~

## 0. Use single microparasite models from Fenton and Perkins (*Parasitology*, 2010) to do above

The proposed LV model:

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

With TI functional response, $f(P)=\beta P$

With a TII functional response, $f(P)=\frac{\beta P}{1+h \beta P}$

With a TIII functional response, $f(P)=\frac{\beta P^2}{1+h \beta P^2}$

### TI FR

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

Where, $f(P)=\beta P$

-   Is a marginally/neutrally stable system.

Now, let's simulate data:

```{r}
FP_T1 <- function(t, y, p){
  r <- p[1]; B <- p[2]; e <- p[3]; delta <- p[4]
  P <- y[1]; I <- y[2]
  dP = r*P - I*B*P
  dI = e*B*P*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; e <- 0.1; delta <- 0.01
parms <- c(r, B, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 500, 1)
results <- lsoda(N0, TT, FP_T1, parms)
FP_1_Det <- data.frame(results); colnames(FP_1_Det) <- c("Times", "P", "I")

plot(FP_1_Det$Times, FP_1_Det$P, type = "l", col = "cornflowerblue", xlab = "Time", ylab = "Population Abundance")
lines(FP_1_Det$Times, FP_1_Det$I, col = "firebrick2")
```

```{r}
x0 <- c(P = 1, I = 1) # Unity
a <- c("r*P",
       "I*B*P", 
       "e*B*P*I",
       "delta*I")
nu <- matrix(c(+1, -1, 0, 0,
               0, 0, +1, -1), nrow = 2, byrow = TRUE)

r <- 0.1; B <- 0.05; e <- 0.1; delta <- 0.01
parms <- c(r = r, B = B, e = e, delta = delta)
tf = 200
method <- "OTL"
simName <- "FP_1_Stoch"
set.seed(123)
FP_1_Stoch <- suppressWarnings(ssa(x0, a, nu, parms, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
FP_1_Stoch <- as.data.frame(FP_1_Stoch$data)
colnames(FP_1_Stoch) <- c("Time", "P", "I")
FirstZero <- which(FP_1_Stoch$P == 0)[1]
FP_1_Stoch <- FP_1_Stoch[1:FirstZero - 1, ]

plot(FP_1_Stoch$Time, FP_1_Stoch$P, type = "l", col = "cornflowerblue", main = "Demographically Stochastic FP_1_Stoch Model", sub = "Initial Conditions: At Unity", xlab = "Time", ylab = "Population Abundance")
points(FP_1_Stoch$Time, FP_1_Stoch$I, type = "l", col = "firebrick2")

## Starting at equilibrium
x0 <- c(P = 20, I = 2) # Equilibrium values: P = delta/e*B; I = r/B
set.seed(123)
FP_1_Stoch <- suppressWarnings(ssa(x0, a, nu, parms, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
FP_1_Stoch <- as.data.frame(FP_1_Stoch$data)
colnames(FP_1_Stoch) <- c("Time", "P", "I")
FirstZero <- which(FP_1_Stoch$P == 0)[1]
FP_1_Stoch <- FP_1_Stoch[1:FirstZero - 1, ]

plot(FP_1_Stoch$Time, FP_1_Stoch$P, type = "l", col = "cornflowerblue", main = "Demographically Stochastic FP_1_Stoch Model", sub = "Initial Conditions: At Equilibrium", xlab = "Time", ylab = "Population Abundance")
points(FP_1_Stoch$Time, FP_1_Stoch$I, type = "l", col = "firebrick2")
```

```{r}
## Data
N <- length(FP_1_Det$Time) - 1
ts <- 1:N
y_init <- c(FP_1_Det$P[1], FP_1_Det$I[1])
y <- as.matrix(FP_1_Det[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
FP_1_Det_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

N <- length(FP_1_Stoch$Time) - 1
ts <- 1:N
y_init <- c(FP_1_Stoch$P[1], FP_1_Stoch$I[1])
y <- as.matrix(FP_1_Stoch[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
FP_1_Stoch_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1.stan")
# model <- stan_model("Chapter1Review/FP_1.stan")

## Fit
fit <- sampling(model, data = FP_1_Det_Stan, iter = 2000, chains = 2, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Det_FitObj.rds")
# saveRDS(fit, file = "Chapter1Review/FP_1_Det_FitObj.rds")

fit <- sampling(model, data = FP_1_Stoch_Stan, iter = 2000, chains = 2, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Stoch_FitObj.rds")
# saveRDS(fit, file = "Chapter1Review/FP_1_Stoch_FitObj.rds")
```

```{r}
## Deterministic
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Det_FitObj.rds")
## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 

## Stochastic
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_1_Stoch_FitObj.rds")
## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)
#             mean se_mean    sd   10%    50%    90% n_eff  Rhat
# theta[1]   0.461   0.062 0.456 0.163  0.311  1.003    54 1.070
# theta[2]   0.061   0.009 0.067 0.018  0.039  0.131    55 1.066
# theta[3]   0.737   0.030 0.602 0.091  0.584  1.604   396 1.008
# theta[4]   0.307   0.043 0.284 0.121  0.223  0.526    43 1.083
# sigma[1]   0.425   0.005 0.098 0.316  0.407  0.553   457 1.008
# sigma[2]   0.835   0.006 0.177 0.639  0.807  1.062   803 1.001
# z_init[1]  8.142   0.100 2.312 5.615  7.816 11.005   533 1.005
# z_init[2] 14.913   0.522 6.948 7.348 13.650 24.034   177 1.020
## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 
```

```{r}
output <- rstan::extract(fit, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
# NM_1_Det
N <- length(NM_1_Det$Time) - 1
ts <- 1:N
y_init <- c(NM_1_Det$P[1], NM_1_Det$I[1])
y <- as.matrix(NM_1_Det[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts[1:200], df$P[1:200], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:200], df$I[1:200], col = "red4")
lines(df$ts[1:200], df$post_means_P[1:200], col = "cornflowerblue")
lines(df$ts[1:200], df$post_means_I[1:200], col = "firebrick2")

plot(df$ts[1:2000], df$P[1:2000], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:2000], df$I[1:2000], col = "red4")
lines(df$ts[1:2000], df$post_means_P[1:2000], col = "cornflowerblue")
lines(df$ts[1:2000], df$post_means_I[1:2000], col = "firebrick2")
```

### TII FR

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

Where, $f(P)=\frac{\beta P}{1+h \beta P}$

-   An unstable system that produces divergent oscillations.

Now, let's simulate data:

#### Oscillations

```{r}
NM_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; h <- 0; e <- 0.1; delta <- 0.01
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 5000, 0.1)
results <- lsoda(N0, TT, NM_T2, parms)
NM_2_Det <- data.frame(results); colnames(NM_2_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_2_Det[ ,2:3])

plot(NM_2_Det$Times, NM_2_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_2_Det$Times, NM_2_Det$I, col = "firebrick2")

plot(NM_2_Det$Times[0:20001], NM_2_Det$P[0:20001], type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_2_Det$Times[0:20001], NM_2_Det$I[0:20001], col = "firebrick2")

P_Max <- max(NM_2_Det$P); P_left <- P_Max - 0.0001; P_right <- P_Max + 0.0001
plot(NM_2_Det$Times, NM_2_Det$P, type = "l", col = "cornflowerblue", ylim = c(P_left, P_right), xlab = "Time", ylab = "Population Abundance")

I_Max <- max(NM_2_Det$I); I_left <- I_Max - 0.00001; I_right <- I_Max + 0.00001
plot(NM_2_Det$Times, NM_2_Det$I, type = "l", col = "firebrick2", ylim = c(I_left, I_right), xlab = "Time", ylab = "Population Abundance")
```

#### Divergent Oscillations

```{r}
NM_T2 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P/(1 + h*B*P))
  dI = e*(B*P/(1 + h*B*P))*I-delta*I
  list(c(dP, dI))
}
r <- 0.05; B <- 0.05; h <- 0.1; e <- 0.1; delta <- 0.01
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 5000, 0.1)
results <- lsoda(N0, TT, NM_T2, parms)
NM_2_Det <- data.frame(results); colnames(NM_2_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_2_Det[ ,2:3])

plot(NM_2_Det$Times, NM_2_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_2_Det$Times, NM_2_Det$I, col = "firebrick2")
```

### TIII FR

$\frac{dP}{dt}=rP-If(P)$

$\frac{dI}{dt}=ef(P)I - \delta I$

Where, $f(P)=\frac{\beta P^2}{1+h \beta P^2}$

-   Stable when: $e>2 \delta h$

Now, let's simulate data:

#### Oscillations

```{r}
NM_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 0.04; B <- 0.05; h <- 10; e <- 0.2; delta <- 0.01; print(e > 2*delta*h)
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, NM_T3, parms)
NM_3_Det <- data.frame(results); colnames(NM_3_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_3_Det[ ,2:3])

plot(NM_3_Det$Times, NM_3_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_3_Det$Times, NM_3_Det$I, col = "firebrick2")
```

#### Damping Oscillations

```{r}
NM_T3 <- function(t, y, p){
  r <- p[1]; B <- p[2]; h <- p[3]; e <- p[4]; delta <- p[5]
  P <- y[1]; I <- y[2]
  dP = r*P - I*(B*P^2/(1 + h*B*P^2))
  dI = e*(B*P^2/(1 + h*B*P^2))*I-delta*I
  list(c(dP, dI))
}
r <- 0.1; B <- 0.05; h <- 2.5; e <- 0.1; delta <- 0.008; print(e > 2*delta*h)
parms <- c(r, B, h, e, delta)
P0 <- 1; I0 <- 1
N0 <- c(P0, I0)
TT <- seq(0, 1000, 0.1)
results <- lsoda(N0, TT, NM_T3, parms)
NM_3_Det <- data.frame(results); colnames(NM_3_Det) <- c("Times", "P", "I")
Abun <- data.frame(NM_3_Det[ ,2:3])

plot(NM_3_Det$Times, NM_3_Det$P, type = "l", col = "cornflowerblue", ylim = c(0, max(Abun)), xlab = "Time", ylab = "Population Abundance")
lines(NM_3_Det$Times, NM_3_Det$I, col = "firebrick2")
```

```{r}
x0 <- c(P = 1, I = 1) 
a <- c("r*P",
       "I*(B*P^2/(1 + h*B*P^2))", 
       "e*(B*P^2/(1 + h*B*P^2))*I",
       "delta*I")
nu <- matrix(c(+1, -1, 0, 0,
               0, 0, +1, -1), nrow = 2, byrow = TRUE)

r <- 0.1; B <- 0.05; h <- 2.5; e <- 0.1; delta <- 0.008
parms <- c(r = r, B = B, h = h, e = e, delta = delta)
tf = 500
method <- "OTL"
simName <- "FP_TypeI"
set.seed(1)
FP_TypeI <- suppressWarnings(ssa(x0, a, nu, parms, tf, method, simName,
                                  verbose = FALSE, 
                                  consoleInterval = 1, 
                                  censusInterval = 1, 
                                  maxWallTime = 30, 
                                  ignoreNegativeState = TRUE)) 
FP_TypeI <- as.data.frame(FP_TypeI$data)
colnames(FP_TypeI) <- c("Time", "P", "I")

FirstZero <- which(FP_TypeI$P == 0)[1]
FP_TypeI <- FP_TypeI[1:FirstZero - 1, ]

#write_csv(LV_StochSim, file = "Chapter1Review/Data/LV_StochSim.csv")

plot(FP_TypeI$Time, FP_TypeI$P, type = "l", col = "cornflowerblue", main = "Demographically Stochastic FP_TypeI Model", xlab = "Time", ylab = "Population Abundance")
points(FP_TypeI$Time, FP_TypeI$I, type = "l", col = "firebrick2")
```

```{r}
## Data
N <- length(NM_3_Det$Time) - 1
ts <- 1:N
y_init <- c(NM_3_Det$P[1], NM_3_Det$I[1])
y <- as.matrix(NM_3_Det[2:(N + 1), 2:3])
y <- cbind(y[ , 2], y[ , 1])
NM_3_Det_Stan <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_Type3.stan")

## Fit
fit <- sampling(model, data = NM_3_Det_Stan, iter = 4000, chains = 2, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_Type3_FitObj.rds")
```

```{r}
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FP_Type3_FitObj.rds")

## Summarise the fit
print(fit, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

#             mean se_mean    sd   10%    50%    90% n_eff  Rhat
# theta[1]   0.702   0.024 0.406 0.289  0.605  1.215   275 1.006
# theta[2]   0.014   0.001 0.044 0.004  0.010  0.027  2215 1.000
# theta[3]   1.317   0.060 0.841 0.365  1.204  2.374   199 1.010
# theta[4]   1.448   0.031 0.677 0.629  1.382  2.306   470 1.000
# theta[5]   0.407   0.015 0.233 0.171  0.363  0.706   242 1.001
# sigma[1]   1.625   0.053 0.450 1.140  1.532  2.273    74 1.026
# sigma[2]   0.993   0.017 0.251 0.691  0.959  1.319   208 1.004
# z_init[1] 11.925   0.301 6.847 5.275 10.480 19.460   518 1.003
# z_init[2]  9.523   0.412 6.590 3.756  8.063 16.882   255 1.008

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]")
stan_trace(fit, pars = pars)
mcmc_pairs(fit, pars = pars)
mcmc_dens(fit, pars = pars) 
```

```{r}
output <- rstan::extract(fit, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),
                                    .fns = mean))
# Parse df by P and I
ncol(z_means); x <- ncol(z_means)/2
z_means_P <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_P) 
z_means_I <- z_means[-c(1:x)]  
ncol(z_means_I)
# Invert dfs
z_means_P <- t(z_means_P)
z_means_I <- t(z_means_I)
# Re-name columns 
colnames(z_means_P) <- c("post_means_P")
colnames(z_means_I) <- c("post_means_I")

## "Real data" ##
# NM_1_Det
N <- length(NM_3_Det$Time) - 1
ts <- 1:N
y_init <- c(NM_3_Det$P[1], NM_3_Det$I[1])
y <- as.matrix(NM_3_Det[2:(N + 1), 2:3])
head(y) # Recall that y is the data we gave the model (our stochastic data)
y_df <- data.frame(y)
colnames(y_df) <- c("P","I")

# Merge dfs
df <- cbind(z_means_P,z_means_I,y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(df,ts)

plot(df$ts[1:200], df$P[1:200], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:200], df$I[1:200], col = "red4")
lines(df$ts[1:200], df$post_means_P[1:200], col = "cornflowerblue")
lines(df$ts[1:200], df$post_means_I[1:200], col = "firebrick2")

plot(df$ts[1:2000], df$P[1:2000], type = "l", col = "navy", ylim = c(0, 150), xlab = "Time", ylab = "Population Abundance")
lines(df$ts[1:2000], df$I[1:2000], col = "red4")
lines(df$ts[1:2000], df$post_means_P[1:2000], col = "cornflowerblue")
lines(df$ts[1:2000], df$post_means_I[1:2000], col = "firebrick2")
```

## 1. Use LV model to generate stochastic data; fit BC model to those data

The proposed LV model:

$\frac{du}{dt} = (\alpha - \beta v)u$

$\frac{dv}{dt} = (-\gamma + \delta u)v$

```{r}
LV_Model <- function(t, y, p){
  alpha <- p[1]; beta <- p[2]; gamma <- p[3]; delta <- p[4] 
  u <- y[1]; v <- y[2]
  du = (alpha - beta * v) * u
  dv = (-gamma + delta * u) * v
  list(c(du, dv))
}
alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024 # From posterior estimates
parms <- c(alpha, beta, gamma, delta)
TT <- seq(1, 21, 1) # Twenty years, assessed every year

u0 <- 30; v0 <- 4 # In thousands, as per Carpenter
N0 <- c(u0, v0)
results <- lsoda(N0, TT, LV_Model, parms, verbose = FALSE)
LV_DetSim_BC <- data.frame(results); colnames(LV_DetSim_BC) <- c("Time", "Hare", "Lynx")

u0 <- 33.956; v0 <- 5.933 # As estimate by model
N0 <- c(u0, v0)
results <- lsoda(N0, TT, LV_Model, parms, verbose = FALSE)
LV_DetSim_Est <- data.frame(results); colnames(LV_DetSim_Est) <- c("Time", "Hare", "Lynx")

hare_lynx_df <- read_csv("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/hudson-bay-lynx-hare.csv")

plot(LV_DetSim_BC$Time, LV_DetSim_BC$Lynx, type = "l", main = "Deterministic LV Model", sub = "Initial Conditions: As per Carpenter or as Estimated by Model", xlab = "Time", ylab = "Population Abundance", ylim = c(0, 100), col = "firebrick2", lwd = 2)
points(LV_DetSim_BC$Time, LV_DetSim_BC$Hare, type = "l", col = "orchid", lwd = 2)
points(1:21, hare_lynx_df$Lynx, type = "l", col = "firebrick2", lwd = 2, lty = 2)
points(1:21, hare_lynx_df$Hare, type = "l", col = "orchid", lwd = 2, lty = 2)
points(1:21, LV_DetSim_Est$Lynx, type = "l", col = "firebrick2", lwd = 2, lty = 3)
points(1:21, LV_DetSim_Est$Hare, type = "l", col = "orchid", lwd = 2, lty = 3)
legend("topright", legend = c("Deterministic", "Data", "Estimate"), lwd = 2, lty = c(1, 2, 3))
```

Now, let's generate some stochastic data:

```{r}
x0 <- c(u = 30, v = 4) # Given by Carpenter
a <- c("alpha*u",
       "beta*v*u", 
       "gamma*v",
       "delta*u*v")
nu <- matrix(c(+1, -1, 0, 0,
               0, 0, -1, +1), nrow = 2, byrow = TRUE)
alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024
parms1 <- c(alpha = alpha, beta = beta, gamma = gamma, delta = delta)
tf = 20
method <- "OTL"
simName <- "LV"

Seeds <- c(1, 3, 4, 5, 7); BC_Stoch_List <- list()
for (i in 1:length(Seeds)){
  set.seed(Seeds[i])
  BC_Stoch <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                    verbose = FALSE, 
                                    consoleInterval = 1, 
                                    censusInterval = 1, 
                                    maxWallTime = 30, 
                                    ignoreNegativeState = TRUE)) 
  BC_Stoch <- BC_Stoch$data; BC_Stoch <- as.data.frame(BC_Stoch)
  colnames(BC_Stoch) <- c("Time", "Hare", "Lynx")
  FirstZero <- which(BC_Stoch$Lynx == 0)[1]
  if (is.na(FirstZero)){
    BC_Stoch_List[[i]] <- BC_Stoch
  } else {
    BC_Stoch <- BC_Stoch[1:FirstZero - 1, ]
    BC_Stoch_List[[i]] <- BC_Stoch
  }
}

plot(hare_lynx_df$Year, hare_lynx_df$Hare, type = "l", main = "Stochastic LV Model (Five Implementations)", sub = "Initial Conditions: As per Carpenter", xlab = "Time", ylab = "Population Abundance", ylim = c(0, 120), col = "orchid", lwd = 2)
lines(hare_lynx_df$Year, hare_lynx_df$Lynx, col = "firebrick2", lwd = 2)
lines(hare_lynx_df$Year, BC_Stoch_List[[1]]$Hare, col = "orchid", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[1]]$Lynx, col = "firebrick2", lwd = 2, lty = 3)
lines(1:19, BC_Stoch_List[[2]]$Hare, col = "orchid", lwd = 2, lty = 3)
lines(1:19, BC_Stoch_List[[2]]$Lynx, col = "firebrick2", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[3]]$Hare, col = "orchid", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[3]]$Lynx, col = "firebrick2", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[4]]$Hare, col = "orchid", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[4]]$Lynx, col = "firebrick2", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[5]]$Hare, col = "orchid", lwd = 2, lty = 3)
lines(hare_lynx_df$Year, BC_Stoch_List[[5]]$Lynx, col = "firebrick2", lwd = 2, lty = 3)
```

Okay, now let's fit the LV model to our generated data:

```{r, eval = FALSE}
## Data
BC_StanData_List <- list()
for (i in 1:length(Seeds)){
  BC_Stoch <- BC_Stoch_List[[i]]
  N <- length(BC_Stoch$Time) - 1
  ts <- 1:N
  y_init <- c(BC_Stoch$Hare[1], BC_Stoch$Lynx[1])
  y <- as.matrix(BC_Stoch[2:(N + 1), 2:3])
  y <- cbind(y[ , 1], y[ , 2]); 
  BC_StanData <- list(N = N, ts = ts, y_init = y_init, y = y)
  BC_StanData_List[[i]] <- BC_StanData
}

## Compile model
model <- stan_model("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/lotka-volterra.stan")

## Fit
Fit_1 <- sampling(model, data = BC_StanData_List[[1]], iter = 2000, chains = 4, cores = 4, seed = 123)
Fit_2 <- sampling(model, data = BC_StanData_List[[2]], iter = 2000, chains = 4, cores = 4, seed = 123)
Fit_3 <- sampling(model, data = BC_StanData_List[[3]], iter = 2000, chains = 4, cores = 4, seed = 123)
Fit_4 <- sampling(model, data = BC_StanData_List[[4]], iter = 2000, chains = 4, cores = 4, seed = 123)
Fit_5 <- sampling(model, data = BC_StanData_List[[5]], iter = 2000, chains = 4, cores = 4, seed = 123)

saveRDS(Fit_1, file = "3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_1.rds")
saveRDS(Fit_2, file = "3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_2.rds")
saveRDS(Fit_3, file = "3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_3.rds")
saveRDS(Fit_4, file = "3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_4.rds")
saveRDS(Fit_5, file = "3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_5.rds")
```

```{r}
## Summarise the fit
Fit_1 <- readRDS("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_1.rds")
print(Fit_1, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd    10%    50%    90% n_eff  Rhat
# theta[1]   0.591   0.003 0.094  0.478  0.586  0.709  1058 1.002
# theta[2]   0.035   0.000 0.008  0.025  0.034  0.045  1223 1.003
# theta[3]   0.626   0.003 0.108  0.499  0.616  0.760  1089 1.002
# theta[4]   0.019   0.000 0.005  0.014  0.019  0.025  1203 1.002
# sigma[1]   0.467   0.002 0.085  0.369  0.457  0.582  2446 1.001
# sigma[2]   0.448   0.002 0.082  0.357  0.437  0.554  2312 1.000
# z_init[1] 17.960   0.061 2.845 14.422 17.802 21.781  2209 1.001
# z_init[2]  5.190   0.019 0.837  4.164  5.139  6.299  2002 1.002

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(Fit_1, pars = pars)
mcmc_pairs(Fit_1, pars = pars)
mcmc_dens(Fit_1, pars = pars) 

## Summarise the fit
Fit_2 <- readRDS("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_2.rds")
print(Fit_2, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd    10%    50%    90% n_eff  Rhat
# theta[1]   0.656   0.003 0.122  0.512  0.645  0.811  1253 1.000
# theta[2]   0.037   0.000 0.010  0.026  0.035  0.049  1419 1.000
# theta[3]   0.911   0.005 0.164  0.717  0.896  1.123  1273 1.000
# theta[4]   0.030   0.000 0.007  0.022  0.029  0.040  1329 1.000
# sigma[1]   0.423   0.002 0.077  0.337  0.412  0.525  2256 1.000
# sigma[2]   0.440   0.002 0.083  0.345  0.429  0.549  2244 1.000
# z_init[1] 33.067   0.116 5.915 25.824 32.664 40.873  2621 1.001
# z_init[2]  5.067   0.018 0.793  4.145  4.998  6.054  1876 1.001

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(Fit_2, pars = pars)
mcmc_pairs(Fit_2, pars = pars)
mcmc_dens(Fit_2, pars = pars) 

## Summarise the fit
Fit_3 <- readRDS("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_3.rds")
print(Fit_3, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd    10%    50%    90% n_eff  Rhat
# theta[1]   0.611   0.002 0.078  0.516  0.607  0.713  1455 1.001
# theta[2]   0.031   0.000 0.005  0.025  0.031  0.038  1612 1.001
# theta[3]   0.780   0.002 0.088  0.673  0.773  0.891  1329 1.002
# theta[4]   0.022   0.000 0.005  0.017  0.022  0.029  1439 1.001
# sigma[1]   0.506   0.002 0.083  0.410  0.494  0.615  2612 1.000
# sigma[2]   0.290   0.001 0.053  0.229  0.283  0.358  2171 1.001
# z_init[1] 29.157   0.084 4.135 24.015 28.958 34.459  2449 1.000
# z_init[2]  3.369   0.009 0.386  2.909  3.341  3.847  2041 1.002

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(Fit_3, pars = pars)
mcmc_pairs(Fit_3, pars = pars)
mcmc_dens(Fit_3, pars = pars) 

## Summarise the fit
Fit_4 <- readRDS("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_4.rds")
print(Fit_4, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd    10%    50%    90% n_eff  Rhat
# theta[1]   0.528   0.003 0.082  0.432  0.518  0.634  1043 1.002
# theta[2]   0.031   0.000 0.009  0.021  0.030  0.042  1228 1.001
# theta[3]   0.881   0.004 0.140  0.708  0.878  1.064  1078 1.002
# theta[4]   0.027   0.000 0.006  0.020  0.027  0.035  1191 1.002
# sigma[1]   0.369   0.001 0.067  0.294  0.361  0.458  2698 1.000
# sigma[2]   0.598   0.002 0.103  0.479  0.584  0.731  2563 1.001
# z_init[1] 31.989   0.104 4.702 26.337 31.645 37.979  2055 1.001
# z_init[2]  3.001   0.014 0.618  2.282  2.931  3.793  1845 1.002

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(Fit_4, pars = pars)
mcmc_pairs(Fit_4, pars = pars)
mcmc_dens(Fit_4, pars = pars) 

## Summarise the fit
Fit_5 <- readRDS("3_Extras/Old/Chapter1Review/Bob-Carpenter_Example/FitObj_5.rds")
print(Fit_5, pars = c("theta", "sigma", "z_init"),
      probs = c(0.1, 0.5, 0.9), digits = 3)

# "True" values: alpha <- 0.545; beta <- 0.028; gamma <- 0.803; delta <- 0.024

#             mean se_mean    sd    10%    50%    90% n_eff  Rhat
# theta[1]   0.426   0.002 0.052  0.363  0.423  0.493  1191 1.002
# theta[2]   0.023   0.000 0.005  0.017  0.023  0.030  1406 1.002
# theta[3]   1.265   0.005 0.161  1.070  1.255  1.472  1145 1.002
# theta[4]   0.038   0.000 0.006  0.031  0.038  0.046  1221 1.003
# sigma[1]   0.249   0.001 0.045  0.198  0.243  0.309  2361 1.003
# sigma[2]   0.470   0.002 0.080  0.379  0.460  0.573  2774 0.999
# z_init[1] 31.554   0.055 2.877 28.067 31.408 35.314  2760 1.001
# z_init[2]  3.196   0.010 0.480  2.621  3.155  3.823  2199 1.000

## Viz
pars = c("theta[1]", "theta[2]", "theta[3]", "theta[4]")
stan_trace(Fit_5, pars = pars)
mcmc_pairs(Fit_5, pars = pars)
mcmc_dens(Fit_5, pars = pars) 
```

Let's compare the "real" data to the estimation.

```{r}
#### Fit 1 ####
## Model estimates
output <- rstan::extract(Fit_1, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
y_init_rep <- output$y_init_rep; y_init_Hare <- mean(y_init_rep[ , 1]); y_init_Lynx <- mean(y_init_rep[ , 2])
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),                                    .fns = mean))
# Parse df
ncol(z_means); x <- ncol(z_means)/2
z_means_Hare <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_Hare) 
z_means_Lynx <- z_means[-c(1:x)]  
ncol(z_means_Lynx)
# Invert dfs
z_means_Hare <- t(z_means_Hare)
z_means_Lynx <- t(z_means_Lynx)
# Add estimated initial values
z_means_Hare <- rbind(y_init_Hare, z_means_Hare)
z_means_Lynx <- rbind(y_init_Lynx, z_means_Lynx)
# Re-name columns 
colnames(z_means_Hare) <- c("post_means_Hare")
colnames(z_means_Lynx) <- c("post_means_Lynx")
## "Real data" ##
y_df <- data.frame(BC_Stoch_List[[1]][ , 2:3])
colnames(y_df) <- c("Hare","Lynx")
# Merge dfs
df <- cbind(z_means_Hare,z_means_Lynx, hare_lynx_df$Hare, hare_lynx_df$Lynx, y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(ts, df)
colnames(df) <- c("Time", "Hare_Est", "Lynx_Est", "Hare_EmpDat", "Lynx_EmpDat", "Hare_StochGen", "Lynx_StochGen")

plot(df$Time, df$Hare_EmpDat, 
     main = "Stochastically Generated Time Series #1", xlab = "Time", ylab = "Abundance", 
     ylim = c(0, 120), type = "l", 
     col = "firebrick2", lwd = 2)
lines(df$Time, df$Lynx_EmpDat, col = "orchid", lwd = 2)
lines(df$Time, df$Hare_StochGen, col = "firebrick2", lwd = 2, lty = 2)
lines(df$Time, df$Lynx_StochGen, col = "orchid", lwd = 2, lty = 2)
lines(df$Time, df$Hare_Est, col = "firebrick2", lwd = 2, lty = 3)
lines(df$Time, df$Lynx_Est, col = "orchid", lwd = 2, lty = 3)
# legend("topright", legend = c("Empirical Data", "Stochastically Generated Data", "Model Estimates"),
#        lwd = 2, lty = c(1, 2, 3))

#### Fit 2 ####
## Model estimates
output <- rstan::extract(Fit_2, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
y_init_rep <- output$y_init_rep; y_init_Hare <- mean(y_init_rep[ , 1]); y_init_Lynx <- mean(y_init_rep[ , 2])
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),                                    .fns = mean))
# Parse df
ncol(z_means); x <- ncol(z_means)/2
z_means_Hare <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_Hare) 
z_means_Lynx <- z_means[-c(1:x)]  
ncol(z_means_Lynx)
# Invert dfs
z_means_Hare <- t(z_means_Hare)
z_means_Lynx <- t(z_means_Lynx)
# Add estimated initial values
z_means_Hare <- rbind(y_init_Hare, z_means_Hare)
z_means_Lynx <- rbind(y_init_Lynx, z_means_Lynx)
# Re-name columns 
colnames(z_means_Hare) <- c("post_means_Hare")
colnames(z_means_Lynx) <- c("post_means_Lynx")
## "Real data" ##
y_df <- data.frame(BC_Stoch_List[[2]][ , 2:3])
colnames(y_df) <- c("Hare","Lynx")
# Merge dfs
df <- cbind(z_means_Hare,z_means_Lynx, hare_lynx_df$Hare[1:19], hare_lynx_df$Lynx[1:19], y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(ts, df)
colnames(df) <- c("Time", "Hare_Est", "Lynx_Est", "Hare_EmpDat", "Lynx_EmpDat", "Hare_StochGen", "Lynx_StochGen")
plot(df$Time, df$Hare_EmpDat, 
     main = "Stochastically Generated Time Series #2", xlab = "Time", ylab = "Abundance", 
     ylim = c(0, 120), type = "l", 
     col = "firebrick2", lwd = 2)
lines(df$Time, df$Lynx_EmpDat, col = "orchid", lwd = 2)
lines(df$Time, df$Hare_StochGen, col = "firebrick2", lwd = 2, lty = 2)
lines(df$Time, df$Lynx_StochGen, col = "orchid", lwd = 2, lty = 2)
lines(df$Time, df$Hare_Est, col = "firebrick2", lwd = 2, lty = 3)
lines(df$Time, df$Lynx_Est, col = "orchid", lwd = 2, lty = 3)
# legend("topright", legend = c("Empirical Data", "Stochastically Generated Data", "Model Estimates"),
#        lwd = 2, lty = c(1, 2, 3))

#### Fit 3 ####
## Model estimates
output <- rstan::extract(Fit_3, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
y_init_rep <- output$y_init_rep; y_init_Hare <- mean(y_init_rep[ , 1]); y_init_Lynx <- mean(y_init_rep[ , 2])
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),                                    .fns = mean))
# Parse df
ncol(z_means); x <- ncol(z_means)/2
z_means_Hare <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_Hare) 
z_means_Lynx <- z_means[-c(1:x)]  
ncol(z_means_Lynx)
# Invert dfs
z_means_Hare <- t(z_means_Hare)
z_means_Lynx <- t(z_means_Lynx)
# Add estimated initial values
z_means_Hare <- rbind(y_init_Hare, z_means_Hare)
z_means_Lynx <- rbind(y_init_Lynx, z_means_Lynx)
# Re-name columns 
colnames(z_means_Hare) <- c("post_means_Hare")
colnames(z_means_Lynx) <- c("post_means_Lynx")
## "Real data" ##
y_df <- data.frame(BC_Stoch_List[[3]][ , 2:3])
colnames(y_df) <- c("Hare","Lynx")
# Merge dfs
df <- cbind(z_means_Hare,z_means_Lynx, hare_lynx_df$Hare, hare_lynx_df$Lynx, y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(ts, df)
colnames(df) <- c("Time", "Hare_Est", "Lynx_Est", "Hare_EmpDat", "Lynx_EmpDat", "Hare_StochGen", "Lynx_StochGen")
plot(df$Time, df$Hare_EmpDat, 
     main = "Stochastically Generated Time Series #3", xlab = "Time", ylab = "Abundance", 
     ylim = c(0, 120), type = "l", 
     col = "firebrick2", lwd = 2)
lines(df$Time, df$Lynx_EmpDat, col = "orchid", lwd = 2)
lines(df$Time, df$Hare_StochGen, col = "firebrick2", lwd = 2, lty = 2)
lines(df$Time, df$Lynx_StochGen, col = "orchid", lwd = 2, lty = 2)
lines(df$Time, df$Hare_Est, col = "firebrick2", lwd = 2, lty = 3)
lines(df$Time, df$Lynx_Est, col = "orchid", lwd = 2, lty = 3)
legend("topright", legend = c("Empirical Data", "Stochastically Generated Data", "Model Estimates"),
       lwd = 2, lty = c(1, 2, 3))

#### Fit 4 ####
## Model estimates
output <- rstan::extract(Fit_4, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
y_init_rep <- output$y_init_rep; y_init_Hare <- mean(y_init_rep[ , 1]); y_init_Lynx <- mean(y_init_rep[ , 2])
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),                                    .fns = mean))
# Parse df
ncol(z_means); x <- ncol(z_means)/2
z_means_Hare <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_Hare) 
z_means_Lynx <- z_means[-c(1:x)]  
ncol(z_means_Lynx)
# Invert dfs
z_means_Hare <- t(z_means_Hare)
z_means_Lynx <- t(z_means_Lynx)
# Add estimated initial values
z_means_Hare <- rbind(y_init_Hare, z_means_Hare)
z_means_Lynx <- rbind(y_init_Lynx, z_means_Lynx)
# Re-name columns 
colnames(z_means_Hare) <- c("post_means_Hare")
colnames(z_means_Lynx) <- c("post_means_Lynx")
## "Real data" ##
y_df <- data.frame(BC_Stoch_List[[4]][ , 2:3])
colnames(y_df) <- c("Hare","Lynx")
# Merge dfs
df <- cbind(z_means_Hare,z_means_Lynx, hare_lynx_df$Hare, hare_lynx_df$Lynx, y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(ts, df)
colnames(df) <- c("Time", "Hare_Est", "Lynx_Est", "Hare_EmpDat", "Lynx_EmpDat", "Hare_StochGen", "Lynx_StochGen")
plot(df$Time, df$Hare_EmpDat, 
     main = "Stochastically Generated Time Series #4", xlab = "Time", ylab = "Abundance", 
     ylim = c(0, 120), type = "l", 
     col = "firebrick2", lwd = 2)
lines(df$Time, df$Lynx_EmpDat, col = "orchid", lwd = 2)
lines(df$Time, df$Hare_StochGen, col = "firebrick2", lwd = 2, lty = 2)
lines(df$Time, df$Lynx_StochGen, col = "orchid", lwd = 2, lty = 2)
lines(df$Time, df$Hare_Est, col = "firebrick2", lwd = 2, lty = 3)
lines(df$Time, df$Lynx_Est, col = "orchid", lwd = 2, lty = 3)
legend("topright", legend = c("Empirical Data", "Stochastically Generated Data", "Model Estimates"),
       lwd = 2, lty = c(1, 2, 3))

#### Fit 5 ####
## Model estimates
output <- rstan::extract(Fit_5, permuted = TRUE, include = TRUE)
y_rep <- output$y_rep
y_init_rep <- output$y_init_rep; y_init_Hare <- mean(y_init_rep[ , 1]); y_init_Lynx <- mean(y_init_rep[ , 2])
z_df <- data.frame(y_rep)
z_means = z_df %>% summarise(across(.cols = everything(),                                    .fns = mean))
# Parse df
ncol(z_means); x <- ncol(z_means)/2
z_means_Hare <- z_means[-c(x + 1:ncol(z_means))]
ncol(z_means_Hare) 
z_means_Lynx <- z_means[-c(1:x)]  
ncol(z_means_Lynx)
# Invert dfs
z_means_Hare <- t(z_means_Hare)
z_means_Lynx <- t(z_means_Lynx)
# Add estimated initial values
z_means_Hare <- rbind(y_init_Hare, z_means_Hare)
z_means_Lynx <- rbind(y_init_Lynx, z_means_Lynx)
# Re-name columns 
colnames(z_means_Hare) <- c("post_means_Hare")
colnames(z_means_Lynx) <- c("post_means_Lynx")
## "Real data" ##
y_df <- data.frame(BC_Stoch_List[[5]][ , 2:3])
colnames(y_df) <- c("Hare","Lynx")
# Merge dfs
df <- cbind(z_means_Hare,z_means_Lynx, hare_lynx_df$Hare, hare_lynx_df$Lynx, y_df)
# Add time steps
ts <- seq(nrow(df))
ts <- data.frame(ts)
# Final df
df <- cbind(ts, df)
colnames(df) <- c("Time", "Hare_Est", "Lynx_Est", "Hare_EmpDat", "Lynx_EmpDat", "Hare_StochGen", "Lynx_StochGen")
plot(df$Time, df$Hare_EmpDat, 
     main = "Stochastically Generated Time Series #5", xlab = "Time", ylab = "Abundance", 
     ylim = c(0, 120), type = "l", 
     col = "firebrick2", lwd = 2)
lines(df$Time, df$Lynx_EmpDat, col = "orchid", lwd = 2)
lines(df$Time, df$Hare_StochGen, col = "firebrick2", lwd = 2, lty = 2)
lines(df$Time, df$Lynx_StochGen, col = "orchid", lwd = 2, lty = 2)
lines(df$Time, df$Hare_Est, col = "firebrick2", lwd = 2, lty = 3)
lines(df$Time, df$Lynx_Est, col = "orchid", lwd = 2, lty = 3)
legend("topright", legend = c("Empirical Data", "Stochastically Generated Data", "Model Estimates"),
       lwd = 2, lty = c(1, 2, 3))
```

### Outcome:

Works well! As such, oscillatory data doesn't seem to be the problem. Rather, the complexity of the Fenton and Perkins model seems to give rise unidentifiability/trouble with validation.

### (a) Fit NM with Type I (rather than Type II) functional response to data

Okay, so with a Type I functional response, the model would look something like this:

$\frac{dP}{dt} = rP - (\theta P)H$

$\frac{dH}{dt} = b + (c(\theta P) - \mu)H$

With a Type I FR *without* $b$, we see a neutrally stable model. When we add $b$, we get damping oscillations.

Let's simulate some data:

```{r}
NM_T1 <- function(t,y,p){
  r <- p[1]; O <- p[2]; c <- p[3]; u <- p[4]
  P <- y[1]; H <- y[2]
  dP = r*P - H*O*P
  dH = H*(c*O*P - u)
  list(c(dP, dH))
}
r <- 0.1; O <- 0.05; c <- 0.1; u <- 0.01
parms <- c(r, O, c, u)
P0 <- 1; H0 <- 1
N0 <- c(P0, H0)
TT <- seq(0, 1000, 0.1) 
results <- lsoda(N0, TT, NM_T1, parms)
NM_Det <- data.frame(results); colnames(NM_Det) <- c("Time", "P", "H")

plot(NM_Det$Time, NM_Det$P, type = "l", col = "cornflowerblue", xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (Without b)")
lines(NM_Det$Time, NM_Det$H, col = "firebrick2")

## With b (1st Parameterization)
NowakMay_T1 <- function(t,y,p){
  r <- p[1]; O <- p[2]; b <- p[3]; c <- p[4]; u <- p[5]
  P <- y[1]; H <- y[2]
  dP = P*r - H*(O*P)
  dH = b + H*(c*(O*P) - u)
  list(c(dP,dH))
}
r <- 1.5; O <- 0.001; b <- 200; c <- 0.9; u <- 0.2
parms <- c(r, O, b, c, u)
P0 <- 1; H0 <- 1
N0 <- c(P0, H0)
TT <- seq(0, 100, 0.1) 
results <- lsoda(N0, TT, NowakMay_T1, parms)
NM_DetSim <- data.frame(results); colnames(NM_DetSim) <- c("Time", "Parasites", "ImmuneCells")

plot(NM_DetSim$Time, NM_DetSim$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_DetSim$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (With b (1st Parameterization))")
lines(NM_DetSim$Time, NM_DetSim$ImmuneCells, col = "firebrick2")
```

Now, for some stochastic implementations:

```{r}
## Without b
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P)", 
       "H*c*(O*P)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r <- 1; O <- 0.001; c <- 0.8; u <- 0.2
parms1 <- c(r = r, O = O, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T1"
set.seed(4)
NowakMay_T1 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_T1 <- NowakMay_T1$data 
NM_StochSim_T1 <- as.data.frame(NM_StochSim_T1)
colnames(NM_StochSim_T1) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_T1, file = "Chapter1Review/Data/NM_StochSim_T1_1.csv")

plot(NM_StochSim_T1$Time, NM_StochSim_T1$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_T1$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (Without b)")
lines(NM_StochSim_T1$Time, NM_StochSim_T1$ImmuneCells, col = "firebrick2")

## With b (1st Parameterization)
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P)", 
       "b + H*c*(O*P)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r <- 2; O <- 0.001; b <- 200; c <- 1; u <- 0.3
parms1 <- c(r = r, O = O, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T1"
set.seed(2)
NowakMay_T1 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_T1 <- NowakMay_T1$data 
NM_StochSim_T1 <- as.data.frame(NM_StochSim_T1)
colnames(NM_StochSim_T1) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_T1, file = "Chapter1Review/Data/NM_StochSim_T1_2.csv")

plot(NM_StochSim_T1$Time, NM_StochSim_T1$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_T1$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (With b (1st Parameterization))")
lines(NM_StochSim_T1$Time, NM_StochSim_T1$ImmuneCells, col = "firebrick2")

## With b (2nd Parameterization)
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P)", 
       "b + H*c*(O*P)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r <- 1; O <- 0.001; b <- 200; c <- 1; u <- 0.2
parms1 <- c(r = r, O = O, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T1"
set.seed(1)
NowakMay_T1 <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_T1 <- NowakMay_T1$data 
NM_StochSim_T1 <- as.data.frame(NM_StochSim_T1)
colnames(NM_StochSim_T1) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_T1, file = "Chapter1Review/Data/NM_StochSim_T1_3.csv")

plot(NM_StochSim_T1$Time, NM_StochSim_T1$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_T1$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "NM Model, Type I Functional Response (With b (1st Parameterization))")
lines(NM_StochSim_T1$Time, NM_StochSim_T1$ImmuneCells, col = "firebrick2")
```

Okay, I tried to fit the model with the Type I response to the third time series (considering the first two are very short), and it was also too short! Didn't work! See code below.

```{r, eval = FALSE}
## With b (2nd Parameterization)
NM_StochSim_T1 <- read_csv("Chapter1Review/Data/NM_StochSim_T1_3.csv"); head(NM_StochSim_T1)
First0 <- which(NM_StochSim_T1$Parasites == 0); First0 <- First0[1]-1; NM_StochSim_T1 <- NM_StochSim_T1[1:First0, ]
N <- length(NM_StochSim_T1$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_T1$Parasites[1], NM_StochSim_T1$ImmuneCells[1])
y <- as.matrix(NM_StochSim_T1[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_T1 <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_T1_With-b.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_T1, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_T1_With-b-2_FitObj.rds")
```

#### Outcome:

This didn't work, not because the model was necessarily hard to fit, but because the stochastic time series weren't long enough. I could try again with deterministic time series.

## 2. Autoregressive model: Compare true and estimated data in a plot like you did with global model to identify potential structural unidentifiability

Okay, so, here's the data we gave the autoregressive model:

```{r}
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (LONG)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")
```

And here's the fit we got, using an autoregressive framework:

```{r}
fit <- readRDS("Chapter1Review/FitObjs/NM_DamOsc_14_FitObj.rds")

## Summarise the fit
fitSumm <- print(fit, pars = c("r", "b", "c", "u"),
                 probs=c(0.1, 0.5, 0.9), digits = 3)

#     mean se_mean     sd    10%    50%    90% n_eff  Rhat
# r  0.794   0.001  0.029  0.759  0.795  0.830   751 1.000
# b 62.857   0.740 16.276 42.479 62.628 84.084   484 1.010
# c  0.195   0.001  0.020  0.170  0.194  0.220   635 1.001
# u  0.339   0.003  0.076  0.246  0.333  0.438   473 1.011

## Viz
pars <- c("r", "b", "c", "u")
stan_trace(fit, pars)
mcmc_pairs(fit, pars)
mcmc_dens(fit, pars) 
```

Now, let's compare the data to the estimates. If the data and estimates are comparable, we have an unidentifiability problem.

```{r}
output <- rstan::extract(fit, permuted = TRUE, include = TRUE)
r_mean <- mean(output$r)
b_mean <- mean(output$b)
c_mean <- mean(output$c)
u_mean <- mean(output$u)

P <- c(NM_StochSim_DamOsc$Parasites[1]); H <- c(NM_StochSim_DamOsc$ImmuneCells[1])

for (t in 2:nrow(NM_StochSim_DamOsc)){
  P[t] <- P[t-1] + r_mean*P[t-1] - (1-exp((-0.008/(1 + 0.008*0.06*P[t-1]))*H[t-1]))*P[t-1]
  H[t] <- H[t-1] + b_mean + c_mean*(0.008*P[t-1]/(1 + 0.008*P[t-1]*0.06))*H[t-1] - (1-exp(-u_mean))*H[t-1]
}

df <- as.data.frame(cbind(seq(1, nrow(NM_StochSim_DamOsc), 1), NM_StochSim_DamOsc$Parasites, NM_StochSim_DamOsc$ImmuneCells, P, H))
colnames(df) <- c("t", "real_P", "real_H", "est_P", "est_H")

plot(df$t, df$real_P, type = "l", col = "cornflowerblue", ylim = c(0, max(df$real_H)), xlab = "Time", ylab = "Population Abundance")
lines(df$t, df$real_H, col = "firebrick2")
lines(df$t, df$est_P, col = "cornflowerblue", lty = 2)
lines(df$t, df$est_H, col = "firebrick2", lty = 2)
```

### Outcome:

The parameter estimates made by the autoregressive model do not replicate the data given to the model. It seems a good idea to return to this model, and make sure it's written correctly. As it stands, the model seems to think it knows what it's doing, but it doesn't.

## 3. Fit NM model to deterministic data

Here's some deterministic data:

```{r}
NowakMay_T2_Dam <- function(t,y,p){
  r <- p[1]; O <- p[2]; h <- p[3]
  b <- p[4]; c <- p[5]; u <- p[6]
  P <- y[1]; H <- y[2]
  dP = P*r - H*(O*P/(1 + O*P*h))
  dH = b + H*(c*(O*P/(1 + O*P*h)) - u)
  list(c(dP, dH))
}
r <- 2.5; O <- 0.008; h <- 0.06
b <- 35; c <- 0.2; u <- 0.2
parms <- c(r, O, h, b, c, u)
P0 <- 80; H0 <- 200 
N0 <- c(P0, H0)
TT <- seq(0, 100, 1) 
results <- lsoda(N0, TT, NowakMay_T2_Dam, parms)
NM_DetSim <- data.frame(results); colnames(NM_DetSim) <- c("Time", "Parasites", "ImmuneCells")

write_csv(NM_DetSim, "Chapter1Review/Data/NM_DetSim_DamOsc.csv")

plot(NM_DetSim$Time, NM_DetSim$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_DetSim$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations")
lines(NM_DetSim$Time, NM_DetSim$ImmuneCells, col = "firebrick2")
```

Now, let's use these data to fit the model. We'll start with 6 free parameters.

```{r}
## Data
NM_DetSim <- read_csv("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Data/NM_DetSim_DamOsc.csv"); head(NM_DetSim)
N <- length(NM_DetSim$Time) - 1
ts <- 1:N
y_init <- c(NM_DetSim$Parasites[1], NM_DetSim$ImmuneCells[1])
y <- as.matrix(NM_DetSim[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])

NM_DetSim <- list(N = N, ts = ts, y_init = y_init, y = y)

## Compile model
model <- stan_model("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/Stan_Models/NM_DamOsc_3.stan")

## Fitting
fit <- sampling(model, data = NM_DetSim, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FitObjs/NM_DetSim_DamOsc_FitObj.rds")
```

```{r}
fit <- readRDS("/Users/mjarviscross/Desktop/Github/FcnalRespProj/Chapter1Review/FitObjs/NM_DetSim_DamOsc_FitObj.rds")

## Summarise the fit
fitSumm <- print(fit, pars = c("theta", "sigma", "z_init"),
                 probs=c(0.1, 0.5, 0.9), digits = 3)

#              mean se_mean    sd     10%     50%     90% n_eff  Rhat
# theta[1]    2.917   0.019 0.408   2.442   2.884   3.444   448 1.009
# theta[2]    0.010   0.000 0.001   0.008   0.010   0.012   466 1.009
# theta[3]    0.028   0.001 0.026   0.003   0.017   0.063   481 1.002
# theta[4]   25.357   0.404 8.647  16.058  23.771  37.188   459 1.004
# theta[5]    0.248   0.004 0.079   0.161   0.238   0.343   461 1.008
# theta[6]    0.186   0.002 0.036   0.146   0.180   0.234   405 1.006
# sigma[1]    0.573   0.001 0.044   0.518   0.569   0.629  1243 1.005
# sigma[2]    0.083   0.000 0.006   0.076   0.083   0.091  1437 1.001
# z_init[1]  52.458   0.204 7.485  43.473  51.791  62.297  1347 0.999
# z_init[2] 223.265   0.339 9.173 171.701 223.451 234.972   737 1.007

## Viz
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(fit, pars)
mcmc_pairs(fit, pars)
mcmc_dens(fit, pars)
```

For comparison, here's the fit to demographically stochastic data:

```{r}
fit <- readRDS("Chapter1Review/FitObjs/NM_DamOsc_3_FitObj.rds")

## Summarise the fit
fitSumm <- print(fit, pars = c("theta", "sigma", "z_init"),
                 probs=c(0.1, 0.5, 0.9), digits = 3)

#              mean se_mean    sd     10%     50%     90% n_eff  Rhat
# theta[1]    2.917   0.019 0.408   2.442   2.884   3.444   448 1.009
# theta[2]    0.010   0.000 0.001   0.008   0.010   0.012   466 1.009
# theta[3]    0.028   0.001 0.026   0.003   0.017   0.063   481 1.002
# theta[4]   25.357   0.404 8.647  16.058  23.771  37.188   459 1.004
# theta[5]    0.248   0.004 0.079   0.161   0.238   0.343   461 1.008
# theta[6]    0.186   0.002 0.036   0.146   0.180   0.234   405 1.006
# sigma[1]    0.573   0.001 0.044   0.518   0.569   0.629  1243 1.005
# sigma[2]    0.083   0.000 0.006   0.076   0.083   0.091  1437 1.001
# z_init[1]  52.458   0.204 7.485  43.473  51.791  62.297  1347 0.999
# z_init[2] 223.265   0.339 9.173 171.701 223.451 234.972   737 1.007

## Viz
pars <- c("theta[1]", "theta[2]", "theta[3]", "theta[4]", "theta[5]", "theta[6]")
stan_trace(fit, pars)
mcmc_pairs(fit, pars)
mcmc_dens(fit, pars)
```

## 4. Look at how changing single parameters values ($\theta$, $h$, maybe $c$) change the timeseries data

## 5. Fit NM model to a few different stochastic time series

Let's start by generating a few stochastic time series:

```{r}
# First, the original data:
x0 <- c(P = 80, H = 200) 
a <- c("P*r",
       "H*(O*P/1 + O*P*h)", 
       "b + H*c*(O*P/1 + O*P*h)",
       "H*u")
nu <- matrix(c(+1,-1,0,0,
               0,0,+1,-1), nrow = 2, byrow = TRUE)
r = 2.5; O = 0.008; h = 0.06; b = 35; c = 0.2; u = 0.2
parms1 <- c(r = r, O = O, h = h, b = b, c = c, u = u)
tf = 100
method <- "OTL"
simName <- "NowakMay_T2_Dam"
set.seed(5)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 2nd time series
set.seed(9)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc_2.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 2)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 3rd time series
set.seed(10)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")
write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc_3.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 3)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 4th time series
set.seed(13)
NowakMay_T2_Dam_SLC <- suppressWarnings(ssa(x0, a, nu, parms1, tf, method, simName,
                                            verbose = FALSE, 
                                            consoleInterval = 1, 
                                            censusInterval = 1, 
                                            maxWallTime = 30, 
                                            ignoreNegativeState = TRUE)) 
NM_StochSim_DamOsc <- NowakMay_T2_Dam_SLC$data 
NM_StochSim_DamOsc <- as.data.frame(NM_StochSim_DamOsc)
colnames(NM_StochSim_DamOsc) <- c("Time", "Parasites", "ImmuneCells")

FirstZero <- which(NM_StochSim_DamOsc$Parasites == 0)[1]
NM_StochSim_DamOsc <- NM_StochSim_DamOsc[1:FirstZero - 1, ]


write_csv(NM_StochSim_DamOsc, file = "Chapter1Review/Data/NM_StochSim_DamOsc_4.csv")

plot(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, type = "l", col = "cornflowerblue", ylim = c(0, max(NM_StochSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 4)")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")
```

Okay, now, let's compare these to the deterministic simulation:

```{r}
# 1st time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 1)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 2nd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_2.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 2)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 3rd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_3.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 3)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

# 4th time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_4.csv")
plot(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$Parasites, type = "l", col = "navy", ylim = c(0, max(NM_DetSim_DamOsc$ImmuneCells)), xlab = "Time", ylab = "Population Abundance", main = "Parameterization: Damping Oscillations (Time Series 4)")
lines(NM_DetSim_DamOsc$Time, NM_DetSim_DamOsc$ImmuneCells, col = "darkred")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$Parasites, col = "cornflowerblue")
lines(NM_StochSim_DamOsc$Time, NM_StochSim_DamOsc$ImmuneCells, col = "firebrick2")

```

As we can see, the oscillations in Time Series 2 and Time Series 3 are pretty offset from the oscillations in the deterministic simulation. So, let's fit the model to Time Series 2, 3, and 4, and see what happens.

```{r}
# 2nd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_2.csv"); head(NM_StochSim_DamOsc)
N <- length(NM_StochSim_DamOsc$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_DamOsc$Parasites[1], NM_StochSim_DamOsc$ImmuneCells[1])
y <- as.matrix(NM_StochSim_DamOsc[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_DamOsc <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_DamOsc_3.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_DamOsc, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_DamOsc_TS2_FitObj.rds")

# 3rd time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_3.csv"); head(NM_StochSim_DamOsc)
N <- length(NM_StochSim_DamOsc$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_DamOsc$Parasites[1], NM_StochSim_DamOsc$ImmuneCells[1])
y <- as.matrix(NM_StochSim_DamOsc[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_DamOsc <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_DamOsc_3.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_DamOsc, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_DamOsc_TS3_FitObj.rds")

# 4th time series
NM_StochSim_DamOsc <- read_csv("Chapter1Review/Data/NM_StochSim_DamOsc_4.csv"); head(NM_StochSim_DamOsc)
N <- length(NM_StochSim_DamOsc$Time) - 1
ts <- 1:N
y_init <- c(NM_StochSim_DamOsc$Parasites[1], NM_StochSim_DamOsc$ImmuneCells[1])
y <- as.matrix(NM_StochSim_DamOsc[2:(N + 1), 2:3])
y <- cbind(y[ , 1], y[ , 2])
NM_StochSim_DamOsc <- list(N = N, ts = ts, y_init = y_init, y = y)
## Compile model
model <- stan_model("Chapter1Review/Stan_Models/NM_DamOsc_3.stan")
## Fitting
fit <- sampling(model, data = NM_StochSim_DamOsc, chains = 2, iter = 1000, cores = 2, seed = 123)
saveRDS(fit, file = "Chapter1Review/FitObjs/NM_StochSim_DamOsc_TS4_FitObj.rds")
```
